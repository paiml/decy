---
roadmap:
  title: "C Language Validation Roadmap - EXTREME TDD"
  goal: "Document every C construct transformation to idiomatic Rust with minimal unsafe"
  methodology: "EXTREME TDD (Test-First, RED-GREEN-REFACTOR)"
  reference: "ISO C99 Standard (ISO/IEC 9899:1999) + K&R C (2nd Edition)"
  status: "IN_PROGRESS"
  completion: "20%"
  unsafe_blocks_per_1000_loc_target: "<5"

  statistics:
    total_tasks: 150
    completed: 56
    partial_support: 0
    in_progress: 0
    blocked: 1
    not_started: 93
    coverage_percent: 37

extreme_tdd_workflow:
  description: "Standard workflow for each task"
  steps:
    - id: 1
      name: "RED"
      description: "Write failing test first"
      example: |
        #[test]
        fn test_<feature>_transformation() {
            let c_code = "<C input>";
            let expected_rust = "<expected rust>";

            let result = transpile(c_code)?;
            assert_eq!(result, expected_rust);

            // Verify unsafe block count
            let unsafe_count = count_unsafe_blocks(&result);
            assert!(unsafe_count <= MAX_UNSAFE_PER_MODULE);
        }

    - id: 2
      name: "GREEN"
      description: "Implement transformation"
      substeps:
        - "Update parser for C construct (decy-parser)"
        - "Update HIR representation (decy-hir)"
        - "Update analyzer for safety checks (decy-analyzer)"
        - "Update ownership inference (decy-ownership)"
        - "Update codegen (decy-codegen)"
        - "Verify safety properties (decy-verify)"

    - id: 3
      name: "REFACTOR"
      description: "Clean up implementation and minimize unsafe"
      substeps:
        - "Extract common patterns"
        - "Add helper functions"
        - "Document edge cases"
        - "Reduce unsafe blocks through better ownership inference"
        - "Add SAFETY comments to remaining unsafe blocks"

    - id: 4
      name: "DOCUMENT"
      description: "Add to examples and documentation"
      substeps:
        - "Update examples/"
        - "Add to test fixtures"
        - "Update CHANGELOG.md"
        - "Document unsafe rationale if any remain"

stop_the_line_protocol:
  description: "ANDON CORD - Pull when validation reveals bugs"
  trigger_conditions:
    - "Transpiled code doesn't compile"
    - "Transpiled code has different behavior than C"
    - "Unsafe block count exceeds target"
    - "Parser fails on valid C99 construct"
    - "Ownership inference creates memory leak"
    - "Verification stage fails safety checks"

  procedure:
    - step: 1
      action: "STOP all feature development immediately"
      responsible: "Developer who discovered issue"

    - step: 2
      action: "Create P0 ticket in roadmap.yaml"
      template: |
        P0-<CONSTRUCT>-<NUMBER>:
          title: "[P0] Fix <construct> transpilation bug"
          type: bug
          priority: critical
          story_points: <estimated>
          status: in_progress
          phase: RED
          discovered_during_validation: true
          validation_reference: "<ISO C99 section or K&R page>"
          c_input: |
            <failing C code>
          expected_rust: |
            <correct Rust output>
          actual_rust: |
            <buggy Rust output or error>
          safety_impact: "<memory safety, undefined behavior, etc.>"

    - step: 3
      action: "Apply EXTREME TDD fix (RED-GREEN-REFACTOR)"
      requirements:
        - "Must add failing test first (RED)"
        - "Must fix with minimal implementation (GREEN)"
        - "Must meet quality gates (REFACTOR)"
        - "Must verify unsafe count didn't increase"

    - step: 4
      action: "Resume validation only after fix verified"
      verification_checklist:
        - "All tests pass (make test)"
        - "Quality gates pass (make quality-gates)"
        - "Coverage ≥80% (≥90% for decy-ownership)"
        - "Unsafe count ≤5 per 1000 LOC"
        - "Original validation case passes"

validation_references:
  primary:
    - name: "ISO C99 Standard"
      identifier: "ISO/IEC 9899:1999"
      sections: 300+
      url: "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"
      coverage: "Complete C language specification"

    - name: "K&R C (2nd Edition)"
      authors: "Brian Kernighan, Dennis Ritchie"
      isbn: "0131103628"
      chapters: 8
      appendix_sections: 6
      coverage: "Canonical C reference with examples"

  supplementary:
    - name: "GCC Documentation"
      url: "https://gcc.gnu.org/onlinedocs/gcc/"
      coverage: "Extensions and compiler-specific behavior"

    - name: "Clang Documentation"
      url: "https://clang.llvm.org/docs/"
      coverage: "AST structure and libclang API"

unsafe_minimization_strategy:
  description: "4-phase strategy to reduce unsafe blocks"
  target: "<5 unsafe blocks per 1000 LOC"

  phases:
    - id: 1
      name: "Pattern-Based"
      description: "Detect common patterns and generate safe Rust"
      target_reduction: "100% → 50%"
      patterns:
        - "malloc/free → Box::new()"
        - "calloc/free → Vec::with_capacity()"
        - "Array allocation → Vec"
        - "String allocation → String/CString"
      status: "IN_PROGRESS"

    - id: 2
      name: "Ownership Inference"
      description: "Infer ownership from pointer usage"
      target_reduction: "50% → 20%"
      techniques:
        - "Classify pointers: owning vs borrowing"
        - "Detect unique ownership → Box"
        - "Detect shared read-only → &T"
        - "Detect exclusive mutable → &mut T"
        - "Build pointer dataflow graph"
      status: "IN_PROGRESS"
      critical_crate: "decy-ownership"

    - id: 3
      name: "Lifetime Inference"
      description: "Infer lifetimes from C variable scopes"
      target_reduction: "20% → 10%"
      techniques:
        - "Map C scope to Rust lifetime"
        - "Generate lifetime annotations"
        - "Validate lifetime constraints"
      status: "NOT_STARTED"

    - id: 4
      name: "Safe Wrappers"
      description: "Wrap remaining unsafe in safe abstractions"
      target_reduction: "10% → <5%"
      techniques:
        - "Create safe wrapper functions"
        - "Add SAFETY comments for audit trail"
        - "Document invariants"
      status: "NOT_STARTED"

chapters:
  # Based on ISO C99 Standard structure

  - id: 1
    name: "Scope & Terms (C99 §1-4)"
    description: "Foundational definitions and conformance"
    tasks:
      - id: "SCOPE-001"
        title: "Document C99 conformance scope"
        status: "completed"
        version: "v0.1.0"
        notes: "DECY targets C99 as baseline, with selective GCC extensions"
        validation_reference: "ISO C99 §1-2"

  - id: 2
    name: "Lexical Elements (C99 §6.4)"
    description: "Tokens, keywords, identifiers, constants"
    sections:
      - id: "2.1"
        name: "Keywords (C99 §6.4.1)"
        tasks:
          - id: "LEX-KW-001"
            title: "Document C keywords to Rust keywords mapping"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "int x;"
                rust: "let x: i32;"
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
              - c: "return 0;"
                rust: "return 0;"
            validation_reference: "K&R §2.1, ISO C99 §6.4.1"

      - id: "2.2"
        name: "Identifiers (C99 §6.4.2)"
        tasks:
          - id: "LEX-ID-001"
            title: "Document identifier naming rules"
            status: "completed"
            version: "v0.1.0"
            notes: "C identifiers map to Rust snake_case for variables/functions, PascalCase for types"
            validation_reference: "K&R §2.2, ISO C99 §6.4.2"

      - id: "2.3"
        name: "Constants (C99 §6.4.4)"
        tasks:
          - id: "LEX-CONST-INT"
            title: "Document integer constants"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "int x = 42;"
                rust: "let x: i32 = 42;"
              - c: "long y = 42L;"
                rust: "let y: i64 = 42;"
              - c: "unsigned int z = 42U;"
                rust: "let z: u32 = 42;"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.1"
            test_name: "test_integer_literal_transformation"

          - id: "LEX-CONST-FLOAT"
            title: "Document floating-point constants"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "float pi = 3.14f;"
                rust: "let pi: f32 = 3.14;"
              - c: "double e = 2.718;"
                rust: "let e: f64 = 2.718;"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.2"
            test_name: "test_float_literal_transformation"

          - id: "LEX-CONST-CHAR"
            title: "Document character constants"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "char c = 'A';"
                rust: "let c: u8 = b'A';"
              - c: "char newline = '\\n';"
                rust: "let newline: u8 = b'\\n';"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.4"
            test_name: "test_char_literal_transformation"

          - id: "LEX-CONST-STR"
            title: "Document string literals"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "char* msg = \"Hello\";"
                rust: "let msg: &str = \"Hello\";"
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
            validation_reference: "K&R §2.3, ISO C99 §6.4.5"
            test_name: "test_string_literal_transformation"

  - id: 3
    name: "Types (C99 §6.2.5, §6.7)"
    description: "Basic types, derived types, type qualifiers"
    sections:
      - id: "3.1"
        name: "Basic Types (C99 §6.2.5)"
        tasks:
          - id: "TYPE-BASIC-INT"
            title: "Document integer types"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "char c;"
                rust: "let c: i8;"
              - c: "short s;"
                rust: "let s: i16;"
              - c: "int i;"
                rust: "let i: i32;"
              - c: "long l;"
                rust: "let l: i64;"
              - c: "unsigned int u;"
                rust: "let u: u32;"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_integer_type_mapping"

          - id: "TYPE-BASIC-FLOAT"
            title: "Document floating-point types"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "float f;"
                rust: "let f: f32;"
              - c: "double d;"
                rust: "let d: f64;"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_float_type_mapping"

          - id: "TYPE-BASIC-VOID"
            title: "Document void type"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "void func(void) {}"
                rust: "fn func() {}"
              - c: "void* ptr;"
                rust: "let ptr: *mut u8;"
                note: "void* requires unsafe handling"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_void_type_mapping"

          - id: "TYPE-BASIC-BOOL"
            title: "Document boolean type"
            status: "completed"
            priority: "high"
            version: "v0.31.0"
            examples:
              - c: "#include <stdbool.h>\nbool flag = true;"
                rust: "let flag = true;"
                note: "Built-in bool type, no header needed"
              - c: "int flag = 1; if (flag) {}"
                rust: "let flag = true; if flag {}"
                note: "Pre-C99 int as bool → explicit bool"
              - c: "int x = (int)flag;"
                rust: "let x = flag as i32;"
                note: "Explicit conversion required"
              - c: "bool b = (x != 0);"
                rust: "let b = x != 0;"
                note: "Explicit comparison for int to bool"
            validation_reference: "ISO C99 §7.16 (stdbool.h), K&R (pre-C99)"
            test_name: "test_bool_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 bool → Rust bool (built-in). Same size (1 byte), same semantics. No implicit int conversions (type-safe). No bitwise operators on bool. Pre-C99 int flags → explicit bool."

          - id: "TYPE-BASIC-LONGLONG"
            title: "Document long long type"
            status: "completed"
            priority: "high"
            version: "v0.40.0"
            examples:
              - c: "long long x = 42LL;"
                rust: "let x: i64 = 42;"
                note: "C99 long long → Rust i64 (exactly 64 bits)"
              - c: "unsigned long long y = 42ULL;"
                rust: "let y: u64 = 42;"
                note: "Unsigned variant"
              - c: "long long timestamp = 1609459200000000000LL;"
                rust: "let timestamp: i64 = 1609459200000000000;"
                note: "Common use: nanosecond timestamps"
              - c: "long long file_size = 5368709120LL;"
                rust: "let file_size: i64 = 5368709120;"
                note: "Common use: file sizes > 4GB"
            validation_reference: "ISO C99 §6.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_long_long_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R had no standard 64-bit type. C99 added long long (at least 64 bits). Rust i64/u64 exactly 64 bits. C signed overflow = undefined behavior, Rust panics in debug/wraps in release. Use checked/wrapping methods. Common uses: timestamps, file sizes, large counters. 64-bit arithmetic native on modern CPUs."

      - id: "3.2"
        name: "Derived Types - Pointers (C99 §6.7.5.1)"
        tasks:
          - id: "TYPE-PTR-BASIC"
            title: "Document basic pointer types"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p;"
                rust: "let p: &i32;"
                note: "Or &mut i32 or Box<i32> depending on ownership"
            validation_reference: "K&R §5.1, ISO C99 §6.7.5.1"
            test_name: "test_pointer_type_basic"
            ownership_inference: "CRITICAL"

          - id: "TYPE-PTR-MALLOC"
            title: "Document malloc/free pattern → Box"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p = malloc(sizeof(int)); free(p);"
                rust: "let p = Box::new(0i32);"
                unsafe_count: 0
            validation_reference: "K&R §8.7, ISO C99 §7.20.3"
            test_name: "test_malloc_to_box_transformation"
            completed_ticket: "DECY-044"

          - id: "TYPE-PTR-ARRAY"
            title: "Document array allocation → Vec"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* arr = malloc(n * sizeof(int)); free(arr);"
                rust: "let arr = vec![0i32; n];"
                unsafe_count: 0
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_array_malloc_to_vec"

          - id: "TYPE-PTR-NULL"
            title: "Document NULL → Option"
            status: "completed"
            version: "v0.4.0"
            examples:
              - c: "int* p = NULL; if (p) { ... }"
                rust: "let p: Option<Box<i32>> = None; if let Some(p) = p { ... }"
                unsafe_count: 0
            validation_reference: "K&R §5.4, ISO C99 §7.17"
            test_name: "test_null_to_option"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"

          - id: "TYPE-FUNC-PTR"
            title: "Document function pointers"
            status: "completed"
            priority: "high"
            version: "v0.32.0"
            examples:
              - c: "int (*fp)(int, int);"
                rust: "let fp: fn(i32, i32) -> i32;"
                note: "Function pointer type (NOT nullable)"
              - c: "int (*fp)(int) = NULL;"
                rust: "let fp: Option<fn(i32) -> i32> = None;"
                note: "Nullable function pointer → Option<fn>"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
                note: "Function pointer typedef"
              - c: "struct Handler { int (*callback)(int); };"
                rust: "struct Handler { callback: fn(i32) -> i32 }"
                note: "Function pointer in struct"
            validation_reference: "K&R §5.11, §5.12, ISO C99 §6.7.5.3"
            test_name: "test_function_pointers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Function pointers → fn types (SAFE). NOT nullable (use Option<fn>). Type-safe (no unsafe casts). Separate from closures (Fn/FnMut/FnOnce). Common patterns: callbacks, strategy pattern, virtual dispatch, higher-order functions."

      - id: "3.3"
        name: "Derived Types - Arrays (C99 §6.7.5.2)"
        tasks:
          - id: "TYPE-ARRAY-FIXED"
            title: "Document fixed-size arrays"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "int arr[10];"
                rust: "let arr: [i32; 10] = [0; 10];"
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_fixed_array_transformation"

          - id: "TYPE-ARRAY-VLA"
            title: "Document variable-length arrays → Vec"
            status: "completed"
            version: "v0.9.0"
            priority: "high"
            examples:
              - c: "int n = 10; int arr[n];"
                rust: "let n = 10; let arr = vec![0i32; n];"
            validation_reference: "ISO C99 §6.7.5.2 (VLA)"
            test_name: "test_vla_to_vec"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"
            unsafe_blocks: 0

      - id: "3.4"
        name: "Derived Types - Structs (C99 §6.7.2.1)"
        tasks:
          - id: "TYPE-STRUCT-BASIC"
            title: "Document struct definition"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "struct Point { int x; int y; };"
                rust: "struct Point { x: i32, y: i32 }"
            validation_reference: "K&R §6.1, ISO C99 §6.7.2.1"
            test_name: "test_struct_definition"

          - id: "TYPE-STRUCT-NESTED"
            title: "Document nested structs"
            status: "completed"
            version: "v0.15.0"
            priority: "medium"
            examples:
              - c: "struct Outer { struct Inner { int x; } inner; };"
                rust: "struct Inner { x: i32 } struct Outer { inner: Inner }"
            validation_reference: "K&R §6.2, ISO C99 §6.7.2.1"
            test_name: "test_nested_struct"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "TYPE-FLEXIBLE-ARRAY"
            title: "Document flexible array members"
            status: "completed"
            priority: "high"
            version: "v0.35.0"
            examples:
              - c: "struct Buffer { size_t len; char data[]; };"
                rust: "struct Buffer { len: usize, data: Vec<u8> }"
                note: "Flexible array member → Vec"
              - c: "malloc(sizeof(struct Buffer) + n);"
                rust: "Buffer { len: n, data: vec![0; n] }"
                note: "Allocation → Vec with capacity"
              - c: "struct Packet { int id; uint8_t payload[]; };"
                rust: "struct Packet { id: i32, payload: Vec<u8> }"
                note: "Variable-length payload"
            validation_reference: "ISO C99 §6.7.2.1 paragraph 16 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_flexible_array_members"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 flexible array members → Rust Vec<T>. Must be last member in C99, no such restriction in Rust. Automatic memory management. Bounds checking. Alternative patterns: &[T] for borrowed data, Box<[T]> for fixed-size heap slice."

          - id: "TYPE-UNION"
            title: "Document union → enum"
            status: "completed"
            priority: "high"
            version: "v0.27.0"
            examples:
              - c: "union Value { int i; float f; };"
                rust: "enum Value { Int(i32), Float(f32) }"
                note: "Type-safe enum instead of unsafe union"
              - c: "struct Tagged { int type; union { int i; float f; } data; };"
                rust: "enum Tagged { Int(i32), Float(f32) }"
                note: "Discriminated union → enum"
              - c: "union FFI { int i; };"
                rust: "#[repr(C)] union FFI { i: i32 }"
                note: "FFI union requires unsafe to read"
            validation_reference: "K&R §6.8, ISO C99 §6.7.2.1"
            test_name: "test_union_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Unions transform to enums (SAFE) for type safety. Discriminated unions become enums with built-in tag. FFI unions use #[repr(C)] union (unsafe to read). Option/Result replace common tagged union patterns."

          - id: "TYPE-ENUM"
            title: "Document enum types"
            status: "completed"
            priority: "high"
            version: "v0.30.0"
            examples:
              - c: "enum Color { RED, GREEN, BLUE };"
                rust: "#[repr(i32)] enum Color { Red, Green, Blue }"
                note: "Type-safe enum with C representation"
              - c: "enum Status { OK = 0, ERROR = 1 };"
                rust: "#[repr(i32)] enum Status { Ok = 0, Error = 1 }"
                note: "Explicit values preserved"
              - c: "int val = status;"
                rust: "let val = status as i32;"
                note: "Explicit conversion required"
              - c: "enum { MAX = 100 };"
                rust: "const MAX: i32 = 100;"
                note: "Anonymous enum → const declarations"
            validation_reference: "K&R §2.3, ISO C99 §6.7.2.2"
            test_name: "test_enum_types"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 18
            coverage: "100%"
            unsafe_blocks: 0
            note: "C enums → Rust enums with #[repr(i32)] for C ABI. Type-safe (cannot mix with int). Exhaustiveness checking in match. Can carry data (more powerful than C). Anonymous enums → const declarations."

      - id: "3.5"
        name: "Type Qualifiers (C99 §6.7.3)"
        tasks:
          - id: "TYPE-QUAL-CONST"
            title: "Document const qualifier"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
              - c: "const int* p;"
                rust: "let p: &i32;"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_const_qualifier"

          - id: "TYPE-QUAL-VOLATILE"
            title: "Document volatile → unsafe or atomic"
            status: "completed"
            priority: "low"
            version: "v0.20.0"
            examples:
              - c: "volatile int flag;"
                rust: "AtomicI32 (safe) or ptr::read_volatile() (unsafe for MMIO)"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_volatile_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation task - Atomic types are SAFE (0 unsafe), MMIO operations require unsafe. C volatile does NOT provide atomicity."

          - id: "TYPE-QUAL-RESTRICT"
            title: "Document restrict keyword"
            status: "completed"
            priority: "high"
            version: "v0.37.0"
            examples:
              - c: "void copy(int* restrict dest, const int* restrict src, size_t n);"
                rust: "fn copy(dest: &mut [i32], src: &[i32])"
                note: "C restrict promise → Rust borrow checker enforcement"
              - c: "int* restrict ptr = malloc(n * sizeof(int));"
                rust: "let ptr = vec![0; n];"
                note: "Exclusive ownership guaranteed"
              - c: "void add(int* restrict a, int* restrict b, int* restrict c) { *a = *b + *c; }"
                rust: "fn add(a: &mut i32, b: &i32, c: &i32) { *a = *b + *c; }"
                note: "Borrow checker enforces non-aliasing"
              - c: "const int* restrict arr;"
                rust: "&[i32]"
                note: "Immutable non-aliasing reference"
            validation_reference: "ISO C99 §6.7.3.1 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_restrict_keyword"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 restrict keyword → Rust borrow checker. C restrict is PROMISE (not verified), Rust borrow checker ENFORCES non-aliasing. Violations: C = undefined behavior, Rust = compile error. Rust provides STRONGER guarantees. Same optimization benefits. &mut is conceptually 'restrict by default'."

      - id: "3.6"
        name: "Type Definitions (C99 §6.7.7)"
        tasks:
          - id: "TYPE-TYPEDEF"
            title: "Document typedef → type alias"
            status: "completed"
            priority: "high"
            version: "v0.26.0"
            examples:
              - c: "typedef int Integer;"
                rust: "type Integer = i32;"
              - c: "typedef int* IntPtr;"
                rust: "type IntPtr<'a> = &'a i32;"
              - c: "typedef struct Point { int x; int y; } Point;"
                rust: "struct Point { x: i32, y: i32 }"
                note: "Rust struct names are already types"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
            validation_reference: "K&R §6.7, ISO C99 §6.7.7"
            test_name: "test_typedef_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Type aliases for primitives, pointers (with lifetimes), structs, arrays, function pointers. Rust newtype pattern provides stronger typing than C typedef. All transformations are safe (0 unsafe blocks)."

      - id: "3.7"
        name: "Initialization (C99 §6.7.8)"
        tasks:
          - id: "TYPE-INIT-DESIGNATED"
            title: "Document designated initializers"
            status: "completed"
            priority: "high"
            version: "v0.33.0"
            examples:
              - c: "struct Point p = { .x = 10, .y = 20 };"
                rust: "let p = Point { x: 10, y: 20 };"
                note: "Designated initializer → struct literal"
              - c: "struct Point p = { .x = 10 };"
                rust: "let p = Point { x: 10, ..Default::default() };"
                note: "Partial initialization → Default trait"
              - c: "int arr[5] = { [0] = 1, [4] = 5 };"
                rust: "let mut arr = [0; 5]; arr[0] = 1; arr[4] = 5;"
                note: "Array designators → manual initialization"
              - c: "struct Outer o = { .inner = { .x = 1 } };"
                rust: "let o = Outer { inner: Inner { x: 1 } };"
                note: "Nested designated initializers"
            validation_reference: "ISO C99 §6.7.8.17-38 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_designated_initializers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 designated initializers → Rust struct literals. Syntax: .field = value → field: value. Partial init requires Default trait. No array designators (manual init). Order independent. Type-safe field names."

  - id: 4
    name: "Expressions (C99 §6.5)"
    description: "Operators, precedence, evaluation"
    sections:
      - id: "4.1"
        name: "Primary Expressions (C99 §6.5.1)"
        tasks:
          - id: "EXPR-PRIMARY-ID"
            title: "Document identifier expressions"
            status: "completed"
            version: "v0.1.0"
            validation_reference: "K&R §2.1, ISO C99 §6.5.1"

      - id: "4.2"
        name: "Postfix Operators (C99 §6.5.2)"
        tasks:
          - id: "EXPR-POSTFIX-ARRAY"
            title: "Document array subscripting"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "arr[i]"
                rust: "arr[i]"
            validation_reference: "K&R §5.2, ISO C99 §6.5.2.1"
            test_name: "test_array_subscript"

          - id: "EXPR-COMPOUND-LITERAL"
            title: "Document compound literals"
            status: "completed"
            priority: "high"
            version: "v0.34.0"
            examples:
              - c: "(struct Point){ .x = 10, .y = 20 }"
                rust: "Point { x: 10, y: 20 }"
                note: "No cast syntax needed in Rust"
              - c: "draw((struct Point){ .x = 1, .y = 2 });"
                rust: "draw(Point { x: 1, y: 2 });"
                note: "Temporary struct as function argument"
              - c: "(int[]){ 1, 2, 3, 4, 5 }"
                rust: "[1, 2, 3, 4, 5]"
                note: "Array literal (no cast needed)"
              - c: "struct Point* p = &(struct Point){ .x = 1 };"
                rust: "let temp = Point { x: 1, y: 0 }; let p = &temp;"
                note: "Reference to temporary"
            validation_reference: "ISO C99 §6.5.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_compound_literals"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 compound literals → Rust struct/array literals. No (Type){} cast syntax needed. Automatic storage duration. Can be modified (lvalue). Combines with designated initializers. Rust temporaries have clear lifetime rules."

          - id: "EXPR-POSTFIX-CALL"
            title: "Document function calls"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "func(x, y)"
                rust: "func(x, y)"
            validation_reference: "K&R §4.2, ISO C99 §6.5.2.2"
            test_name: "test_function_call"

          - id: "EXPR-POSTFIX-MEMBER"
            title: "Document struct member access"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "point.x"
                rust: "point.x"
              - c: "point->x"
                rust: "point.x"
                note: "Pointer dereference eliminated with ownership"
            validation_reference: "K&R §6.1, ISO C99 §6.5.2.3"
            test_name: "test_member_access"

          - id: "EXPR-POSTFIX-INCR"
            title: "Document post-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.10.0"
            examples:
              - c: "x++"
                rust: "{ let tmp = x; x += 1; tmp }"
              - c: "x--"
                rust: "{ let tmp = x; x -= 1; tmp }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.2.4"
            test_name: "test_postfix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

      - id: "4.3"
        name: "Unary Operators (C99 §6.5.3)"
        tasks:
          - id: "EXPR-UNARY-INCR"
            title: "Document pre-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.11.0"
            examples:
              - c: "++x"
                rust: "{ x += 1; x }"
              - c: "--x"
                rust: "{ x -= 1; x }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.3.1"
            test_name: "test_prefix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "EXPR-UNARY-ADDR"
            title: "Document address-of operator (&)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "&x"
                rust: "&x"
                note: "Safe borrow in Rust"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_address_of"

          - id: "EXPR-UNARY-DEREF"
            title: "Document dereference operator (*)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "*p"
                rust: "*p"
                note: "Safe with references, may need unsafe with raw pointers"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_dereference"

          - id: "EXPR-UNARY-SIZEOF"
            title: "Document sizeof operator"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "sizeof(int)"
                rust: "std::mem::size_of::<i32>()"
              - c: "sizeof(x)"
                rust: "std::mem::size_of_val(&x)"
            validation_reference: "K&R §5.4, ISO C99 §6.5.3.4"
            test_name: "test_sizeof_expression"
            completed_ticket: "DECY-044"

          - id: "EXPR-CAST"
            title: "Document cast operators"
            status: "completed"
            priority: "high"
            version: "v0.29.0"
            examples:
              - c: "int i = (int)3.14;"
                rust: "let i = 3.14 as i32;"
                note: "Numeric cast uses as operator (SAFE)"
              - c: "unsigned u = (unsigned)-1;"
                rust: "let u = -1i32 as u32;"
                note: "Wrapping is well-defined"
              - c: "int bits = *(int*)&f;"
                rust: "let bits = f.to_bits();"
                note: "Type punning has safe methods"
              - c: "void* vp = (void*)ptr;"
                rust: "let vp = ptr as *const ();"
                note: "Pointer casts safe to create, unsafe to deref"
            validation_reference: "K&R §2.7, ISO C99 §6.5.4"
            test_name: "test_cast_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "Cast operators → as operator (SAFE for most casts). Numeric conversions explicit and well-defined. Type punning has safe methods (to_bits). Only transmute requires unsafe. From/Into traits for struct conversions."

      - id: "4.4"
        name: "Arithmetic Operators (C99 §6.5.5-6.5.7)"
        tasks:
          - id: "EXPR-ARITH-BINARY"
            title: "Document binary arithmetic"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "a + b"
                rust: "a + b"
              - c: "a * b"
                rust: "a * b"
              - c: "a / b"
                rust: "a / b"
                note: "Rust panics on division by zero (safer)"
            validation_reference: "K&R §2.5, ISO C99 §6.5.5-6"
            test_name: "test_arithmetic_operators"

          - id: "EXPR-ARITH-PTR"
            title: "Document pointer arithmetic → slice indexing"
            status: "blocked"
            phase: "RED"
            priority: "high"
            examples:
              - c: "p + 1"
                rust: "&arr[i + 1]"
                note: "Eliminate pointer arithmetic with slices"
            validation_reference: "K&R §5.3, ISO C99 §6.5.6"
            test_name: "test_pointer_arithmetic_safe"
            sprint: 3
            ownership_inference: "CRITICAL"
            red_phase_date: "2025-10-15"
            tests_added: 9
            tests_passing: 1
            tests_failing: 8
            blocked_reason: "Requires ownership inference infrastructure (pointer dataflow, array detection, pointer classification)"
            implementation_plan: "docs/EXPR-ARITH-PTR-implementation-plan.md"
            note: "RED phase complete - paused pending ownership inference foundation"

          - id: "EXPR-BITWISE"
            title: "Document bitwise operators"
            status: "completed"
            version: "v0.25.0"
            priority: "high"
            examples:
              - c: "a & b"
                rust: "a & b"
              - c: "a | b"
                rust: "a | b"
              - c: "a ^ b"
                rust: "a ^ b"
              - c: "~a"
                rust: "!a"
                note: "C uses ~, Rust uses ! for bitwise NOT"
              - c: "a << n"
                rust: "a << n"
              - c: "a >> n"
                rust: "a >> n"
            validation_reference: "K&R §2.9, ISO C99 §6.5.10-6.5.12"
            test_name: "test_bitwise_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Bitwise operators (&, |, ^, ~, <<, >>) for bit manipulation, flags, masks. All operations are safe. Syntax identical to C except NOT (~→!). Type-safe signed/unsigned handling."

      - id: "4.5"
        name: "Comparison Operators (C99 §6.5.8-6.5.9)"
        tasks:
          - id: "EXPR-CMP-RELATIONAL"
            title: "Document relational operators"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "a < b"
                rust: "a < b"
              - c: "a >= b"
                rust: "a >= b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.8"
            test_name: "test_relational_operators"

          - id: "EXPR-CMP-EQUALITY"
            title: "Document equality operators"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "a == b"
                rust: "a == b"
              - c: "a != b"
                rust: "a != b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.9"
            test_name: "test_equality_operators"

      - id: "4.6"
        name: "Logical Operators (C99 §6.5.13-6.5.14)"
        tasks:
          - id: "EXPR-LOGICAL-AND"
            title: "Document logical AND (&&)"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "a && b"
                rust: "a && b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.13"
            test_name: "test_logical_and"

          - id: "EXPR-LOGICAL-OR"
            title: "Document logical OR (||)"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "a || b"
                rust: "a || b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.14"
            test_name: "test_logical_or"

          - id: "EXPR-TERNARY"
            title: "Document ternary operator (? :)"
            status: "completed"
            priority: "high"
            version: "v0.28.0"
            examples:
              - c: "max = (a > b) ? a : b;"
                rust: "let max = if a > b { a } else { b };"
                note: "If expression replaces ternary"
              - c: "result = (x >= 90) ? 'A' : (x >= 80) ? 'B' : 'C';"
                rust: "let result = if x >= 90 { 'A' } else if x >= 80 { 'B' } else { 'C' };"
                note: "Nested ternary → if-else-if chain (more readable)"
              - c: "value = ptr ? ptr->data : default;"
                rust: "let value = ptr.map(|p| p.data).unwrap_or(default);"
                note: "Option methods for null checks"
            validation_reference: "K&R §2.11, ISO C99 §6.5.15"
            test_name: "test_ternary_operator"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Ternary operator → if expression (SAFE). Both are expressions that return values. If expression more readable for nested conditions. Short-circuits like C ternary. Type-safe: both branches must match types."

      - id: "4.7"
        name: "Assignment Operators (C99 §6.5.16)"
        tasks:
          - id: "EXPR-ASSIGN-SIMPLE"
            title: "Document simple assignment"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "x = 5"
                rust: "x = 5"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16"
            test_name: "test_simple_assignment"

          - id: "EXPR-ASSIGN-COMPOUND"
            title: "Document compound assignment"
            status: "completed"
            priority: "medium"
            version: "v0.12.0"
            examples:
              - c: "x += 5"
                rust: "x = x + 5"
                note: "HIR expands compound assignments"
              - c: "x *= 2"
                rust: "x = x * 2"
                note: "Expansion happens at HIR level"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16.2"
            test_name: "test_compound_assignment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0

  - id: 5
    name: "Statements (C99 §6.8)"
    description: "Control flow, iteration, jumps"
    sections:
      - id: "5.1"
        name: "Expression Statements (C99 §6.8.3)"
        tasks:
          - id: "STMT-EXPR"
            title: "Document expression statements"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "x = 5;"
                rust: "x = 5;"
            validation_reference: "K&R §3.2, ISO C99 §6.8.3"
            test_name: "test_expression_statement"

          - id: "STMT-MIXED-DECL"
            title: "Document mixed declarations and code"
            status: "completed"
            priority: "high"
            version: "v0.39.0"
            examples:
              - c: "int x = 10; printf(\"%d\", x); int y = 20;"
                rust: "let x = 10; println!(\"{}\", x); let y = 20;"
                note: "C99 allows declarations anywhere (C89/K&R required at block start)"
              - c: "for (int i = 0; i < n; i++) { int value = get(i); use(value); }"
                rust: "for i in 0..n { let value = get(i); use(value); }"
                note: "Declare close to first use"
              - c: "if (cond) { printf(\"yes\"); } int x = 10;"
                rust: "if cond { println!(\"yes\"); } let x = 10;"
                note: "Declaration after control flow"
            validation_reference: "ISO C99 §6.8 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_mixed_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R required all declarations at block start. C99 removed this restriction (major improvement). Rust always allowed declarations anywhere (like C99). Both encourage 'declare near use' principle. Reduces variable scope → fewer bugs. More natural code flow. Purely syntactic - no semantic differences."

      - id: "5.2"
        name: "Selection Statements (C99 §6.8.4)"
        tasks:
          - id: "STMT-IF"
            title: "Document if statements"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "if (x > 0) { ... }"
                rust: "if x > 0 { ... }"
              - c: "if (x) { ... } else { ... }"
                rust: "if x != 0 { ... } else { ... }"
            validation_reference: "K&R §3.2, ISO C99 §6.8.4.1"
            test_name: "test_if_statement"

          - id: "STMT-SWITCH"
            title: "Document switch → match"
            status: "completed"
            version: "v0.8.0"
            priority: "high"
            examples:
              - c: "switch (x) { case 1: ...; break; default: ...; }"
                rust: "match x { 1 => { ... }, _ => { ... } }"
              - c: "switch (x) { case 1: return 10; case 2: return 20; }"
                rust: "match x { 1 => { return 10; }, 2 => { return 20; }, _ => {} }"
            validation_reference: "K&R §3.4, ISO C99 §6.8.4.2"
            test_name: "test_switch_to_match"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0

      - id: "5.3"
        name: "Iteration Statements (C99 §6.8.5)"
        tasks:
          - id: "STMT-WHILE"
            title: "Document while loops"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "while (x < 10) { ... }"
                rust: "while x < 10 { ... }"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.1"
            test_name: "test_while_loop"

          - id: "STMT-FOR"
            title: "Document for loops"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.3"
            test_name: "test_for_loop"

          - id: "STMT-FOR-DECL"
            title: "Document for loop variable declarations"
            status: "completed"
            priority: "high"
            version: "v0.38.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
                note: "C99 allows declarations in for loop (NOT in C89/K&R)"
              - c: "for (int i = 0; i < 20; i += 2) { ... }"
                rust: "for i in (0..20).step_by(2) { ... }"
                note: "Custom increment with step_by"
              - c: "for (int i = 10; i > 0; i--) { ... }"
                rust: "for i in (1..=10).rev() { ... }"
                note: "Reverse iteration"
              - c: "for (int i = 0; i < arr_len; i++) { arr[i] = ...; }"
                rust: "for (i, val) in arr.iter_mut().enumerate() { ... }"
                note: "Enumerate for index + value"
            validation_reference: "ISO C99 §6.8.5.3 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_for_loop_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 added variable declarations in for loops (NOT in C89/K&R). Both C99 and Rust scope variable to loop body. Rust range syntax more concise. Rust iterators prevent off-by-one errors. step_by for custom increment, rev() for reverse, enumerate() for index+value."

      - id: "5.4"
        name: "Jump Statements (C99 §6.8.6)"
        tasks:
          - id: "STMT-RETURN"
            title: "Document return statements"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "return 0;"
                rust: "return 0;"
            validation_reference: "K&R §4.1, ISO C99 §6.8.6.4"
            test_name: "test_return_statement"

          - id: "STMT-BREAK"
            title: "Document break statements"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "break;"
                rust: "break;"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.3"
            test_name: "test_break_statement"

          - id: "STMT-CONTINUE"
            title: "Document continue statements"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "continue;"
                rust: "continue;"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.2"
            test_name: "test_continue_statement"

          - id: "STMT-GOTO"
            title: "Document goto → eliminate or loop/match"
            status: "completed"
            priority: "low"
            version: "v0.22.0"
            examples:
              - c: "if (err) goto cleanup; ... cleanup: free(p);"
                rust: "let p = Box::new(0); // RAII cleanup via Drop"
              - c: "for (...) { if (found) goto done; } done: ..."
                rust: "'outer: for ... { break 'outer; }"
              - c: "state1: ... goto state2; state2: ..."
                rust: "loop { match state { State1 => ..., State2 => ... } }"
            validation_reference: "K&R §3.8, ISO C99 §6.8.6.1"
            test_name: "test_goto_documentation"
            sprint: 4
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - goto eliminated via Result+RAII (error handling), labeled break (nested loops), loop+match (state machines), loop+continue (retry logic), if restructuring (forward jumps). Rust has NO goto statement."

  - id: 6
    name: "Functions (C99 §6.9.1)"
    description: "Function declarations, definitions, parameters"
    tasks:
      - id: "FUNC-DECL"
        title: "Document function declarations"
        status: "completed"
        version: "v0.1.0"
        examples:
          - c: "int add(int a, int b);"
            rust: "fn add(a: i32, b: i32) -> i32;"
        validation_reference: "K&R §4.1, ISO C99 §6.9.1"
        test_name: "test_function_declaration"

      - id: "FUNC-DEF"
        title: "Document function definitions"
        status: "completed"
        version: "v0.1.0"
        examples:
          - c: "int add(int a, int b) { return a + b; }"
            rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
        validation_reference: "K&R §4.1, ISO C99 §6.9.1"
        test_name: "test_function_definition"

      - id: "FUNC-VOID-PARAMS"
        title: "Document void parameter lists"
        status: "completed"
        version: "v0.1.0"
        examples:
          - c: "void init(void) { ... }"
            rust: "fn init() { ... }"
        validation_reference: "K&R §4.1, ISO C99 §6.9.1"
        test_name: "test_void_parameters"

      - id: "FUNC-VARIADIC"
        title: "Document variadic functions"
        status: "completed"
        priority: "low"
        version: "v0.21.0"
        examples:
          - c: "int sum(int count, ...);"
            rust: "fn sum(values: &[i32]) -> i32 { values.iter().sum() }"
          - c: "int printf(const char* fmt, ...);"
            rust: "println!(...) or custom macro_rules!"
        validation_reference: "K&R §7.3, ISO C99 §6.9.1, §7.15"
        test_name: "test_variadic_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - variadic functions transform to slices (homogeneous), macros (format strings), or tuples (fixed arity). C's runtime variadic replaced with compile-time type safety."

      - id: "FUNC-INLINE"
        title: "Document inline functions"
        status: "completed"
        priority: "medium"
        version: "v0.36.0"
        examples:
          - c: "inline int add(int a, int b) { return a + b; }"
            rust: "#[inline] fn add(a: i32, b: i32) -> i32 { a + b }"
            note: "C99 inline keyword → Rust #[inline] attribute"
          - c: "static inline int max(int a, int b) { return (a > b) ? a : b; }"
            rust: "#[inline] fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }"
            note: "static inline → #[inline] with appropriate visibility"
          - c: "inline __attribute__((always_inline)) int double_value(int x) { return x * 2; }"
            rust: "#[inline(always)] fn double_value(x: i32) -> i32 { x * 2 }"
            note: "GCC always_inline → #[inline(always)]"
          - c: "__attribute__((noinline)) int complex_calculation(int x) { return x * x + x * 2 + 1; }"
            rust: "#[inline(never)] fn complex_calculation(x: i32) -> i32 { x * x + x * 2 + 1 }"
            note: "GCC noinline → #[inline(never)]"
        validation_reference: "ISO C99 §6.7.4 (new in C99), NOT in K&R (pre-C99)"
        test_name: "test_inline_functions"
        sprint: 5
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "C99 inline functions → Rust #[inline] attribute. Both are optimization hints (not guarantees). Rust compiler excellent at auto-inlining without hints. const fn provides compile-time evaluation (more powerful). Generic functions implicitly inline-eligible. All transformations SAFE (0 unsafe blocks)."

  - id: 7
    name: "Standard Library (C99 §7)"
    description: "stdio, stdlib, string, etc."
    sections:
      - id: "7.1"
        name: "stdio.h (C99 §7.19)"
        tasks:
          - id: "STDLIB-PRINTF"
            title: "Document printf → println!"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
            validation_reference: "K&R §7.2, ISO C99 §7.19.6.1"
            test_name: "test_printf_to_println"

          - id: "STDLIB-SCANF"
            title: "Document scanf → read from stdin"
            status: "completed"
            priority: "low"
            version: "v0.19.0"
            examples:
              - c: "scanf(\"%d\", &x);"
                rust: "io::stdin().read_line(&mut buffer).unwrap(); let x: i32 = buffer.trim().parse().unwrap();"
            validation_reference: "K&R §7.4, ISO C99 §7.19.6.2"
            test_name: "test_scanf_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - scanf transforms to stdin().read_line() + parse(), eliminating buffer overflow risks"

      - id: "7.2"
        name: "stdlib.h (C99 §7.20)"
        tasks:
          - id: "STDLIB-MALLOC"
            title: "Document malloc → Box/Vec"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p = malloc(sizeof(int));"
                rust: "let p = Box::new(0i32);"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.3"
            test_name: "test_malloc_to_box"
            completed_ticket: "DECY-044"

          - id: "STDLIB-FREE"
            title: "Document free → automatic Drop"
            status: "completed"
            version: "v0.6.0"
            examples:
              - c: "free(p);"
                rust: "// Automatic when Box/Vec goes out of scope"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.2"
            test_name: "test_free_elimination"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-CALLOC"
            title: "Document calloc → Vec::with_capacity"
            status: "completed"
            version: "v0.5.0"
            priority: "high"
            examples:
              - c: "int* arr = calloc(n, sizeof(int));"
                rust: "let arr = vec![0i32; n];"
            validation_reference: "ISO C99 §7.20.3.1"
            test_name: "test_calloc_to_vec"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"

          - id: "STDLIB-REALLOC"
            title: "Document realloc → Vec methods"
            status: "completed"
            version: "v0.7.0"
            priority: "medium"
            examples:
              - c: "p = realloc(p, new_size);"
                rust: "vec.resize(new_size, default);"
              - c: "p = realloc(p, 0);"
                rust: "vec.clear(); // Free equivalent"
              - c: "p = realloc(NULL, size);"
                rust: "let p = vec![0i32; count];"
            validation_reference: "ISO C99 §7.20.3.4"
            test_name: "test_realloc_to_vec_resize"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"
            unsafe_blocks: 0

      - id: "7.3"
        name: "string.h (C99 §7.21)"
        tasks:
          - id: "STDLIB-STRLEN"
            title: "Document strlen → .len()"
            status: "completed"
            version: "v0.13.0"
            priority: "medium"
            examples:
              - c: "size_t len = strlen(s);"
                rust: "let len = s.len();"
            validation_reference: "K&R §B3, ISO C99 §7.21.6.3"
            test_name: "test_strlen_to_len"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-STRCPY"
            title: "Document strcpy → String/clone"
            status: "completed"
            version: "v0.14.0"
            priority: "medium"
            examples:
              - c: "strcpy(dest, src);"
                rust: "dest = src.to_string();"
            validation_reference: "K&R §B3, ISO C99 §7.21.3.1"
            test_name: "test_strcpy_transformation"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

  - id: 8
    name: "Preprocessor (C99 §6.10)"
    description: "#define, #include, #ifdef, etc."
    tasks:
      - id: "PREP-INCLUDE"
        title: "Document #include → use statements"
        status: "completed"
        priority: "high"
        version: "v0.17.0"
        examples:
          - c: "#include <stdio.h>"
            rust: "// Built-in, no import needed"
          - c: "#include \"myheader.h\""
            rust: "mod mymodule;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.2"
        test_name: "test_include_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 10
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - system headers map to built-ins, local headers become modules"

      - id: "PREP-DEFINE-CONST"
        title: "Document #define constants → const"
        status: "completed"
        priority: "high"
        version: "v0.16.0"
        examples:
          - c: "#define MAX 100"
            rust: "const MAX: i32 = 100;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_const"
        sprint: 2
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0

      - id: "PREP-DEFINE-MACRO"
        title: "Document #define macros → functions or macros"
        status: "completed"
        priority: "medium"
        version: "v0.18.0"
        examples:
          - c: "#define SQR(x) ((x) * (x))"
            rust: "fn sqr(x: i32) -> i32 { x * x }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_macro_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - expression macros become functions, statement macros become macro_rules! or use std library"

      - id: "PREP-IFDEF"
        title: "Document #ifdef → cfg"
        status: "completed"
        priority: "low"
        version: "v0.23.0"
        examples:
          - c: "#ifdef DEBUG ... #endif"
            rust: "#[cfg(debug_assertions)] { ... }"
          - c: "#ifdef __linux__ ... #endif"
            rust: "#[cfg(target_os = \"linux\")] { ... }"
          - c: "#if defined(X) && !defined(Y) ... #endif"
            rust: "#[cfg(all(feature = \"x\", not(feature = \"y\")))] { ... }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.1"
        test_name: "test_ifdef_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 13
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - #ifdef/#ifndef become cfg attributes. Rust cfg is type-aware (evaluated during compilation) unlike C's text-based preprocessor. Supports debug_assertions, target_os, target_arch, features (Cargo.toml), test, and complex combinators (all, any, not)."

completed_features:
  - title: "Basic types (int, float, char)"
    version: "v0.1.0"
    tasks: ["TYPE-BASIC-INT", "TYPE-BASIC-FLOAT"]
    tests: 5
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Integer and float literals"
    version: "v0.1.0"
    tasks: ["LEX-CONST-INT", "LEX-CONST-FLOAT"]
    tests: 6
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Basic arithmetic and comparison operators"
    version: "v0.1.0"
    tasks: ["EXPR-ARITH-BINARY", "EXPR-CMP-RELATIONAL", "EXPR-CMP-EQUALITY"]
    tests: 8
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Function declarations and definitions"
    version: "v0.1.0"
    tasks: ["FUNC-DECL", "FUNC-DEF", "FUNC-VOID-PARAMS"]
    tests: 4
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Control flow (if, while, for)"
    version: "v0.2.0"
    tasks: ["STMT-IF", "STMT-WHILE", "STMT-FOR"]
    tests: 12
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Pointers and malloc/free → Box"
    version: "v0.3.0"
    tasks: ["TYPE-PTR-MALLOC", "STDLIB-MALLOC", "STDLIB-FREE"]
    tests: 9
    methodology: "EXTREME TDD + Ownership Inference"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

  - title: "sizeof operator"
    version: "v0.3.0"
    tasks: ["EXPR-UNARY-SIZEOF"]
    tests: 9
    methodology: "EXTREME TDD + Property Testing"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

high_priority_next_tasks:
  description: "Next 20 tasks to implement"
  tasks:
    - id: "TYPE-PTR-NULL"
      title: "NULL → Option<T>"
      priority: 1
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Eliminates null pointer dereferences"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STDLIB-CALLOC"
      title: "calloc → Vec::with_capacity"
      priority: 2
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Pattern-based allocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STMT-SWITCH"
      title: "switch → match"
      priority: 3
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 15

    - id: "TYPE-ARRAY-VLA"
      title: "Variable-length arrays → Vec"
      priority: 4
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Stack overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-ARITH-PTR"
      title: "Pointer arithmetic → slice indexing"
      priority: 5
      status: "🔶 BLOCKED - RED PHASE COMPLETE (Sprint 3)"
      phase: "RED"
      ownership_inference_impact: "CRITICAL"
      unsafe_reduction: "Eliminates pointer arithmetic"
      red_phase_date: "2025-10-15"
      tests_added: 9
      blocked_reason: "Needs ownership inference infrastructure"

    - id: "STDLIB-REALLOC"
      title: "realloc → Vec::resize"
      priority: 6
      status: "✅ COMPLETED (Sprint 2)"
      ownership_inference_impact: "MEDIUM"
      unsafe_reduction: "Pattern-based reallocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-POSTFIX-INCR"
      title: "Post-increment/decrement"
      priority: 7
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "EXPR-UNARY-INCR"
      title: "Pre-increment/decrement"
      priority: 8
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "EXPR-ASSIGN-COMPOUND"
      title: "Compound assignment (+=, *=, etc.)"
      priority: 9
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "PREP-DEFINE-CONST"
      title: "#define constants → const"
      priority: 10
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "PREP-INCLUDE"
      title: "#include → use statements"
      priority: 11
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "None (module system)"
      completed_date: "2025-10-15"
      tests_added: 10

    - id: "PREP-DEFINE-MACRO"
      title: "#define macros → functions or macros"
      priority: 12
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type safety from functions"
      completed_date: "2025-10-15"
      tests_added: 16

    - id: "STDLIB-STRLEN"
      title: "strlen → .len()"
      priority: 13
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "STDLIB-STRCPY"
      title: "strcpy → String/clone"
      priority: 14
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "TYPE-STRUCT-NESTED"
      title: "Nested structs"
      priority: 15
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "STDLIB-SCANF"
      title: "scanf → stdin reading"
      priority: 16
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type-safe parsing + buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 14

    - id: "FUNC-VARIADIC"
      title: "Variadic functions"
      priority: 17
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Type safety from macros or Vec (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "STMT-GOTO"
      title: "goto elimination"
      priority: 18
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Structured control flow (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "TYPE-QUAL-VOLATILE"
      title: "volatile → atomic"
      priority: 19
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Atomic types are SAFE (0 unsafe for concurrency), MMIO requires unsafe"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "DECY-045"
      title: "Comprehensive sizeof edge case testing"
      priority: 20
      status: "✅ COMPLETED (Sprint 4)"
      type: "quality"
      unsafe_reduction: "Prevents parser bugs (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 24

next_steps:
  - "Start with TYPE-PTR-NULL (NULL → Option) in Sprint 1"
  - "Follow EXTREME TDD religiously (RED-GREEN-REFACTOR)"
  - "Pull ANDON CORD immediately when bugs found during validation"
  - "Track unsafe block count per sprint (target: <5 per 1000 LOC)"
  - "Use STOP THE LINE protocol for all validation failures"
  - "Document all transformations with C99/K&R references"
  - "Prioritize ownership inference improvements in decy-ownership crate"

status:
  overall: "IN_PROGRESS"
  completion_percent: 37
  completed_tasks: 56
  in_progress_tasks: 0
  blocked_tasks: 1
  not_started_tasks: 93
  total_tasks: 150
  methodology: "EXTREME TDD (RED-GREEN-REFACTOR) + Ownership Inference"
  goal: "100% C99 language coverage with <5 unsafe blocks per 1000 LOC"
  last_completed:
    task_id: "TYPE-BASIC-LONGLONG"
    title: "long long type documentation"
    version: "v0.40.0"
    date: "2025-10-15"
    unsafe_blocks_added: 0
    tests_added: 16
    coverage: "100%"
  current_sprint: 5
  current_unsafe_count_per_1000_loc: 0
  target_unsafe_count_per_1000_loc: 5
