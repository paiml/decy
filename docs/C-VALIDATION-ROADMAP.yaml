---
roadmap:
  title: "C Language Validation Roadmap - EXTREME TDD"
  goal: "Document every C construct transformation to idiomatic Rust with minimal unsafe"
  methodology: "EXTREME TDD (Test-First, RED-GREEN-REFACTOR)"
  reference: "ISO C99 Standard (ISO/IEC 9899:1999) + K&R C (2nd Edition)"
  status: "IN_PROGRESS"
  completion: "20%"
  unsafe_blocks_per_1000_loc_target: "<5"

  statistics:
    total_tasks: 150
    completed: 111
    partial_support: 0
    in_progress: 0
    blocked: 1
    not_started: 38
    coverage_percent: 74

extreme_tdd_workflow:
  description: "Standard workflow for each task"
  steps:
    - id: 1
      name: "RED"
      description: "Write failing test first"
      example: |
        #[test]
        fn test_<feature>_transformation() {
            let c_code = "<C input>";
            let expected_rust = "<expected rust>";

            let result = transpile(c_code)?;
            assert_eq!(result, expected_rust);

            // Verify unsafe block count
            let unsafe_count = count_unsafe_blocks(&result);
            assert!(unsafe_count <= MAX_UNSAFE_PER_MODULE);
        }

    - id: 2
      name: "GREEN"
      description: "Implement transformation"
      substeps:
        - "Update parser for C construct (decy-parser)"
        - "Update HIR representation (decy-hir)"
        - "Update analyzer for safety checks (decy-analyzer)"
        - "Update ownership inference (decy-ownership)"
        - "Update codegen (decy-codegen)"
        - "Verify safety properties (decy-verify)"

    - id: 3
      name: "REFACTOR"
      description: "Clean up implementation and minimize unsafe"
      substeps:
        - "Extract common patterns"
        - "Add helper functions"
        - "Document edge cases"
        - "Reduce unsafe blocks through better ownership inference"
        - "Add SAFETY comments to remaining unsafe blocks"

    - id: 4
      name: "DOCUMENT"
      description: "Add to examples and documentation"
      substeps:
        - "Update examples/"
        - "Add to test fixtures"
        - "Update CHANGELOG.md"
        - "Document unsafe rationale if any remain"

stop_the_line_protocol:
  description: "ANDON CORD - Pull when validation reveals bugs"
  trigger_conditions:
    - "Transpiled code doesn't compile"
    - "Transpiled code has different behavior than C"
    - "Unsafe block count exceeds target"
    - "Parser fails on valid C99 construct"
    - "Ownership inference creates memory leak"
    - "Verification stage fails safety checks"

  procedure:
    - step: 1
      action: "STOP all feature development immediately"
      responsible: "Developer who discovered issue"

    - step: 2
      action: "Create P0 ticket in roadmap.yaml"
      template: |
        P0-<CONSTRUCT>-<NUMBER>:
          title: "[P0] Fix <construct> transpilation bug"
          type: bug
          priority: critical
          story_points: <estimated>
          status: in_progress
          phase: RED
          discovered_during_validation: true
          validation_reference: "<ISO C99 section or K&R page>"
          c_input: |
            <failing C code>
          expected_rust: |
            <correct Rust output>
          actual_rust: |
            <buggy Rust output or error>
          safety_impact: "<memory safety, undefined behavior, etc.>"

    - step: 3
      action: "Apply EXTREME TDD fix (RED-GREEN-REFACTOR)"
      requirements:
        - "Must add failing test first (RED)"
        - "Must fix with minimal implementation (GREEN)"
        - "Must meet quality gates (REFACTOR)"
        - "Must verify unsafe count didn't increase"

    - step: 4
      action: "Resume validation only after fix verified"
      verification_checklist:
        - "All tests pass (make test)"
        - "Quality gates pass (make quality-gates)"
        - "Coverage ≥80% (≥90% for decy-ownership)"
        - "Unsafe count ≤5 per 1000 LOC"
        - "Original validation case passes"

validation_references:
  primary:
    - name: "ISO C99 Standard"
      identifier: "ISO/IEC 9899:1999"
      sections: 300+
      url: "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"
      coverage: "Complete C language specification"

    - name: "K&R C (2nd Edition)"
      authors: "Brian Kernighan, Dennis Ritchie"
      isbn: "0131103628"
      chapters: 8
      appendix_sections: 6
      coverage: "Canonical C reference with examples"

  supplementary:
    - name: "GCC Documentation"
      url: "https://gcc.gnu.org/onlinedocs/gcc/"
      coverage: "Extensions and compiler-specific behavior"

    - name: "Clang Documentation"
      url: "https://clang.llvm.org/docs/"
      coverage: "AST structure and libclang API"

unsafe_minimization_strategy:
  description: "4-phase strategy to reduce unsafe blocks"
  target: "<5 unsafe blocks per 1000 LOC"

  phases:
    - id: 1
      name: "Pattern-Based"
      description: "Detect common patterns and generate safe Rust"
      target_reduction: "100% → 50%"
      patterns:
        - "malloc/free → Box::new()"
        - "calloc/free → Vec::with_capacity()"
        - "Array allocation → Vec"
        - "String allocation → String/CString"
      status: "IN_PROGRESS"

    - id: 2
      name: "Ownership Inference"
      description: "Infer ownership from pointer usage"
      target_reduction: "50% → 20%"
      techniques:
        - "Classify pointers: owning vs borrowing"
        - "Detect unique ownership → Box"
        - "Detect shared read-only → &T"
        - "Detect exclusive mutable → &mut T"
        - "Build pointer dataflow graph"
      status: "IN_PROGRESS"
      critical_crate: "decy-ownership"

    - id: 3
      name: "Lifetime Inference"
      description: "Infer lifetimes from C variable scopes"
      target_reduction: "20% → 10%"
      techniques:
        - "Map C scope to Rust lifetime"
        - "Generate lifetime annotations"
        - "Validate lifetime constraints"
      status: "NOT_STARTED"

    - id: 4
      name: "Safe Wrappers"
      description: "Wrap remaining unsafe in safe abstractions"
      target_reduction: "10% → <5%"
      techniques:
        - "Create safe wrapper functions"
        - "Add SAFETY comments for audit trail"
        - "Document invariants"
      status: "NOT_STARTED"

chapters:
  # Based on ISO C99 Standard structure

  - id: 1
    name: "Scope & Terms (C99 §1-4)"
    description: "Foundational definitions and conformance"
    tasks:
      - id: "SCOPE-001"
        title: "Document C99 conformance scope"
        status: "completed"
        version: "v0.1.0"
        notes: "DECY targets C99 as baseline, with selective GCC extensions"
        validation_reference: "ISO C99 §1-2"

  - id: 2
    name: "Lexical Elements (C99 §6.4)"
    description: "Tokens, keywords, identifiers, constants"
    sections:
      - id: "2.1"
        name: "Keywords (C99 §6.4.1)"
        tasks:
          - id: "LEX-KW-001"
            title: "Document C keywords to Rust keywords mapping"
            status: "completed"
            version: "v0.87.0"
            examples:
              - c: "int x; char c; float f; double d;"
                rust: "let x: i32; let c: u8; let f: f32; let d: f64;"
              - c: "void function() { }"
                rust: "fn function() { }"
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
              - c: "static int counter = 0;"
                rust: "static COUNTER: i32 = 0;"
              - c: "if (x > 0) { } else { }"
                rust: "if x > 0 { } else { }"
              - c: "while (x < 10) { }"
                rust: "while x < 10 { }"
              - c: "for (int i = 0; i < n; i++) { }"
                rust: "for i in 0..n { }"
              - c: "break; continue; return;"
                rust: "break; continue; return;"
              - c: "struct Point { int x; };"
                rust: "struct Point { x: i32 }"
              - c: "enum Color { RED, GREEN };"
                rust: "enum Color { Red, Green }"
              - c: "switch (x) { case 1: break; default: break; }"
                rust: "match x { 1 => { break; }, _ => { break; } }"
              - c: "sizeof(int)"
                rust: "std::mem::size_of::<i32>()"
              - c: "typedef int Integer;"
                rust: "type Integer = i32;"
            validation_reference: "K&R §2.1, ISO C99 §6.4.1"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - fundamental C to Rust keyword mappings. Key transformations: int→i32 (explicit width), switch→match (pattern matching), sizeof→function, typedef→type. Control flow keywords mostly same but no parentheses in Rust."

      - id: "2.2"
        name: "Identifiers (C99 §6.4.2)"
        tasks:
          - id: "LEX-ID-001"
            title: "Document identifier naming rules"
            status: "completed"
            version: "v0.88.0"
            examples:
              - c: "int myVariable; void processData() { }"
                rust: "let my_variable: i32; fn process_data() { }"
              - c: "typedef struct point Point; typedef int my_int_t;"
                rust: "struct Point { } type MyInt = i32;"
              - c: "#define MAX_SIZE 100; const int DEFAULT = 42;"
                rust: "const MAX_SIZE: usize = 100; const DEFAULT: i32 = 42;"
              - c: "static int counter = 0;"
                rust: "static COUNTER: i32 = 0;"
              - c: "enum Color { RED, GREEN, BLUE };"
                rust: "enum Color { Red, Green, Blue }"
              - c: "int httpStatus; typedef struct HTTPRequest HTTPRequest;"
                rust: "let http_status: i32; struct HttpRequest { }"
              - c: "int value1; struct Point2D { int x; };"
                rust: "let value1: i32; struct Point2d { x: i32 }"
              - c: "int type = 42; int match = 10;"
                rust: "let r#type = 42; let r#match = 10;"
              - c: "int nCount; char* pszName; bool bEnabled;"
                rust: "let count: i32; let name: &str; let enabled: bool;"
              - c: "struct Person { char firstName[50]; int userId; };"
                rust: "struct Person { first_name: [u8; 50], user_id: i32 }"
            validation_reference: "K&R §2.2, ISO C99 §6.4.2"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - naming conventions fundamental to C→Rust transformation. Rules: variables/functions→snake_case, types→PascalCase, constants/statics→SCREAMING_SNAKE_CASE, enum variants→PascalCase. Enforced by clippy (warnings). Hungarian notation removed. Keywords→r# raw identifiers."

      - id: "2.3"
        name: "Constants (C99 §6.4.4)"
        tasks:
          - id: "LEX-CONST-INT"
            title: "Document integer constants"
            status: "completed"
            version: "v0.67.0"
            examples:
              - c: "int x = 42;"
                rust: "let x: i32 = 42;"
                note: "Decimal: same syntax, int → i32"
              - c: "int octal = 052;"
                rust: "let octal: i32 = 0o52;"
                note: "Octal: leading 0 → 0o prefix (SAFER, no confusion with decimal)"
              - c: "int hex = 0x2A;"
                rust: "let hex: i32 = 0x2A;"
                note: "Hexadecimal: same 0x prefix"
              - c: "unsigned int u = 42U;"
                rust: "let u: u32 = 42;"
                note: "Unsigned: U suffix → u32 type (or 42u32)"
              - c: "long l = 42L;"
                rust: "let l: i64 = 42;"
                note: "Long: L suffix → i64 (or 42i64)"
              - c: "unsigned long ul = 42UL;"
                rust: "let ul: u64 = 42;"
                note: "Unsigned long: UL → u64 (or 42u64)"
              - c: "long long ll = 42LL;"
                rust: "let ll: i64 = 42;"
                note: "Long long: LL → i64 (or 42i64)"
              - c: "unsigned long long ull = 42ULL;"
                rust: "let ull: u64 = 42;"
                note: "Unsigned long long: ULL → u64 (or 42u64)"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.1"
            test_name: "test_integer_literal_transformation"
            test_file: "integer_literals_documentation_test.rs"
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Integer literals all bases and suffixes. CRITICAL SAFETY: (1) Octal literals: C leading 0 is ERROR-PRONE (042 = 34 decimal, NOT 42!), Rust 0o prefix explicit and safe, (2) Binary literals: Rust has 0b (NOT in C99), (3) Underscores: Rust 1_000_000 for readability (NOT in C), (4) Type suffixes: C limited (U/L/LL), Rust precise (i8/i32/u64/etc). Transformations: decimal same, octal 052→0o52, hex same, U→u32, L→i64, UL→u64, LL→i64, ULL→u64. Test file demonstrates all bases (decimal, octal, hex, binary), all C suffixes, Rust features (underscores, type suffixes), max values, negative numbers. All safe (0 unsafe)."

          - id: "LEX-CONST-FLOAT"
            title: "Document floating-point constants"
            status: "completed"
            version: "v0.68.0"
            test_file: "crates/decy/tests/floating_point_literals_documentation_test.rs"
            examples:
              - c: "double x = 3.14;"
                rust: "let x: f64 = 3.14;"
                note: "Simple decimal: double → f64 (default type)"
              - c: "float x = 3.14f;"
                rust: "let x: f32 = 3.14;"
                note: "Float suffix: f → f32 type annotation or 3.14f32"
              - c: "double x = 1.5e10;"
                rust: "let x: f64 = 1.5e10;"
                note: "Scientific notation: same syntax (e10 means ×10^10)"
              - c: "double x = 2.3e-5;"
                rust: "let x: f64 = 2.3e-5;"
                note: "Negative exponent: e-5 means ×10^-5, same syntax"
              - c: "double x = .5;"
                rust: "let x: f64 = 0.5;"
                note: "CRITICAL: C allows .5 (no leading zero), Rust REQUIRES 0.5"
              - c: "double x = 5.;"
                rust: "let x: f64 = 5.0;"
                note: "Trailing decimal: C allows 5., Rust prefers explicit 5.0"
              - c: "double inf = INFINITY;"
                rust: "let inf = f64::INFINITY;"
                note: "Special values: INFINITY macro → f64::INFINITY constant"
              - c: "double nan = NAN;"
                rust: "let nan = f64::NAN;"
                note: "NaN constant: NAN macro → f64::NAN"
              - c: "if (isnan(x)) { ... }"
                rust: "if x.is_nan() { ... }"
                note: "NaN check: isnan() function → is_nan() method"
              - c: "if (isinf(x)) { ... }"
                rust: "if x.is_infinite() { ... }"
                note: "Infinity check: isinf() → is_infinite() method"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.2"
            test_name: "test_floating_point_literals_transformation_summary"
            critical_safety_differences:
              - "Leading zero REQUIRED in Rust (.5 is compile error, must be 0.5)"
              - "Special values via constants (f64::INFINITY, f64::NAN), not macros"
              - "NaN checks via methods (is_nan()), not == comparison (always false)"
              - "Default f64 (64-bit) matches C double, explicit f32 for float"
              - "IEEE 754 compliance in both, but Rust methods more type-safe"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Floating-point literals all patterns. CRITICAL SAFETY: (1) Leading zero REQUIRED: C .5 valid, Rust COMPILE ERROR (must be 0.5), (2) Special values: C INFINITY/NAN macros → Rust f64::INFINITY/f64::NAN constants (no header), (3) NaN checks: C isnan() → Rust is_nan() method (== comparison ALWAYS false per IEEE 754), (4) Infinity checks: isinf() → is_infinite() method, (5) Type-safe: f32 vs f64 explicit. Transformations: decimal same, scientific same (1.5e10), .5→0.5 (add leading zero), 5.→5.0 (explicit), f suffix→f32 type, INFINITY→f64::INFINITY, NAN→f64::NAN, isnan()→is_nan(), isinf()→is_infinite(). Test file demonstrates simple decimals, scientific notation, special values, NaN/infinity checks, negative zero, IEEE 754 compliance. All safe (0 unsafe)."

          - id: "LEX-CONST-CHAR"
            title: "Document character constants"
            status: "completed"
            version: "v0.66.0"
            examples:
              - c: "char c = 'A';"
                rust: "let c: u8 = b'A';"
                note: "Simple ASCII: char → u8, use b'A' byte literal syntax"
              - c: "char newline = '\\n';"
                rust: "let newline: u8 = b'\\n';"
                note: "Escape sequences: same syntax (\\n, \\t, \\0, \\\\, \\')"
              - c: "char null = '\\0';"
                rust: "let null: u8 = b'\\0';"
                note: "Null character: C string terminator, same in Rust"
              - c: "if (c >= 'a' && c <= 'z') { ... }"
                rust: "if c >= b'a' && c <= b'z' { ... }"
                note: "Range checks: byte literals in comparisons (b'a', b'z')"
              - c: "int digit = c - '0';"
                rust: "let digit = (c - b'0') as i32;"
                note: "Character arithmetic: explicit cast required"
              - c: "switch (c) { case 'a': return 1; ... }"
                rust: "match c { b'a' => 1, ... }"
                note: "Pattern matching: byte literals in match arms"
              - c: "char vowels[] = {'a', 'e', 'i', 'o', 'u'};"
                rust: "let vowels: [u8; 5] = [b'a', b'e', b'i', b'o', b'u'];"
                note: "Character arrays: byte literal arrays [u8; N]"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.4"
            test_name: "test_char_literal_transformation"
            test_file: "character_literals_documentation_test.rs"
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Character literals with 100% coverage. CRITICAL TYPE DIFFERENCES: (1) C char is 8-bit integer (signed or unsigned, implementation-defined), Rust has TWO types: char (32-bit Unicode) and u8 (8-bit byte), (2) ASCII C code: char → u8 with b'A' byte literal syntax, (3) Unicode C code: wchar_t → char (full Unicode support), (4) C characters are integers (arithmetic allowed), Rust requires explicit casts for arithmetic, (5) Same escape sequences: \\n, \\t, \\0, \\\\, \\', plus Rust Unicode \\u{...}. Transformation: C char 'A' → Rust b'A' for ASCII (byte literal). Range checks: 'a'..'z' → b'a'..b'z'. Character arithmetic: c - '0' → (c - b'0') as i32 (explicit cast). Pattern matching: case 'a' → b'a' in match. Test file demonstrates: simple ASCII, escape sequences, null character, range checks (lowercase, uppercase, digits), arithmetic, switch/match, character arrays, digit conversion, uppercase checks. All transformations safe (0 unsafe blocks). Rust more type-safe with distinct char (Unicode) and u8 (byte) types."

          - id: "LEX-CONST-STR"
            title: "Document string literals"
            status: "completed"
            version: "v0.65.0"
            examples:
              - c: "char* msg = \"Hello\";"
                rust: "let msg: &str = \"Hello\";"
                note: "Simple string: char* → &str (string slice, UTF-8, not null-terminated)"
              - c: "char* escaped = \"Line1\\nLine2\\tTab\";"
                rust: "let escaped = \"Line1\\nLine2\\tTab\";"
                note: "Escape sequences: same syntax (\\n, \\t, \\\", \\\\, \\0)"
              - c: "char* empty = \"\";"
                rust: "let empty = \"\";"
                note: "Empty string: same syntax, length 0"
              - c: "char* concat = \"Hello\" \" \" \"World\";"
                rust: "let concat = concat!(\"Hello\", \" \", \"World\");"
                note: "Concatenation: C auto-concatenates adjacent literals, Rust uses concat!() macro"
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
                note: "Format strings: %d → {}, type-safe formatting"
              - c: "if (strcmp(s, \"test\") == 0) { ... }"
                rust: "if s == \"test\" { ... }"
                note: "String comparison: strcmp() → direct == (more intuitive, type-safe)"
              - c: "char* path = \"C:\\\\Users\\\\John\";"
                rust: "let path = \"C:\\\\Users\\\\John\";"
                note: "Backslashes: same escaping rules (\\\\)"
              - c: "char* quote = \"He said \\\"Hi\\\"\";"
                rust: "let quote = \"He said \\\"Hi\\\"\";"
                note: "Quotes: \\\" for embedded quotes"
            validation_reference: "K&R §2.3, ISO C99 §6.4.5"
            test_name: "test_string_literal_transformation"
            test_file: "string_literals_documentation_test.rs"
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: String literals with 100% coverage. CRITICAL SAFETY DIFFERENCES: (1) C strings null-terminated (implicit \\0), Rust length stored separately (no null needed), (2) C strlen() O(n) runtime scan, Rust len() O(1) constant time, (3) C modifying string literals is UNDEFINED BEHAVIOR (but compiles), Rust immutable by default (compile error), (4) C char* conflates pointer and array, Rust clear distinction (&str borrowed vs String owned), (5) C byte-oriented (no encoding), Rust always valid UTF-8 (compile-time check), (6) C strcmp() needed for comparison, Rust direct == works (type-safe). Same escape sequences. Adjacent literal concatenation: C automatic, Rust concat!() macro. Format strings: printf %s/%d → println! {}. Test file demonstrates: simple literals, escape sequences (\\n, \\t, \\\", \\\\, \\0), empty strings, concatenation, printf/println transformation, string comparison, struct initialization, multiline strings, embedded nulls. All transformations safe (0 unsafe blocks). Rust strings safer, more ergonomic, and UTF-8 guaranteed."

          - id: "LEX-CONST-HEXFLOAT"
            title: "Document hexadecimal floating-point literals"
            status: "completed"
            priority: "medium"
            version: "v0.41.0"
            examples:
              - c: "double x = 0x1.8p3;"
                rust: "let x: f64 = 12.0;  // 1.5 * 2^3"
                note: "Rust has no hex float syntax, compute or use from_bits()"
              - c: "double pi = 0x1.921fb54442d18p1;"
                rust: "let pi = f64::from_bits(0x400921fb54442d18);"
                note: "Use from_bits() for exact IEEE 754 representation"
              - c: "float f = 0x1.0p0f;"
                rust: "let f: f32 = 1.0;"
                note: "f suffix → f32 type"
            validation_reference: "ISO C99 §6.4.4.2 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_hexadecimal_float_literals"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R: Only decimal float literals. C99: Added hex float literals (0x1.8p3). Rust: NO hex float syntax (compute or from_bits()). Format: 0x<mantissa>p<exponent> = mantissa × 2^exponent. Purpose: exact binary representation without decimal rounding. Useful for constants, bit-exact values, IEEE 754 patterns. Common in scientific/low-level computing."

  - id: 3
    name: "Types (C99 §6.2.5, §6.7)"
    description: "Basic types, derived types, type qualifiers"
    sections:
      - id: "3.1"
        name: "Basic Types (C99 §6.2.5)"
        tasks:
          - id: "TYPE-BASIC-INT"
            title: "Document integer types"
            status: "completed"
            version: "v0.69.0"
            test_file: "crates/decy/tests/integer_types_documentation_test.rs"
            examples:
              - c: "char c;"
                rust: "let c: i8;"
                note: "char → i8 (signed by default), 8-bit integer"
              - c: "unsigned char uc;"
                rust: "let uc: u8;"
                note: "unsigned char → u8, common for bytes/ASCII (0-255)"
              - c: "signed char sc;"
                rust: "let sc: i8;"
                note: "signed char → i8 (explicit), disambiguates char signedness"
              - c: "short s;"
                rust: "let s: i16;"
                note: "short → i16, exactly 16 bits (C: at least 16)"
              - c: "unsigned short us;"
                rust: "let us: u16;"
                note: "unsigned short → u16, common for ports/IDs"
              - c: "int i;"
                rust: "let i: i32;"
                note: "int → i32 (most common), exactly 32 bits"
              - c: "unsigned int ui;"
                rust: "let ui: u32;"
                note: "unsigned int → u32, non-negative values"
              - c: "long l;"
                rust: "let l: i64;"
                note: "long → i64 (conservative), exactly 64 bits (C: at least 32)"
              - c: "unsigned long ul;"
                rust: "let ul: u64;"
                note: "unsigned long → u64, large unsigned values"
              - c: "long long ll;"
                rust: "let ll: i64;"
                note: "long long → i64, C99 type (at least 64 bits)"
              - c: "unsigned long long ull;"
                rust: "let ull: u64;"
                note: "unsigned long long → u64, maximum unsigned range"
              - c: "signed int si;"
                rust: "let si: i32;"
                note: "signed int → i32 (signed is default for int)"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_integer_types_transformation_summary"
            critical_safety_differences:
              - "EXACT sizes guaranteed in Rust (i8/i16/i32/i64), C has minimums"
              - "char signedness IMPLEMENTATION-DEFINED in C, explicit i8/u8 in Rust"
              - "NO implicit conversions in Rust (compile error), C auto-converts"
              - "Overflow panics in debug (C UNDEFINED BEHAVIOR for signed)"
              - "Size hierarchy preserved: i8 < i16 < i32 < i64"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Integer types all C variants. CRITICAL SAFETY: (1) Size guarantees: C types have minimums (int ≥16 bits, typically 32), Rust EXACT sizes (i32 always 32 bits), (2) char signedness: C IMPLEMENTATION-DEFINED (may be signed or unsigned), Rust explicit (i8 or u8), (3) NO implicit conversions: C allows implicit int→long, Rust COMPILE ERROR (requires explicit cast), (4) Overflow behavior: C signed overflow UNDEFINED BEHAVIOR, Rust panics in debug/wraps in release (well-defined), (5) Type promotion: C promotes to int automatically, Rust types must match exactly. Transformations: char→i8, unsigned char→u8, short→i16, int→i32, long→i64, long long→i64, unsigned variants→u prefix (u8/u16/u32/u64). Test file demonstrates all C integer types (char/short/int/long/long long), signed/unsigned variants, multiple declarations, initialization, size hierarchy. All safe (0 unsafe)."

          - id: "TYPE-BASIC-FLOAT"
            title: "Document floating-point types"
            status: "completed"
            version: "v0.70.0"
            test_file: "crates/decy/tests/floating_point_types_documentation_test.rs"
            examples:
              - c: "float f;"
                rust: "let f: f32;"
                note: "float → f32, exactly 32 bits (single precision, 6-7 digits)"
              - c: "double d;"
                rust: "let d: f64;"
                note: "double → f64, exactly 64 bits (double precision, 15-17 digits)"
              - c: "long double ld;"
                rust: "let ld: f64;"
                note: "long double → f64 (conservative, may lose precision on some platforms)"
              - c: "float pi = 3.14f;"
                rust: "let pi: f32 = 3.14;"
                note: "float with value: f suffix in C → type annotation in Rust"
              - c: "double e = 2.71828;"
                rust: "let e: f64 = 2.71828;"
                note: "double with value: no suffix (default), f64 natural fit"
              - c: "float f = 1.5f; double d = f;"
                rust: "let f: f32 = 1.5; let d: f64 = f as f64;"
                note: "Conversion: C implicit float→double, Rust explicit cast required"
              - c: "double inf = INFINITY;"
                rust: "let inf = f64::INFINITY;"
                note: "Special values: INFINITY macro → f64::INFINITY constant"
              - c: "double nan = NAN;"
                rust: "let nan = f64::NAN;"
                note: "NaN: NAN macro → f64::NAN constant"
              - c: "double speed = 3.0e8;"
                rust: "let speed: f64 = 3.0e8;"
                note: "Scientific notation: same syntax, double/f64 default"
              - c: "float small = 1.5e-10f;"
                rust: "let small: f32 = 1.5e-10;"
                note: "Scientific with float: f suffix → f32 type annotation"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_floating_point_types_transformation_summary"
            critical_safety_differences:
              - "EXACT sizes in Rust (f32/f64), C types typically same but not guaranteed"
              - "long double size VARIES by platform (80/128 bits), Rust f64 always 64 bits"
              - "NO implicit conversions: C allows float→double, Rust COMPILE ERROR (needs cast)"
              - "Special values via constants (f64::INFINITY/NAN), not macros (no header)"
              - "Default type f64 matches C double (literals inferred as f64)"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Floating-point types all C variants. CRITICAL SAFETY: (1) Exact sizes: C float typically 32 bits, double 64 bits (implementation-defined), Rust f32/f64 EXACT sizes guaranteed, (2) long double portability: C varies (80 bits x86, 128 bits ARM/POWER), Rust maps to f64 (portable but may lose precision), (3) NO implicit conversions: C allows implicit float→double widening, Rust COMPILE ERROR (requires explicit cast), (4) Special values: C INFINITY/NAN macros (need <math.h>), Rust f64::INFINITY/NAN built-in constants (no header), (5) Type hierarchy: C float ≤ double ≤ long double, Rust f32 < f64 (no extended precision in std). Transformations: float→f32, double→f64, long double→f64 (conservative), conversions require explicit cast. Test file demonstrates all C float types (float/double/long double), initialization, conversions, special values (infinity/NaN), scientific notation, zero values. All safe (0 unsafe)."

          - id: "TYPE-BASIC-VOID"
            title: "Document void type"
            status: "completed"
            version: "v0.71.0"
            test_file: "crates/decy/tests/void_type_documentation_test.rs"
            examples:
              - c: "void print(void) { }"
                rust: "fn print() { }"
                note: "void return → omit return type (implicit unit type ())"
              - c: "int get_value(void);"
                rust: "fn get_value() -> i32;"
                note: "void parameters → empty () (no parameters)"
              - c: "void* ptr;"
                rust: "let ptr: *mut u8;"
                note: "void* → *mut u8 (generic pointer becomes byte pointer)"
              - c: "void process(void* data);"
                rust: "fn process(data: *mut u8);"
                note: "void* parameter → *mut u8 (explicit type)"
              - c: "void* allocate(size_t size);"
                rust: "fn allocate(size: usize) -> *mut u8;"
                note: "void* return → *mut u8 (explicit return type)"
              - c: "int* p = (int*)void_ptr;"
                rust: "let p: *mut i32 = void_ptr as *mut i32;"
                note: "void* cast: C implicit → Rust explicit (as cast required)"
              - c: "void* buffer = malloc(100);"
                rust: "let buffer: *mut u8 = unsafe { allocate(100) };"
                note: "malloc returns void*, unsafe required in Rust"
              - c: "void copy(void* dest, const void* src);"
                rust: "fn copy(dest: *mut u8, src: *const u8);"
                note: "const void* → *const u8 (read-only pointer)"
              - c: "void* ptr = NULL; if (ptr == NULL) { }"
                rust: "let ptr: *mut u8 = std::ptr::null_mut(); if ptr.is_null() { }"
                note: "NULL → null_mut(), null check via is_null() method"
              - c: "void func(int x) { if (x < 0) return; }"
                rust: "fn func(x: i32) { if x < 0 { return; } }"
                note: "Early return from void function: same syntax"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_void_type_transformation_summary"
            critical_safety_differences:
              - "void return → omit type (implicit ()), void params → empty ()"
              - "void* generic pointer → *mut u8 (NO implicit conversions in Rust)"
              - "void* casts: C implicit → Rust EXPLICIT (as cast required, visible)"
              - "Pointer operations REQUIRE unsafe blocks (dereference, allocation)"
              - "NULL → null_mut()/null(), check via is_null() method (type-safe)"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: "Required for void* operations"
            note: "COMPREHENSIVE DOCUMENTATION: void type all C patterns. CRITICAL SAFETY: (1) void return/params: C void keyword → Rust omit type (implicit unit ()), cleaner syntax, (2) void* generic pointer: C implicitly converts to any pointer type (type-unsafe), Rust *mut u8 requires EXPLICIT casts (as *mut T), (3) Type safety: C void* bypasses type system (convenient but unsafe), Rust preserves types (explicit casts visible in code), (4) Unsafe operations: C dereference void* after cast, Rust REQUIRES unsafe blocks (explicit danger), (5) NULL handling: C NULL macro, Rust null_mut()/is_null() (type-safe methods). Transformations: void return→omit, void params→(), void*→*mut u8, const void*→*const u8, casts require explicit as, malloc/operations require unsafe. Test file demonstrates void return, void params, void* pointers, casts, malloc patterns, memcpy/qsort signatures, NULL handling, early returns, struct fields. Unsafe required for pointer operations."

          - id: "TYPE-BASIC-BOOL"
            title: "Document boolean type"
            status: "completed"
            priority: "high"
            version: "v0.31.0"
            examples:
              - c: "#include <stdbool.h>\nbool flag = true;"
                rust: "let flag = true;"
                note: "Built-in bool type, no header needed"
              - c: "int flag = 1; if (flag) {}"
                rust: "let flag = true; if flag {}"
                note: "Pre-C99 int as bool → explicit bool"
              - c: "int x = (int)flag;"
                rust: "let x = flag as i32;"
                note: "Explicit conversion required"
              - c: "bool b = (x != 0);"
                rust: "let b = x != 0;"
                note: "Explicit comparison for int to bool"
            validation_reference: "ISO C99 §7.16 (stdbool.h), K&R (pre-C99)"
            test_name: "test_bool_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 bool → Rust bool (built-in). Same size (1 byte), same semantics. No implicit int conversions (type-safe). No bitwise operators on bool. Pre-C99 int flags → explicit bool."

          - id: "TYPE-BASIC-LONGLONG"
            title: "Document long long type"
            status: "completed"
            priority: "high"
            version: "v0.40.0"
            examples:
              - c: "long long x = 42LL;"
                rust: "let x: i64 = 42;"
                note: "C99 long long → Rust i64 (exactly 64 bits)"
              - c: "unsigned long long y = 42ULL;"
                rust: "let y: u64 = 42;"
                note: "Unsigned variant"
              - c: "long long timestamp = 1609459200000000000LL;"
                rust: "let timestamp: i64 = 1609459200000000000;"
                note: "Common use: nanosecond timestamps"
              - c: "long long file_size = 5368709120LL;"
                rust: "let file_size: i64 = 5368709120;"
                note: "Common use: file sizes > 4GB"
            validation_reference: "ISO C99 §6.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_long_long_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R had no standard 64-bit type. C99 added long long (at least 64 bits). Rust i64/u64 exactly 64 bits. C signed overflow = undefined behavior, Rust panics in debug/wraps in release. Use checked/wrapping methods. Common uses: timestamps, file sizes, large counters. 64-bit arithmetic native on modern CPUs."

      - id: "3.2"
        name: "Derived Types - Pointers (C99 §6.7.5.1)"
        tasks:
          - id: "TYPE-PTR-BASIC"
            title: "Document basic pointer types"
            status: "completed"
            version: "v0.86.0"
            examples:
              - c: "int* p = &x;"
                rust: "let p: &i32 = &x;"
              - c: "int* p = &x; *p = 10;"
                rust: "let p: &mut i32 = &mut x; *p = 10;"
              - c: "float* pf; double* pd; char* pc;"
                rust: "let pf: &f32; let pd: &f64; let pc: &u8;"
              - c: "struct Point* p;"
                rust: "let p: &Point;"
              - c: "int* p = NULL;"
                rust: "let p: Option<Box<i32>> = None;"
              - c: "int* p = malloc(sizeof(int));"
                rust: "let p = Box::new(0);"
              - c: "void increment(int* p) { (*p)++; }"
                rust: "fn increment(p: &mut i32) { *p += 1; }"
              - c: "int** pp;"
                rust: "let pp: &&i32;"
              - c: "const int* p;"
                rust: "let p: &i32;"
              - c: "int* p = arr;"
                rust: "let p: &[i32] = &arr;"
              - c: "int* get_value() { static int x = 42; return &x; }"
                rust: "fn get_value() -> &'static i32 { static X: i32 = 42; &X }"
              - c: "void* p;"
                rust: "let p: *const std::ffi::c_void;"
              - c: "int (*func_ptr)(int, int);"
                rust: "let func_ptr: fn(i32, i32) -> i32;"
              - c: "struct Node { struct Node* next; };"
                rust: "struct Node { next: Option<Box<Node>> }"
            validation_reference: "K&R §5.1, ISO C99 §6.7.5.1"
            test_name: "test_pointer_type_basic"
            ownership_inference: "CRITICAL"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - CRITICAL for ownership inference. Three pointer types in Rust: &T (borrow), &mut T (mutable borrow), Box<T> (owned). NULL → Option. Lifetime tracking prevents dangling pointers."

          - id: "TYPE-PTR-MALLOC"
            title: "Document malloc/free pattern → Box"
            status: "completed"
            version: "v0.89.0"
            examples:
              - c: "int* p = malloc(sizeof(int)); *p = 42; free(p);"
                rust: "let mut p = Box::new(0i32); *p = 42;"
                note: "Basic malloc/free → Box::new, automatic deallocation"
                unsafe_count: 0
              - c: "if (p == NULL) { return -1; }"
                rust: "// Box::new panics on OOM (idiomatic Rust)"
                note: "NULL check removed, Rust panics on allocation failure"
              - c: "struct Point* p = malloc(sizeof(struct Point)); p->x = 10; free(p);"
                rust: "let mut p = Box::new(Point { x: 0, y: 0 }); p.x = 10;"
                note: "Struct allocation, arrow becomes dot (auto-deref)"
              - c: "int* create() { return malloc(sizeof(int)); }"
                rust: "fn create() -> Box<i32> { Box::new(0) }"
                note: "Return value → Box<T>, ownership transfer"
              - c: "struct Node { int* data; }; n.data = malloc(sizeof(int)); free(n.data);"
                rust: "struct Node { data: Box<i32> }; let n = Node { data: Box::new(0) };"
                note: "Struct field → Box field, automatic cleanup"
              - c: "int* q = p; free(q);"
                rust: "let q = p; // p moved, can't use p anymore"
                note: "Assignment → move semantics, prevents use-after-free"
              - c: "if (cond) { p = malloc(...); } if (p != NULL) { free(p); }"
                rust: "let p: Option<Box<i32>> = if cond { Some(Box::new(0)) } else { None };"
                note: "Conditional allocation → Option<Box<T>>, NULL safety"
              - c: "int* p = calloc(1, sizeof(int));"
                rust: "let p = Box::new(0i32);"
                note: "calloc → Box::new(0), explicit zero-init"
              - c: "int** pp = malloc(sizeof(int*)); *pp = malloc(sizeof(int)); free(*pp); free(pp);"
                rust: "let mut pp = Box::new(Box::new(0i32));"
                note: "Nested allocations → Box<Box<T>>, correct deallocation order"
              - c: "for (...) { int* p = malloc(...); free(p); }"
                rust: "for i in 0..n { let p = Box::new(0); }"
                note: "Loop-local allocation, automatic cleanup per iteration"
              - c: "FuncPtr* p = malloc(sizeof(FuncPtr)); *p = &my_func; free(p);"
                rust: "let mut p: Box<FuncPtr> = Box::new(my_function);"
                note: "Function pointer allocation, no & needed in Rust"
              - c: "struct LargeData { int values[1000]; }; struct LargeData* p = malloc(sizeof(struct LargeData));"
                rust: "let p = Box::new(LargeData { values: [0; 1000] });"
                note: "Large struct stays on heap, prevents stack overflow"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3"
            test_name: "test_malloc_to_box_transformation"
            test_file: "malloc_free_to_box_documentation_test.rs"
            completed_ticket: "DECY-089"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "CRITICAL TRANSFORMATION: malloc/free → Box is the foundation of unsafe code reduction. Eliminates manual memory management bugs (use-after-free, double-free, leaks). 100% safe transformation (0 unsafe blocks). Box::new() provides RAII (automatic deallocation), ownership tracking (borrow checker prevents errors), type safety (no void* casting), move semantics (prevents use-after-free). Key differences: (1) C allocates uninitialized, Rust initializes in Box::new, (2) C manual free(), Rust automatic Drop, (3) C NULL on failure, Rust panics on OOM, (4) C void* with casting, Rust type-safe, (5) C no ownership tracking, Rust move semantics. Patterns: Basic malloc/free → Box::new, NULL check removed (idiom), struct allocation → Box::new(struct), return value → Box<T> transfer, struct field → Box field, assignment → move, conditional → Option<Box<T>>, calloc → Box::new(0), nested malloc → Box<Box<T>>, loop allocation → per-iteration Box. Test file demonstrates all patterns with 17 comprehensive tests."

          - id: "TYPE-PTR-ARRAY"
            title: "Document array allocation → Vec"
            status: "completed"
            version: "v0.90.0"
            examples:
              - c: "int* arr = malloc(n * sizeof(int)); for (...) arr[i] = i; free(arr);"
                rust: "let mut arr = vec![0i32; n]; for i in 0..n { arr[i] = i; }"
                note: "Basic array allocation → vec![], automatic deallocation"
                unsafe_count: 0
              - c: "int* arr = calloc(n, sizeof(int));"
                rust: "let arr = vec![0i32; n];"
                note: "calloc → vec![0; n], zero-initialized"
              - c: "if (arr == NULL) { return -1; }"
                rust: "// vec![] panics on OOM (idiomatic)"
                note: "NULL check removed, Rust panics on allocation failure"
              - c: "struct Array { int* data; size_t len; };"
                rust: "struct Array { data: Vec<i32> }"
                note: "Struct field → Vec field, length built-in (.len())"
              - c: "int* create() { return malloc(n * sizeof(int)); }"
                rust: "fn create() -> Vec<i32> { vec![0; n] }"
                note: "Return value → Vec<T>, ownership transfer"
              - c: "arr = realloc(arr, new_size * sizeof(int));"
                rust: "arr.reserve(additional);"
                note: "realloc → Vec::reserve, automatic resizing"
              - c: "int** matrix = malloc(rows * sizeof(int*)); for (...) matrix[i] = malloc(cols * sizeof(int));"
                rust: "let matrix = vec![vec![0i32; cols]; rows];"
                note: "2D array → Vec<Vec<T>>, automatic deallocation of all rows"
              - c: "int* arr2 = arr1; free(arr1);"
                rust: "let arr2 = arr1; // arr1 moved, or: arr1.clone() for copy"
                note: "Assignment → move semantics or clone()"
              - c: "void process(int* arr, size_t len) { }"
                rust: "fn process(arr: &[i32]) { }"
                note: "Parameter → slice reference, length built-in"
              - c: "for (...) { if (len >= capacity) { arr = realloc(...); } arr[len++] = val; }"
                rust: "for i in 0..n { arr.push(i); }"
                note: "Dynamic growth → Vec::push, automatic resizing"
              - c: "for (...) arr[i] = 42;"
                rust: "let arr = vec![42i32; n];"
                note: "Initialization loop → vec![val; n], single line"
              - c: "int** ptrs = malloc(...); for (...) ptrs[i] = malloc(...);"
                rust: "let mut ptrs: Vec<Box<i32>> = Vec::with_capacity(n);"
                note: "Array of pointers → Vec<Box<T>>"
              - c: "char* buffer = malloc(BUFFER_SIZE);"
                rust: "let mut buffer = vec![0u8; BUFFER_SIZE];"
                note: "Buffer allocation → vec![0u8; size]"
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_array_malloc_to_vec"
            test_file: "array_malloc_to_vec_documentation_test.rs"
            completed_ticket: "DECY-090"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "CRITICAL TRANSFORMATION: Array malloc → Vec is essential for buffer overflow prevention. Eliminates buffer overflow vulnerabilities (automatic bounds checking), use-after-free, memory leaks. 100% safe transformation (0 unsafe blocks). Vec<T> provides RAII (automatic deallocation), automatic bounds checking (panics on overflow), built-in length tracking (no separate len variable), growable arrays (push/reserve), ownership tracking (borrow checker). Key differences: (1) C no bounds checking (UNDEFINED BEHAVIOR on overflow), Rust panics safely, (2) C manual length tracking, Rust built-in .len(), (3) C uninitialized memory, Rust initialized in vec![], (4) C realloc (error-prone), Rust automatic growth, (5) C manual free(), Rust automatic Drop. Patterns: Basic malloc → vec![], calloc → vec![0; n], NULL check removed, struct field → Vec field (no len), return value → Vec<T>, realloc → Vec::reserve, 2D array → Vec<Vec<T>>, assignment → move/clone, parameter → &[T] slice, dynamic growth → push(), explicit init → vec![val; n], pointer array → Vec<Box<T>>, buffer → vec![0u8; size]. Test file demonstrates all patterns with 17 comprehensive tests."

          - id: "TYPE-PTR-NULL"
            title: "Document NULL → Option"
            status: "completed"
            version: "v0.91.0"
            examples:
              - c: "int* p = NULL;"
                rust: "let p: Option<Box<i32>> = None;"
                note: "NULL initialization → None, explicit optionality"
                unsafe_count: 0
              - c: "if (p != NULL) { *p = 42; }"
                rust: "if let Some(ref mut boxed) = p { **boxed = 42; }"
                note: "NULL check → if let Some, pattern matching"
              - c: "if (p == NULL) { return -1; }"
                rust: "if p.is_none() { return -1; }"
                note: "NULL equality → is_none(), explicit check"
              - c: "if (p) { *p = 42; }"
                rust: "if let Some(ref mut boxed) = p { **boxed = 42; }"
                note: "Implicit NULL check → explicit pattern matching"
              - c: "if (!p) { return -1; }"
                rust: "if p.is_none() { return -1; }"
                note: "Negated check → is_none(), clearer intent"
              - c: "int v = (p != NULL) ? *p : 0;"
                rust: "let v = p.map(|b| *b).unwrap_or(0);"
                note: "Ternary → unwrap_or, functional style"
              - c: "p = NULL;"
                rust: "p = None;"
                note: "NULL assignment → None, explicit invalidation"
              - c: "int* find() { return NULL; }"
                rust: "fn find() -> Option<Box<i32>> { None }"
                note: "Return NULL → return None, explicit in type"
              - c: "void f(int* p) { if (p != NULL) { } }"
                rust: "fn f(p: Option<&mut i32>) { if let Some(val) = p { } }"
                note: "Optional parameter → Option<&T>, explicit in signature"
              - c: "struct Node { struct Node* next; }; n.next = NULL;"
                rust: "struct Node { next: Option<Box<Node>> }; n.next = None;"
                note: "Struct field → Option<Box<T>>, self-referential safety"
              - c: "while (p != NULL) { p = p->next; }"
                rust: "while let Some(ref node) = p { p = node.next.clone(); }"
                note: "Loop condition → while let Some, safe traversal"
              - c: "if (p == NULL) { x = 0; } else { x = *p; }"
                rust: "let x = match p { Some(b) => *b, None => 0 };"
                note: "if-else → match, exhaustive pattern matching"
              - c: "int* result = p1; if (!result) result = p2;"
                rust: "let result = p1.or(p2);"
                note: "NULL coalescing → .or(), chained alternatives"
              - c: "if (p == NULL) { return NULL; } *p = 42;"
                rust: "let mut p = get_value()?; *p = 42;"
                note: "Early return → ? operator, error propagation"
            validation_reference: "K&R §5.4, ISO C99 §7.17"
            test_name: "test_null_to_option"
            test_file: "null_to_option_documentation_test.rs"
            completed_ticket: "DECY-091"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "CRITICAL TRANSFORMATION: NULL → Option eliminates the 'billion-dollar mistake' (Tony Hoare). Prevents null pointer dereference vulnerabilities. 100% safe transformation (0 unsafe blocks). Option<T> provides type system enforcement (compiler prevents forgetting NULL checks), pattern matching (explicit, exhaustive handling), safe methods (unwrap_or, is_none, is_some, ? operator). Key differences: (1) C all pointers implicitly nullable (hidden danger), Rust explicit Option type (type says 'might be absent'), (2) C manual NULL checks (easy to forget), Rust compiler-enforced (compile error if not checked), (3) C comparison operators (==, !=, implicit if), Rust pattern matching (if let Some, match, is_some/is_none), (4) C ternary for defaults, Rust built-in methods (unwrap_or, unwrap_or_default), (5) C NULL dereference is UNDEFINED BEHAVIOR (segfault), Rust compile error (cannot dereference Option). Patterns: NULL init → None, NULL check → if let Some/is_none(), ternary → unwrap_or, assignment → None, return → Option<T>, parameter → Option<&T>, struct field → Option<Box<T>>, while loop → while let Some, if-else → match, coalescing → .or(), early return → ? operator. Test file demonstrates all patterns with 17 comprehensive tests covering the complete NULL safety transformation."

          - id: "TYPE-FUNC-PTR"
            title: "Document function pointers"
            status: "completed"
            priority: "high"
            version: "v0.32.0"
            examples:
              - c: "int (*fp)(int, int);"
                rust: "let fp: fn(i32, i32) -> i32;"
                note: "Function pointer type (NOT nullable)"
              - c: "int (*fp)(int) = NULL;"
                rust: "let fp: Option<fn(i32) -> i32> = None;"
                note: "Nullable function pointer → Option<fn>"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
                note: "Function pointer typedef"
              - c: "struct Handler { int (*callback)(int); };"
                rust: "struct Handler { callback: fn(i32) -> i32 }"
                note: "Function pointer in struct"
            validation_reference: "K&R §5.11, §5.12, ISO C99 §6.7.5.3"
            test_name: "test_function_pointers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Function pointers → fn types (SAFE). NOT nullable (use Option<fn>). Type-safe (no unsafe casts). Separate from closures (Fn/FnMut/FnOnce). Common patterns: callbacks, strategy pattern, virtual dispatch, higher-order functions."

      - id: "3.3"
        name: "Derived Types - Arrays (C99 §6.7.5.2)"
        tasks:
          - id: "TYPE-ARRAY-FIXED"
            title: "Document fixed-size arrays"
            status: "completed"
            priority: "high"
            version: "v0.59.0"
            examples:
              - c: "int arr[10] = {0};"
                rust: "let arr: [i32; 10] = [0; 10];"
                note: "Zero init: C {0} → Rust [0; 10] (explicit repeat syntax)"
              - c: "int arr[5] = {1, 2, 3, 4, 5};"
                rust: "let arr: [i32; 5] = [1, 2, 3, 4, 5];"
                note: "Explicit values: same literal syntax in both"
              - c: "int val = arr[5];"
                rust: "let val = arr[5];  // Bounds checked at runtime"
                note: "Array access: C no bounds check (UNSAFE), Rust panics on out-of-bounds (SAFE)"
              - c: "arr[3] = 42;"
                rust: "arr[3] = 42;  // Requires mut"
                note: "Array modification: Rust requires mut keyword for writes"
              - c: "void process(int arr[], int len) { ... } process(data, 10);"
                rust: "fn process(arr: &[i32]) { ... } process(&data);"
                note: "Function param: C loses size (unsafe), Rust slice preserves size (safe)"
              - c: "int matrix[3][4] = {0};"
                rust: "let matrix: [[i32; 4]; 3] = [[0; 4]; 3];"
                note: "Multidimensional: type syntax [[inner; cols]; rows]"
              - c: "for (int i = 0; i < 10; i++) { arr[i] = i; }"
                rust: "for i in 0..10 { arr[i] = i; }"
                note: "Iteration: manual indexing works, but .iter_mut() more idiomatic"
              - c: "int sum = 0; for (int i = 0; i < 5; i++) { sum += arr[i]; }"
                rust: "let sum: i32 = arr.iter().sum();"
                note: "Sum pattern: Rust iterator .sum() more idiomatic than manual loop"
              - c: "const int lookup[5] = {10, 20, 30, 40, 50};"
                rust: "const LOOKUP: [i32; 5] = [10, 20, 30, 40, 50];"
                note: "Const array: compile-time constant, Rust uses SCREAMING_CASE"
              - c: "float values[5] = {1.0, 2.0, 3.0, 4.0, 5.0};"
                rust: "let values: [f32; 5] = [1.0, 2.0, 3.0, 4.0, 5.0];"
                note: "Different types: works with any Copy type (C float → Rust f32)"
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_fixed_array_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Fixed-size arrays: Stack-allocated, compile-time size. Critical safety differences: C arrays uninitialized by default (UNDEFINED VALUES), Rust requires initialization (compile error otherwise). C has NO bounds checking (buffer overflow possible), Rust checks bounds at runtime (panics on out-of-bounds - safe crash). C arrays decay to pointers implicitly (loses size information), Rust requires explicit slice conversion (preserves size). Function parameters: C int arr[] loses size (caller must pass length separately), Rust &[T] slice preserves size. Multidimensional: C [rows][cols], Rust [[T; cols]; rows]. Iteration: manual indexing works in both, Rust .iter() and .iter_mut() more idiomatic and safer. Copy: Rust arrays impl Copy if T: Copy (simple assignment copies). Const arrays: compile-time constants for lookup tables. All transformations enforce memory safety (0 unsafe blocks)."

          - id: "TYPE-ARRAY-INIT"
            title: "Document array initialization patterns"
            status: "completed"
            priority: "high"
            version: "v0.46.0"
            examples:
              - c: "int arr[10] = {0};"
                rust: "let arr: [i32; 10] = [0; 10];"
                note: "Zero initialization (all elements)"
              - c: "int arr[10] = {1, 2, 3};"
                rust: "let arr = [1, 2, 3, 0, 0, 0, 0, 0, 0, 0];"
                note: "Partial init: C zeros rest, Rust needs explicit"
              - c: "int arr[] = {1, 2, 3};"
                rust: "let arr = [1, 2, 3];"
                note: "Implicit size from initializer"
              - c: "char str[] = \"hello\";"
                rust: "let str = \"hello\";"
                note: "String literal (different: C has null terminator)"
              - c: "int matrix[2][2] = {{1,2},{3,4}};"
                rust: "let matrix: [[i32; 2]; 2] = [[1,2],[3,4]];"
                note: "Multidimensional array initialization"
              - c: "const int lookup[3] = {10, 20, 30};"
                rust: "const LOOKUP: [i32; 3] = [10, 20, 30];"
                note: "Const array initialization"
            validation_reference: "K&R §4.9, ISO C99 §6.7.8"
            test_name: "test_array_initialization"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Array initialization patterns: zero init ({0}), partial init (rest zeroed in C), full init, implicit size, string literals (include null in C), multidimensional, const arrays, struct arrays. C partial initialization zeros remaining elements implicitly. Rust requires explicit initialization. C allows array-to-pointer decay (implicit, unsafe). Rust requires explicit slices (safe). All transformations SAFE (0 unsafe blocks)."

          - id: "TYPE-ARRAY-VLA"
            title: "Document variable-length arrays → Vec"
            status: "completed"
            version: "v0.80.0"
            priority: "high"
            examples:
              - c: "int n = 10; int arr[n];"
                rust: "let n = 10; let arr = vec![0i32; n];"
                note: "Basic VLA → Vec (stack → heap)"
              - c: "double values[n];"
                rust: "let values = vec![0.0f64; n];"
                note: "Runtime size determination"
              - c: "int arr[n * 2 + 1];"
                rust: "let arr = vec![0; n * 2 + 1];"
                note: "Expression in size"
              - c: "char buffer[len];"
                rust: "let buffer = vec![0u8; len];"
                note: "Character buffer"
              - c: "int matrix[rows][cols];"
                rust: "let matrix: Vec<Vec<i32>> = vec![vec![0; cols]; rows];"
                note: "Multidimensional VLA → nested Vec"
              - c: "int arr[n]; for (int i = 0; i < n; i++) arr[i] = 0;"
                rust: "let arr = vec![0; n];"
                note: "Manual initialization eliminated"
              - c: "struct Point points[count];"
                rust: "let points = vec![Point::default(); count];"
                note: "Struct VLA requires Default trait"
              - c: "{ int arr[n]; } // arr freed"
                rust: "{ let arr = vec![0; n]; } // arr dropped"
                note: "Scope-based lifetime (same semantics)"
              - c: "const int SIZE = 100; int arr[SIZE];"
                rust: "const SIZE: usize = 100; let arr = [0i32; SIZE];"
                note: "Const size → fixed array (more efficient)"
              - c: "for (int i = 0; i < 10; i++) { int arr[n]; }"
                rust: "for i in 0..10 { let arr = vec![0; n]; }"
                note: "VLA in loop (repeated allocation)"
              - c: "float data[compute_size()];"
                rust: "let data = vec![0.0f32; compute_size()];"
                note: "Size from function call"
              - c: "Integer numbers[n];"
                rust: "let numbers: Vec<Integer> = vec![0; n];"
                note: "VLA with typedef/type alias"
              - c: "unsigned int flags[n];"
                rust: "let flags = vec![0u32; n];"
                note: "Unsigned VLA"
              - c: "int n = 1000000; int arr[n];"
                rust: "let n = 1000000; let arr = vec![0; n];"
                note: "SAFE: No stack overflow (heap allocated)"
              - c: "void process(int n, int arr[n]) { }"
                rust: "fn process(arr: &[i32]) { }"
                note: "VLA parameter → slice (size implicit)"
            validation_reference: "ISO C99 §6.7.5.2 (VLA)"
            test_name: "test_vla_documentation"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Variable-length arrays (VLA, C99 §6.7.5.2): C99 feature for runtime-sized arrays on stack. Size determined at runtime (not compile-time). Cannot be initialized in C (must use memset). Fixed size after creation. Stack allocation (fast but risky - potential stack overflow). Made optional in C11. Rust uses Vec<T> (heap allocated, safer). Vec advantages: can initialize (vec![0; n]), resizable, no stack overflow risk, bounds checking in debug. Critical safety: C VLA with large n can crash (stack overflow), Rust Vec fails gracefully. Multidimensional VLA → nested Vec or flattened. VLA in function parameter → slice (&[T]). All transformations SAFE (0 unsafe blocks). Heap allocation slower than stack but eliminates stack overflow risk."

      - id: "3.4"
        name: "Derived Types - Structs (C99 §6.7.2.1)"
        tasks:
          - id: "TYPE-STRUCT-BASIC"
            title: "Document struct definition"
            status: "completed"
            version: "v0.84.0"
            examples:
              - c: "struct Point { int x; int y; };"
                rust: "struct Point { x: i32, y: i32 }"
              - c: "typedef struct { int x; int y; } Point;"
                rust: "struct Point { x: i32, y: i32 }"
              - c: "struct Point p = { 10, 20 };"
                rust: "let p = Point { x: 10, y: 20 };"
              - c: "p.x = 10;"
                rust: "p.x = 10;"
              - c: "ptr->x = 10;"
                rust: "ptr.x = 10;"
              - c: "struct Node { int data; struct Node* next; };"
                rust: "struct Node { data: i32, next: Option<Box<Node>> }"
              - c: "struct Matrix { int data[10][10]; };"
                rust: "struct Matrix { data: [[i32; 10]; 10] }"
              - c: "void process(struct Point p) { }"
                rust: "fn process(p: Point) { }"
              - c: "void process(struct Point* p) { p->x; }"
                rust: "fn process(p: &Point) { p.x; }"
              - c: "struct Point p = { .x = 10, .y = 20 };"
                rust: "let p = Point { x: 10, y: 20 };"
              - c: "struct Handler { void (*callback)(int); };"
                rust: "struct Handler { callback: fn(i32) }"
              - c: "struct Rectangle { struct Point top_left; };"
                rust: "struct Rectangle { top_left: Point }"
            validation_reference: "K&R §6.1, ISO C99 §6.7.2.1"
            test_name: "test_struct_definition"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - structs transform with key differences: no 'struct' keyword in usage, ptr-> becomes ., typedef eliminated, all fields must be initialized"

          - id: "TYPE-STRUCT-NESTED"
            title: "Document nested structs"
            status: "completed"
            version: "v0.15.0"
            priority: "medium"
            examples:
              - c: "struct Outer { struct Inner { int x; } inner; };"
                rust: "struct Inner { x: i32 } struct Outer { inner: Inner }"
            validation_reference: "K&R §6.2, ISO C99 §6.7.2.1"
            test_name: "test_nested_struct"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "TYPE-FLEXIBLE-ARRAY"
            title: "Document flexible array members"
            status: "completed"
            priority: "high"
            version: "v0.35.0"
            examples:
              - c: "struct Buffer { size_t len; char data[]; };"
                rust: "struct Buffer { len: usize, data: Vec<u8> }"
                note: "Flexible array member → Vec"
              - c: "malloc(sizeof(struct Buffer) + n);"
                rust: "Buffer { len: n, data: vec![0; n] }"
                note: "Allocation → Vec with capacity"
              - c: "struct Packet { int id; uint8_t payload[]; };"
                rust: "struct Packet { id: i32, payload: Vec<u8> }"
                note: "Variable-length payload"
            validation_reference: "ISO C99 §6.7.2.1 paragraph 16 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_flexible_array_members"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 flexible array members → Rust Vec<T>. Must be last member in C99, no such restriction in Rust. Automatic memory management. Bounds checking. Alternative patterns: &[T] for borrowed data, Box<[T]> for fixed-size heap slice."

          - id: "TYPE-UNION"
            title: "Document union → enum"
            status: "completed"
            priority: "high"
            version: "v0.27.0"
            examples:
              - c: "union Value { int i; float f; };"
                rust: "enum Value { Int(i32), Float(f32) }"
                note: "Type-safe enum instead of unsafe union"
              - c: "struct Tagged { int type; union { int i; float f; } data; };"
                rust: "enum Tagged { Int(i32), Float(f32) }"
                note: "Discriminated union → enum"
              - c: "union FFI { int i; };"
                rust: "#[repr(C)] union FFI { i: i32 }"
                note: "FFI union requires unsafe to read"
            validation_reference: "K&R §6.8, ISO C99 §6.7.2.1"
            test_name: "test_union_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Unions transform to enums (SAFE) for type safety. Discriminated unions become enums with built-in tag. FFI unions use #[repr(C)] union (unsafe to read). Option/Result replace common tagged union patterns."

          - id: "TYPE-ENUM"
            title: "Document enum types"
            status: "completed"
            priority: "high"
            version: "v0.30.0"
            examples:
              - c: "enum Color { RED, GREEN, BLUE };"
                rust: "#[repr(i32)] enum Color { Red, Green, Blue }"
                note: "Type-safe enum with C representation"
              - c: "enum Status { OK = 0, ERROR = 1 };"
                rust: "#[repr(i32)] enum Status { Ok = 0, Error = 1 }"
                note: "Explicit values preserved"
              - c: "int val = status;"
                rust: "let val = status as i32;"
                note: "Explicit conversion required"
              - c: "enum { MAX = 100 };"
                rust: "const MAX: i32 = 100;"
                note: "Anonymous enum → const declarations"
            validation_reference: "K&R §2.3, ISO C99 §6.7.2.2"
            test_name: "test_enum_types"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 18
            coverage: "100%"
            unsafe_blocks: 0
            note: "C enums → Rust enums with #[repr(i32)] for C ABI. Type-safe (cannot mix with int). Exhaustiveness checking in match. Can carry data (more powerful than C). Anonymous enums → const declarations."

      - id: "3.5"
        name: "Type Qualifiers (C99 §6.7.3)"
        tasks:
          - id: "TYPE-QUAL-CONST"
            title: "Document const qualifier"
            status: "completed"
            version: "v0.74.0"
            examples:
              - c: "const int x = 5;"
                rust: "let x: i32 = 5;"
                note: "Immutable by default in Rust"
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
                note: "Compile-time constant"
              - c: "const int* p;"
                rust: "let p: &i32;"
                note: "Pointer to const → immutable reference"
              - c: "int* const p;"
                rust: "let p: &mut i32;"
                note: "Const pointer → cannot rebind"
              - c: "const int* const p;"
                rust: "let p: &i32;"
                note: "Both const → fully immutable"
              - c: "void foo(const int x) { }"
                rust: "fn foo(x: i32) { }"
                note: "Parameter immutable by default"
              - c: "const int* foo() { return &x; }"
                rust: "fn foo() -> &i32 { &x }"
                note: "Return immutable reference"
              - c: "const int arr[3] = {1, 2, 3};"
                rust: "const ARR: [i32; 3] = [1, 2, 3];"
                note: "Const array"
              - c: "struct S { const int x; };"
                rust: "struct S { x: i32 }"
                note: "Fields immutable unless struct is mut"
              - c: "const char* str = \"hello\";"
                rust: "let s: &str = \"hello\";"
                note: "String literal → &str"
              - c: "const volatile int reg;"
                rust: "// AtomicI32 or unsafe MMIO"
                note: "const volatile → atomic or unsafe"
              - c: "const int x = 5; int* p = (int*)&x; *p = 10;"
                rust: "COMPILE ERROR"
                note: "Cannot cast away immutability (UB in C)"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_const_qualifier"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "SAFETY: Rust prevents casting away const (compile-time error), C allows it (undefined behavior). Immutability by default."

          - id: "TYPE-QUAL-VOLATILE"
            title: "Document volatile → unsafe or atomic"
            status: "completed"
            priority: "low"
            version: "v0.20.0"
            examples:
              - c: "volatile int flag;"
                rust: "AtomicI32 (safe) or ptr::read_volatile() (unsafe for MMIO)"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_volatile_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation task - Atomic types are SAFE (0 unsafe), MMIO operations require unsafe. C volatile does NOT provide atomicity."

          - id: "TYPE-QUAL-RESTRICT"
            title: "Document restrict keyword"
            status: "completed"
            priority: "high"
            version: "v0.37.0"
            examples:
              - c: "void copy(int* restrict dest, const int* restrict src, size_t n);"
                rust: "fn copy(dest: &mut [i32], src: &[i32])"
                note: "C restrict promise → Rust borrow checker enforcement"
              - c: "int* restrict ptr = malloc(n * sizeof(int));"
                rust: "let ptr = vec![0; n];"
                note: "Exclusive ownership guaranteed"
              - c: "void add(int* restrict a, int* restrict b, int* restrict c) { *a = *b + *c; }"
                rust: "fn add(a: &mut i32, b: &i32, c: &i32) { *a = *b + *c; }"
                note: "Borrow checker enforces non-aliasing"
              - c: "const int* restrict arr;"
                rust: "&[i32]"
                note: "Immutable non-aliasing reference"
            validation_reference: "ISO C99 §6.7.3.1 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_restrict_keyword"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 restrict keyword → Rust borrow checker. C restrict is PROMISE (not verified), Rust borrow checker ENFORCES non-aliasing. Violations: C = undefined behavior, Rust = compile error. Rust provides STRONGER guarantees. Same optimization benefits. &mut is conceptually 'restrict by default'."

      - id: "3.6"
        name: "Type Definitions (C99 §6.7.7)"
        tasks:
          - id: "TYPE-TYPEDEF"
            title: "Document typedef → type alias"
            status: "completed"
            priority: "high"
            version: "v0.26.0"
            examples:
              - c: "typedef int Integer;"
                rust: "type Integer = i32;"
              - c: "typedef int* IntPtr;"
                rust: "type IntPtr<'a> = &'a i32;"
              - c: "typedef struct Point { int x; int y; } Point;"
                rust: "struct Point { x: i32, y: i32 }"
                note: "Rust struct names are already types"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
            validation_reference: "K&R §6.7, ISO C99 §6.7.7"
            test_name: "test_typedef_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Type aliases for primitives, pointers (with lifetimes), structs, arrays, function pointers. Rust newtype pattern provides stronger typing than C typedef. All transformations are safe (0 unsafe blocks)."

      - id: "3.7"
        name: "Initialization (C99 §6.7.8)"
        tasks:
          - id: "TYPE-INIT-DESIGNATED"
            title: "Document designated initializers"
            status: "completed"
            priority: "high"
            version: "v0.33.0"
            examples:
              - c: "struct Point p = { .x = 10, .y = 20 };"
                rust: "let p = Point { x: 10, y: 20 };"
                note: "Designated initializer → struct literal"
              - c: "struct Point p = { .x = 10 };"
                rust: "let p = Point { x: 10, ..Default::default() };"
                note: "Partial initialization → Default trait"
              - c: "int arr[5] = { [0] = 1, [4] = 5 };"
                rust: "let mut arr = [0; 5]; arr[0] = 1; arr[4] = 5;"
                note: "Array designators → manual initialization"
              - c: "struct Outer o = { .inner = { .x = 1 } };"
                rust: "let o = Outer { inner: Inner { x: 1 } };"
                note: "Nested designated initializers"
            validation_reference: "ISO C99 §6.7.8.17-38 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_designated_initializers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 designated initializers → Rust struct literals. Syntax: .field = value → field: value. Partial init requires Default trait. No array designators (manual init). Order independent. Type-safe field names."

  - id: 4
    name: "Expressions (C99 §6.5)"
    description: "Operators, precedence, evaluation"
    sections:
      - id: "4.1"
        name: "Primary Expressions (C99 §6.5.1)"
        tasks:
          - id: "EXPR-PRIMARY-ID"
            title: "Document identifier expressions"
            status: "completed"
            version: "v0.75.0"
            examples:
              - c: "int x = 5; y = x;"
                rust: "let x: i32 = 5; y = x;"
                note: "Simple variable identifier"
              - c: "result = calculate(x);"
                rust: "let result = calculate(x);"
                note: "Function identifier"
              - c: "result = x + y * z;"
                rust: "result = x + y * z;"
                note: "Identifiers in expression"
              - c: "int x = 5; { int x = 10; }"
                rust: "let x = 5; { let x = 10; }"
                note: "Shadowing allowed"
              - c: "int myVariable = 5;"
                rust: "let my_variable: i32 = 5;"
                note: "camelCase → snake_case"
              - c: "#define MAX_SIZE 100"
                rust: "const MAX_SIZE: usize = 100;"
                note: "SCREAMING_SNAKE_CASE for constants"
              - c: "int add(int a, int b) { return a + b; }"
                rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
                note: "Parameter identifiers"
              - c: "point.x = 10; int y = point.y;"
                rust: "point.x = 10; let y = point.y;"
                note: "Struct field identifiers"
              - c: "arr[i] = 42;"
                rust: "arr[i] = 42;"
                note: "Array identifier with index"
              - c: "int x = *ptr;"
                rust: "let x = *ptr;"
                note: "Pointer dereference with identifier"
              - c: "if (x > 0) { return x; }"
                rust: "if x > 0 { return x; }"
                note: "Identifier in condition"
              - c: "for (int i = 0; i < n; i++) { sum += i; }"
                rust: "for i in 0..n { sum += i; }"
                note: "Loop variable identifier"
              - c: "int global_counter = 0;"
                rust: "static mut GLOBAL_COUNTER: i32 = 0;"
                note: "Global → static mut (unsafe)"
              - c: "typedef int Integer; Integer x = 5;"
                rust: "type Integer = i32; let x: Integer = 5;"
                note: "Type alias identifier"
              - c: "enum Color { RED }; enum Color c = RED;"
                rust: "enum Color { Red } let c = Color::Red;"
                note: "Enum variant with qualified path"
              - c: "// Cannot use keywords"
                rust: "let r#type = \"string\"; let r#match = 5;"
                note: "Raw identifiers escape keywords"
            validation_reference: "K&R §2.1, ISO C99 §6.5.1"
            test_name: "test_identifier_expressions"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "SAFETY: Identifiers transform safely. Global mutable statics require unsafe access in Rust. Naming conventions enforced by compiler."

      - id: "4.2"
        name: "Postfix Operators (C99 §6.5.2)"
        tasks:
          - id: "EXPR-POSTFIX-ARRAY"
            title: "Document array subscripting"
            status: "completed"
            version: "v0.78.0"
            examples:
              - c: "int x = arr[i];"
                rust: "let x = arr[i];"
                note: "Simple subscript (same syntax)"
              - c: "arr[i] = 42;"
                rust: "arr[i] = 42;"
                note: "Assignment (same syntax)"
              - c: "int first = arr[0];"
                rust: "let first = arr[0];"
                note: "Constant index (zero-based)"
              - c: "int sum = arr[i] + arr[j];"
                rust: "let sum = arr[i] + arr[j];"
                note: "In expression (same)"
              - c: "int val = matrix[i][j];"
                rust: "let val = matrix[i][j];"
                note: "Multi-dimensional (same)"
              - c: "int x = arr[i + 1];"
                rust: "let x = arr[i + 1];"
                note: "Expression index (same)"
              - c: "for (int i = 0; i < n; i++) { sum += arr[i]; }"
                rust: "for i in 0..n { sum += arr[i]; }"
                note: "In loop (same pattern)"
              - c: "int* p = arr; int x = p[i];"
                rust: "let p = &arr[..]; let x = p[i];"
                note: "Pointer subscript → slice"
              - c: "if (i < len) { x = arr[i]; }"
                rust: "if let Some(&x) = arr.get(i) { }"
                note: "Manual check → get() method"
              - c: "// No slice syntax"
                rust: "let slice = &arr[2..5];"
                note: "Rust slice syntax (Rust-specific)"
              - c: "int x = arr[i % size];"
                rust: "let x = arr[i % size];"
                note: "Modulo for circular (same)"
              - c: "int val = table[row][col];"
                rust: "let val = table[row][col];"
                note: "2D separate indices (same)"
              - c: "int x = arr[i++];"
                rust: "let x = arr[i]; i += 1;"
                note: "Post-increment → separate"
              - c: "// No bounds check (UB)"
                rust: "// Bounds checked in debug (panic)"
                note: "Rust safer in debug mode"
              - c: "d.values[i]"
                rust: "d.values[i]"
                note: "Array in struct field (same)"
            validation_reference: "K&R §5.2, ISO C99 §6.5.2.1"
            test_name: "test_array_subscript"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "SAFETY: Array subscripting transforms safely. Key differences: bounds checking in debug mode (panic), get() method returns Option (always safe), slice syntax for subarray access, no negative indices (usize only). C has undefined behavior on out-of-bounds, Rust catches in debug."

          - id: "EXPR-COMPOUND-LITERAL"
            title: "Document compound literals"
            status: "completed"
            priority: "high"
            version: "v0.34.0"
            examples:
              - c: "(struct Point){ .x = 10, .y = 20 }"
                rust: "Point { x: 10, y: 20 }"
                note: "No cast syntax needed in Rust"
              - c: "draw((struct Point){ .x = 1, .y = 2 });"
                rust: "draw(Point { x: 1, y: 2 });"
                note: "Temporary struct as function argument"
              - c: "(int[]){ 1, 2, 3, 4, 5 }"
                rust: "[1, 2, 3, 4, 5]"
                note: "Array literal (no cast needed)"
              - c: "struct Point* p = &(struct Point){ .x = 1 };"
                rust: "let temp = Point { x: 1, y: 0 }; let p = &temp;"
                note: "Reference to temporary"
            validation_reference: "ISO C99 §6.5.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_compound_literals"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 compound literals → Rust struct/array literals. No (Type){} cast syntax needed. Automatic storage duration. Can be modified (lvalue). Combines with designated initializers. Rust temporaries have clear lifetime rules."

          - id: "EXPR-POSTFIX-CALL"
            title: "Document function calls"
            status: "completed"
            version: "v0.73.0"
            test_file: "crates/decy/tests/function_call_documentation_test.rs"
            examples:
              - c: "int result = add(x, y);"
                rust: "let result = add(x, y);"
                note: "Simple call: same syntax, return value assigned"
              - c: "print_message();"
                rust: "print_message();"
                note: "Void function: same syntax, no return value"
              - c: "result = calculate(a, b, c, d);"
                rust: "let result = calculate(a, b, c, d);"
                note: "Multiple arguments: comma-separated, same syntax"
              - c: "result = outer(inner(x));"
                rust: "let result = outer(inner(x));"
                note: "Nested calls: inner evaluated first, same syntax"
              - c: "if (is_valid()) { }"
                rust: "if is_valid() { }"
                note: "As condition: parentheses optional in Rust"
              - c: "void process(int x) { } process(val);"
                rust: "fn process(x: i32) { } process(val);"
                note: "Pass by value: copy semantics (i32 is Copy)"
              - c: "void modify(int* x) { } modify(&val);"
                rust: "fn modify(x: &mut i32) { } modify(&mut val);"
                note: "Pass by reference: pointer → &mut, address-of → borrow"
              - c: "foo();"
                rust: "let _ = foo();"
                note: "Ignored return: C allows, Rust warns unless explicit (let _)"
              - c: "int (*func_ptr)(int); func_ptr(42);"
                rust: "let func_ptr: fn(i32) -> i32; func_ptr(42);"
                note: "Function pointer: same call syntax, different type syntax"
              - c: "process(transform(input));"
                rust: "process(transform(input));"
                note: "Chained calls: sequential processing, same evaluation order"
            validation_reference: "K&R §4.2, ISO C99 §6.5.2.2"
            test_name: "test_function_call_transformation_summary"
            critical_safety_differences:
              - "Argument evaluation: C unspecified (pre-C99), Rust GUARANTEED left-to-right"
              - "Pass by reference: C pointers (int*), Rust references (&mut i32) type-safe"
              - "Return value usage: C can ignore, Rust WARNS unless explicit (let _)"
              - "Ownership: Rust moves non-Copy types, C always copies"
              - "No variadic functions: Rust uses macros (println!) or slices"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Function calls all C patterns. CRITICAL SAFETY: (1) Evaluation order: C unspecified (pre-C99), Rust GUARANTEED left-to-right (predictable side effects), (2) Pass by reference: C uses pointers (int* x, &val), Rust uses references (&mut i32, &mut val) with borrow checker (prevents dangling pointers), (3) Return value usage: C allows ignoring return values (common error source), Rust WARNS unless explicitly ignored (let _ = foo()), (4) Ownership semantics: C always copies (pass by value), Rust moves non-Copy types (prevents use-after-free), (5) Variadic functions: C supports (printf), Rust uses macros (println!) or slices (type-safe, compile-time checked). Transformations: same syntax for most calls, pointer→&mut for pass-by-reference, let _ for ignored returns, fn type for function pointers. Test file demonstrates simple calls, void functions, multiple/no arguments, nested calls, expressions, conditions, pass by value/reference, literals, loops, ignored returns, function pointers, chaining. All safe (0 unsafe)."

          - id: "EXPR-POSTFIX-MEMBER"
            title: "Document struct member access"
            status: "completed"
            version: "v0.85.0"
            examples:
              - c: "point.x"
                rust: "point.x"
              - c: "point->x"
                rust: "point.x"
              - c: "(*ptr).x"
                rust: "ptr.x"
              - c: "rect.top_left.x"
                rust: "rect.top_left.x"
              - c: "ptr->top_left.x"
                rust: "ptr.top_left.x"
              - c: "process(p.x)"
                rust: "process(p.x)"
              - c: "sum = p.x + p.y"
                rust: "sum = p.x + p.y"
              - c: "&p.x"
                rust: "&p.x"
              - c: "ptr->x = ptr->y + 10"
                rust: "ptr.x = ptr.y + 10"
              - c: "if (p.x > 0 && p.y > 0) { }"
                rust: "if p.x > 0 && p.y > 0 { }"
              - c: "while (c.value < c.max) { }"
                rust: "while c.value < c.max { }"
              - c: "points[0].x = 5"
                rust: "points[0].x = 5"
              - c: "(ptr + 1)->x"
                rust: "ptr[1].x"
              - c: "o.middle.inner.value"
                rust: "o.middle.inner.value"
              - c: "return ptr->y"
                rust: "return ptr.y"
            validation_reference: "K&R §6.1, ISO C99 §6.5.2.3"
            test_name: "test_member_access"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - critical difference: ptr->member becomes ptr.member (automatic dereferencing), single dot operator for all access"

          - id: "EXPR-MEMBER-ACCESS-PATTERNS"
            title: "Document struct member access patterns"
            status: "completed"
            priority: "high"
            version: "v0.47.0"
            examples:
              - c: "struct.field"
                rust: "struct.field"
                note: "Direct member access (same syntax)"
              - c: "ptr->field"
                rust: "point.field"
                note: "Arrow operator eliminated with ownership"
              - c: "(*ptr).field"
                rust: "ptr.field"
                note: "Auto-deref in Rust (cleaner)"
              - c: "outer.inner.field"
                rust: "outer.inner.field"
                note: "Nested member access (same)"
              - c: "arr[i].field"
                rust: "arr[i].field"
                note: "Array of structs (same)"
              - c: "node->next->data"
                rust: "node.next.data"
                note: "Pointer chain eliminated with references"
            validation_reference: "K&R §6.1-6.3, ISO C99 §6.5.2.3"
            test_name: "test_struct_member_access"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "Struct member access: C has dot (.) and arrow (->), Rust uses dot for both. Arrow operator ptr->field is shorthand for (*ptr).field in C. Rust eliminates arrow with ownership and auto-deref. References use dot operator (automatic dereferencing). No null pointer dereferences in safe Rust. Nested access and array access have same syntax. Pointer chains use references or Box (ownership-based). All basic member access transformations SAFE (0 unsafe for direct access, some pointer patterns may need unsafe in current transpiler)."

          - id: "EXPR-POSTFIX-INCR"
            title: "Document post-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.10.0"
            examples:
              - c: "x++"
                rust: "{ let tmp = x; x += 1; tmp }"
              - c: "x--"
                rust: "{ let tmp = x; x -= 1; tmp }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.2.4"
            test_name: "test_postfix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "EXPR-INCR-DECR-PATTERNS"
            title: "Document increment/decrement operator patterns"
            status: "completed"
            priority: "high"
            version: "v0.50.0"
            examples:
              - c: "int y = x++;"
                rust: "let y = { let tmp = x; x += 1; tmp };"
                note: "Post-increment: returns old value, then increments"
              - c: "int y = ++x;"
                rust: "let y = { x += 1; x };"
                note: "Pre-increment: increments first, then returns new value"
              - c: "int y = x--;"
                rust: "let y = { let tmp = x; x -= 1; tmp };"
                note: "Post-decrement: returns old value, then decrements"
              - c: "int y = --x;"
                rust: "let y = { x -= 1; x };"
                note: "Pre-decrement: decrements first, then returns new value"
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
                note: "Loop counter pattern (idiomatic Rust range)"
              - c: "result = x++ + 10;"
                rust: "result = { let tmp = x; x += 1; tmp } + 10;"
                note: "Post-increment in expression (uses old value)"
              - c: "result = ++x + 10;"
                rust: "result = { x += 1; x } + 10;"
                note: "Pre-increment in expression (uses new value)"
              - c: "arr[i++]"
                rust: "arr[{ let tmp = i; i += 1; tmp }]"
                note: "Array indexing with post-increment (use index, then increment)"
              - c: "arr[--i]"
                rust: "arr[{ i -= 1; i }]"
                note: "Array indexing with pre-decrement (decrement first, then use)"
              - c: "while (n > 0) { sum += n--; }"
                rust: "while n > 0 { sum += { let tmp = n; n -= 1; tmp }; }"
                note: "Decrement in loop (countdown pattern)"
            validation_reference: "K&R §2.8, ISO C99 §6.5.2.4 (post), §6.5.3.1 (pre)"
            test_name: "test_increment_decrement_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Increment/decrement operators (++/--): Rust has NO native ++/-- operators. Post-increment (x++) returns old value, then increments. Pre-increment (++x) increments first, then returns new value. Same for decrement. C allows undefined behavior with multiple modifications in single expression (x++ + x++). Rust block expressions enforce sequencing (SAFE). All transformations use block expressions with explicit steps. Requires mutable variables (mut). Common patterns: loop counters, array indexing, sequence operations. Post uses tmp variable to save old value. Pre directly uses new value after increment. All transformations SAFE (0 unsafe blocks). Rust ranges (0..n) preferred for simple loops."

      - id: "4.3"
        name: "Unary Operators (C99 §6.5.3)"
        tasks:
          - id: "EXPR-UNARY-INCR"
            title: "Document pre-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.11.0"
            examples:
              - c: "++x"
                rust: "{ x += 1; x }"
              - c: "--x"
                rust: "{ x -= 1; x }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.3.1"
            test_name: "test_prefix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "EXPR-UNARY-ADDR"
            title: "Document address-of operator (&)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "&x"
                rust: "&x"
                note: "Safe borrow in Rust"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_address_of"

          - id: "EXPR-UNARY-DEREF"
            title: "Document dereference operator (*)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "*p"
                rust: "*p"
                note: "Safe with references, may need unsafe with raw pointers"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_dereference"

          - id: "EXPR-ADDR-DEREF-PATTERNS"
            title: "Document address-of and dereference patterns"
            status: "completed"
            priority: "high"
            version: "v0.48.0"
            examples:
              - c: "int* ptr = &x;"
                rust: "let ptr: &i32 = &x;"
                note: "Address-of creates reference (safe)"
              - c: "int value = *ptr;"
                rust: "let value = *ptr;"
                note: "Dereference read (safe with &T)"
              - c: "*ptr = 20;"
                rust: "*ptr = 20;"
                note: "Dereference write (needs &mut T)"
              - c: "int** pp = &ptr;"
                rust: "let pp: &&i32 = &&x;"
                note: "Double indirection with references"
              - c: "void func(int* p) { *p = 5; }"
                rust: "fn func(p: &mut i32) { *p = 5; }"
                note: "Pointer parameters → mutable references"
              - c: "const int* cp = &x;"
                rust: "let cp: &i32 = &x;"
                note: "Const pointer → immutable reference (default)"
              - c: "int* p = &arr[i];"
                rust: "let p = &arr[i];"
                note: "Address of array element"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_address_of_dereference"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Address-of (&) and dereference (*) operators: C creates raw pointers (can be null, no lifetime tracking), Rust creates references (never null, borrow checker enforces lifetimes). C pointers: int* (mutable by default). Rust: &T (immutable) or &mut T (mutable, explicit). Dereference for reading safe with &T. Dereference for writing requires &mut T. Double indirection works with references. Pointer parameters become references. Const pointers map to immutable references. All reference operations SAFE (0 unsafe blocks). Raw pointers exist but require unsafe to dereference."

          - id: "DECL-MULTIPLE"
            title: "Document multiple variable declarations"
            status: "completed"
            priority: "high"
            version: "v0.49.0"
            examples:
              - c: "int a, b, c;"
                rust: "let a: i32;\nlet b: i32;\nlet c: i32;"
                note: "Multiple simple declarations → separate declarations"
              - c: "int x = 10, y = 20, z = 30;"
                rust: "let x = 10;\nlet y = 20;\nlet z = 30;"
                note: "With initialization → separate let statements"
              - c: "int a = 5, b, c = 10;"
                rust: "let a = 5;\nlet b: i32;\nlet c = 10;"
                note: "Mixed initialized/uninitialized → separate declarations"
              - c: "int *p, q;"
                rust: "let p: &i32;\nlet q: i32;"
                note: "CONFUSING: p is pointer, q is int (NOT pointer!)"
              - c: "int *p, *q;"
                rust: "let p: &i32;\nlet q: &i32;"
                note: "Both pointers (each needs * in C)"
              - c: "int arr[5], brr[3];"
                rust: "let arr: [i32; 5];\nlet brr: [i32; 3];"
                note: "Multiple arrays → separate declarations"
              - c: "const int MIN = 0, MAX = 100;"
                rust: "const MIN: i32 = 0;\nconst MAX: i32 = 100;"
                note: "Const multiple declarations → separate const"
              - c: "struct Point p1, p2, p3;"
                rust: "let p1: Point;\nlet p2: Point;\nlet p3: Point;"
                note: "Multiple struct instances → separate declarations"
              - c: "for (int i = 0, j = 10; i < j; i++)"
                rust: "let mut i = 0;\nlet mut j = 10;\nfor ..."
                note: "For loop multiple declarations → separate let statements"
            validation_reference: "K&R §2.2, ISO C99 §6.7"
            test_name: "test_multiple_declarations"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Multiple variable declarations (C99 §6.7): C allows declaring multiple variables in one statement (int a, b, c;). CONFUSING pattern: int *p, q; makes p a pointer but q an int (NOT a pointer). Each declarator can have different initialization. Rust requires separate declarations (clearer intent). Transformation: each variable gets its own let/const statement. Pointer/value mixing eliminated (safer). Each declaration explicit (more readable). Common patterns: simple vars, initialized vars, mixed init, multiple pointers (confusing), arrays, globals, consts, struct instances, for loops. All transformations SAFE (0 unsafe blocks). Rust approach prevents pointer/value confusion."

          - id: "EXPR-UNARY-SIZEOF"
            title: "Document sizeof operator"
            status: "completed"
            version: "v0.79.0"
            examples:
              - c: "sizeof(int)"
                rust: "std::mem::size_of::<i32>()"
                note: "Type form → generic function"
              - c: "sizeof(x)"
                rust: "std::mem::size_of_val(&x)"
                note: "Expression form → reference required"
              - c: "int arr[10]; sizeof(arr)"
                rust: "let arr: [i32; 10]; std::mem::size_of_val(&arr)"
                note: "Full array size (no decay)"
              - c: "sizeof(arr) / sizeof(arr[0])"
                rust: "arr.len()"
                note: "Array length idiom simplified"
              - c: "sizeof(struct Point)"
                rust: "std::mem::size_of::<Point>()"
                note: "User-defined type"
              - c: "sizeof(int*)"
                rust: "std::mem::size_of::<*const i32>()"
                note: "Pointer size"
              - c: "malloc(10 * sizeof(int))"
                rust: "Vec::with_capacity(10)"
                note: "Size calculation implicit in Vec"
              - c: "sizeof(char)"
                rust: "std::mem::size_of::<u8>()"
                note: "Always 1 byte"
              - c: "int matrix[3][4]; sizeof(matrix)"
                rust: "let matrix: [[i32; 4]; 3]; std::mem::size_of_val(&matrix)"
                note: "Multi-dimensional array"
              - c: "if (sizeof(void*) == 8)"
                rust: "if std::mem::size_of::<*const ()>() == 8"
                note: "Compile-time constant in condition"
              - c: "typedef int MyInt; sizeof(MyInt)"
                rust: "type MyInt = i32; std::mem::size_of::<MyInt>()"
                note: "Type alias"
              - c: "struct S { char c; int i; }; sizeof(struct S)"
                rust: "#[repr(C)] struct S { c: u8, i: i32 } std::mem::size_of::<S>()"
                note: "Struct with padding (repr(C) for C layout)"
              - c: "#define BUFFER_SIZE sizeof(struct Packet)"
                rust: "const BUFFER_SIZE: usize = std::mem::size_of::<Packet>();"
                note: "Macro → const"
              - c: "int x; sizeof x"
                rust: "let x: i32; std::mem::size_of_val(&x)"
                note: "sizeof without parentheses (rare)"
              - c: "char buffer[sizeof(struct Data)]"
                rust: "let buffer: [u8; std::mem::size_of::<Data>()]"
                note: "sizeof in array size"
            validation_reference: "K&R §5.4, ISO C99 §6.5.3.4"
            test_name: "test_sizeof_operator"
            completed_ticket: "DECY-044"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "sizeof operator (C99 §6.5.3.4): C compile-time operator returning size in bytes. Returns size_t. Syntax: sizeof(type) or sizeof expression. Parentheses required for types, optional for expressions. Rust uses std::mem::size_of::<T>() for types, std::mem::size_of_val(&x) for values. Returns usize. Always compile-time for size_of::<T>(). Critical: array sizeof gives full size (no decay). Common idiom sizeof(arr)/sizeof(arr[0]) → arr.len(). Struct padding preserved with repr(C). All transformations SAFE (0 unsafe blocks). Rust prevents incomplete types via type system."

          - id: "EXPR-CAST"
            title: "Document cast operators"
            status: "completed"
            priority: "high"
            version: "v0.29.0"
            examples:
              - c: "int i = (int)3.14;"
                rust: "let i = 3.14 as i32;"
                note: "Numeric cast uses as operator (SAFE)"
              - c: "unsigned u = (unsigned)-1;"
                rust: "let u = -1i32 as u32;"
                note: "Wrapping is well-defined"
              - c: "int bits = *(int*)&f;"
                rust: "let bits = f.to_bits();"
                note: "Type punning has safe methods"
              - c: "void* vp = (void*)ptr;"
                rust: "let vp = ptr as *const ();"
                note: "Pointer casts safe to create, unsafe to deref"
            validation_reference: "K&R §2.7, ISO C99 §6.5.4"
            test_name: "test_cast_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "Cast operators → as operator (SAFE for most casts). Numeric conversions explicit and well-defined. Type punning has safe methods (to_bits). Only transmute requires unsafe. From/Into traits for struct conversions."

      - id: "4.4"
        name: "Arithmetic Operators (C99 §6.5.5-6.5.7)"
        tasks:
          - id: "EXPR-ARITH-BINARY"
            title: "Document binary arithmetic"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "a + b"
                rust: "a + b"
              - c: "a * b"
                rust: "a * b"
              - c: "a / b"
                rust: "a / b"
                note: "Rust panics on division by zero (safer)"
            validation_reference: "K&R §2.5, ISO C99 §6.5.5-6"
            test_name: "test_arithmetic_operators"

          - id: "EXPR-ARITH-BINARY-PATTERNS"
            title: "Document binary arithmetic operator patterns"
            status: "completed"
            priority: "high"
            version: "v0.53.0"
            examples:
              - c: "sum = a + b;"
                rust: "sum = a + b;"
                note: "Addition (same syntax)"
              - c: "diff = a - b;"
                rust: "diff = a - b;"
                note: "Subtraction (same syntax)"
              - c: "product = a * b;"
                rust: "product = a * b;"
                note: "Multiplication (same syntax)"
              - c: "quotient = a / b;"
                rust: "quotient = a / b;"
                note: "Division (C undefined for /0, Rust panics - safe)"
              - c: "remainder = a % b;"
                rust: "remainder = a % b;"
                note: "Modulus (C undefined for %0, Rust panics - safe)"
              - c: "result = a + b * c;"
                rust: "result = a + b * c;"
                note: "Precedence: * before + (same in both)"
              - c: "result = (a + b) * c;"
                rust: "result = (a + b) * c;"
                note: "Parentheses force evaluation order"
              - c: "result = 7 / 2;"
                rust: "result = 7 / 2;"
                note: "Integer division truncates (3, not 3.5)"
              - c: "remainder = -17 % 5;"
                rust: "remainder = -17 % 5;"
                note: "Modulus sign matches dividend (-2)"
              - c: "formula = a*x*x + b*x + c;"
                rust: "formula = a*x*x + b*x + c;"
                note: "Compound expressions work identically"
            validation_reference: "K&R §2.5, ISO C99 §6.5.5 (multiplicative), §6.5.6 (additive)"
            test_name: "test_binary_arithmetic_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Binary arithmetic operators (+, -, *, /, %): Same syntax in C and Rust. Key difference: C has undefined behavior for division/modulus by zero, Rust panics (safe). Operator precedence identical (* / % before + -). Integer division truncates toward zero in both. Modulus sign matches dividend (first operand). Rust stricter on type mixing (requires explicit casts). Integer overflow: C undefined (signed) or wraps (unsigned), Rust panics in debug, wraps in release. All transformations SAFE (0 unsafe blocks). Performance identical (same machine instructions)."

          - id: "EXPR-ARITH-PTR"
            title: "Document pointer arithmetic → slice indexing"
            status: "blocked"
            phase: "RED"
            priority: "high"
            examples:
              - c: "p + 1"
                rust: "&arr[i + 1]"
                note: "Eliminate pointer arithmetic with slices"
            validation_reference: "K&R §5.3, ISO C99 §6.5.6"
            test_name: "test_pointer_arithmetic_safe"
            sprint: 3
            ownership_inference: "CRITICAL"
            red_phase_date: "2025-10-15"
            tests_added: 9
            tests_passing: 1
            tests_failing: 8
            blocked_reason: "Requires ownership inference infrastructure (pointer dataflow, array detection, pointer classification)"
            implementation_plan: "docs/EXPR-ARITH-PTR-implementation-plan.md"
            note: "RED phase complete - paused pending ownership inference foundation"

          - id: "EXPR-BITWISE"
            title: "Document bitwise operators"
            status: "completed"
            version: "v0.25.0"
            priority: "high"
            examples:
              - c: "a & b"
                rust: "a & b"
              - c: "a | b"
                rust: "a | b"
              - c: "a ^ b"
                rust: "a ^ b"
              - c: "~a"
                rust: "!a"
                note: "C uses ~, Rust uses ! for bitwise NOT"
              - c: "a << n"
                rust: "a << n"
              - c: "a >> n"
                rust: "a >> n"
            validation_reference: "K&R §2.9, ISO C99 §6.5.10-6.5.12"
            test_name: "test_bitwise_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Bitwise operators (&, |, ^, ~, <<, >>) for bit manipulation, flags, masks. All operations are safe. Syntax identical to C except NOT (~→!). Type-safe signed/unsigned handling."

      - id: "4.5"
        name: "Comparison Operators (C99 §6.5.8-6.5.9)"
        tasks:
          - id: "EXPR-CMP-RELATIONAL"
            title: "Document relational operators"
            status: "completed"
            priority: "high"
            version: "v0.61.0"
            examples:
              - c: "if (a < b) { smaller = a; }"
                rust: "if a < b { smaller = a; }"
                note: "Less than: same syntax, returns bool in Rust (not int)"
              - c: "if (a > b) { larger = a; }"
                rust: "if a > b { larger = a; }"
                note: "Greater than: common for max/sorting operations"
              - c: "if (a <= b) { process(); }"
                rust: "if a <= b { process(); }"
                note: "Less than or equal: inclusive lower bound"
              - c: "if (a >= b) { process(); }"
                rust: "if a >= b { process(); }"
                note: "Greater than or equal: inclusive upper bound"
              - c: "if (x >= MIN && x <= MAX) { in_range = 1; }"
                rust: "if x >= MIN && x <= MAX { in_range = true; }"
                note: "Range check: combining comparisons for validation"
              - c: "int min = (a < b) ? a : b;"
                rust: "let min = if a < b { a } else { b };"
                note: "Finding min/max: ternary → if expression"
            validation_reference: "K&R §2.6, ISO C99 §6.5.8"
            test_name: "test_comparison_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Relational operators (<, >, <=, >=): Same syntax in C and Rust. Return type: C returns int (0 or 1), Rust returns bool (type-safe). Type requirements: Rust requires PartialOrd trait. Common patterns: range checking, loop bounds, finding min/max, sorting. All transformations type-safe (0 unsafe blocks). Combined with equality operators in single test file."

          - id: "EXPR-CMP-EQUALITY"
            title: "Document equality operators"
            status: "completed"
            priority: "high"
            version: "v0.61.0"
            examples:
              - c: "if (a == b) { handle_equal(); }"
                rust: "if a == b { handle_equal(); }"
                note: "Equality: same syntax, returns bool in Rust"
              - c: "if (a != b) { handle_different(); }"
                rust: "if a != b { handle_different(); }"
                note: "Inequality: common for sentinel/NULL checks"
              - c: "if (ptr != NULL && value != 0) { ... }"
                rust: "if let Some(ptr) = opt { if value != 0 { ... } }"
                note: "NULL check: C uses !=, Rust uses Option pattern"
              - c: "if (strcmp(str1, str2) == 0) { strings_equal(); }"
                rust: "if str1 == str2 { strings_equal(); }"
                note: "String comparison: C needs strcmp, Rust uses direct =="
              - c: "int is_equal = (a == b);"
                rust: "let is_equal = a == b;"
                note: "Comparison as value: C stores int, Rust stores bool"
            validation_reference: "K&R §2.6, ISO C99 §6.5.9"
            test_name: "test_comparison_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Equality operators (==, !=): Same syntax in C and Rust. Return type: C returns int (0 or 1), Rust returns bool (type-safe). Type requirements: Rust requires PartialEq trait. String comparison: C needs strcmp function, Rust supports direct == (more intuitive). NULL checks: C uses ptr != NULL, Rust uses Option pattern. Common patterns: sentinel checks, validation, loop termination. All transformations type-safe (0 unsafe blocks). Combined with relational operators in single test file."

      - id: "4.6"
        name: "Logical Operators (C99 §6.5.13-6.5.14)"
        tasks:
          - id: "EXPR-LOGICAL-AND"
            title: "Document logical AND (&&)"
            status: "completed"
            priority: "high"
            version: "v0.60.0"
            examples:
              - c: "if (a && b) { process(); }"
                rust: "if a && b { process(); }"
                note: "Simple AND: same syntax, Rust requires bool operands (type safe)"
              - c: "if (a && b && c) { process(); }"
                rust: "if a && b && c { process(); }"
                note: "Multiple AND: left-to-right, short-circuit on first false"
              - c: "if (is_valid(ptr) && expensive_check(ptr)) { ... }"
                rust: "if is_valid(ptr) && expensive_check(ptr) { ... }"
                note: "Short-circuit: expensive_check NOT called if is_valid false"
              - c: "if (ptr != NULL && ptr->field > 0) { ... }"
                rust: "if let Some(ptr) = opt { if ptr.field > 0 { ... } }"
                note: "NULL check: C short-circuit prevents deref, Rust uses Option"
              - c: "if (x >= MIN && x <= MAX) { in_range(x); }"
                rust: "if x >= MIN && x <= MAX { in_range(x); }"
                note: "Range check: combines lower and upper bounds"
              - c: "int x = 5; if (x && y) { ... }"
                rust: "let x = 5; if x != 0 && y { ... }"
                note: "C allows int as bool (implicit), Rust requires explicit comparison"
            validation_reference: "K&R §2.6, ISO C99 §6.5.13"
            test_name: "test_logical_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Logical AND (&&): Short-circuit evaluation (if left false, right NOT evaluated). C and Rust same syntax. Critical difference: C allows any integer as bool (0=false, non-zero=true), Rust REQUIRES bool type (compile error for int). Short-circuit prevents null deref in C (ptr != NULL && ptr->field), prevents expensive computation. Common patterns: multiple conditions, NULL/Option checks, range validation, function guards. Type safety: Rust prevents assignment in condition (if x = 5 is error), C allows (common bug source). All transformations type-safe (0 unsafe blocks)."

          - id: "EXPR-LOGICAL-OR"
            title: "Document logical OR (||)"
            status: "completed"
            priority: "high"
            version: "v0.60.0"
            examples:
              - c: "if (a || b) { process(); }"
                rust: "if a || b { process(); }"
                note: "Simple OR: same syntax, Rust requires bool operands"
              - c: "if (a || b || c) { process(); }"
                rust: "if a || b || c { process(); }"
                note: "Multiple OR: left-to-right, short-circuit on first true"
              - c: "if ((a && b) || c) { process(); }"
                rust: "if (a && b) || c { process(); }"
                note: "Combined: AND binds tighter than OR, use parens for clarity"
              - c: "int value = get_cached() || get_computed();"
                rust: "let value = get_cached() || get_computed();"
                note: "Fallback pattern: try cached first, compute only if needed"
              - c: "if (!(a && b)) { ... }"
                rust: "if !(a && b) { ... }  // Or: if !a || !b { ... }"
                note: "De Morgan's law: !(a && b) == !a || !b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.14"
            test_name: "test_logical_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Logical OR (||): Short-circuit evaluation (if left true, right NOT evaluated). C and Rust same syntax. Type safety: Rust requires bool, C allows int (0=false, non-zero=true). Common patterns: fallback/default values, multiple exit conditions, error checks. Precedence: AND (&&) binds tighter than OR (||). De Morgan's laws apply. All transformations type-safe (0 unsafe blocks). Combined with AND documentation in single comprehensive test file."

          - id: "EXPR-SHORT-CIRCUIT"
            title: "Document short-circuit evaluation"
            status: "completed"
            priority: "high"
            version: "v0.45.0"
            examples:
              - c: "if (ptr != NULL && ptr->value > 0) { ... }"
                rust: "if ptr.is_some() && ptr.unwrap().value > 0 { ... }"
                note: "Null check prevents crash (right not evaluated if left false)"
              - c: "if (i < len && arr[i] > 0) { ... }"
                rust: "if i < len && arr[i] > 0 { ... }"
                note: "Bounds check prevents out-of-bounds access"
              - c: "result = 0 && expensive();"
                rust: "result = false && expensive();"
                note: "expensive() NOT called (short-circuit)"
              - c: "result = 1 || expensive();"
                rust: "result = true || expensive();"
                note: "expensive() NOT called (short-circuit)"
              - c: "if (cached || (cached = init())) { ... }"
                rust: "if cached || { cached = init(); cached } { ... }"
                note: "Lazy initialization pattern"
            validation_reference: "K&R §2.6, ISO C99 §6.5.13-6.5.14"
            test_name: "test_short_circuit_evaluation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Short-circuit evaluation: && stops at first false, || stops at first true. Right operand NOT evaluated if result determined from left. Critical for safety (null checks, bounds checks). Same semantics in C and Rust. Evaluation order: left-to-right (guaranteed). Common patterns: ptr && ptr->field, i < len && arr[i], cheap() && expensive(), cached || init(). All transformations SAFE (0 unsafe blocks)."

          - id: "EXPR-TERNARY"
            title: "Document ternary operator (? :)"
            status: "completed"
            priority: "high"
            version: "v0.62.0"
            examples:
              - c: "max = (a > b) ? a : b;"
                rust: "let max = if a > b { a } else { b };"
                note: "Simple ternary → if expression (same short-circuit)"
              - c: "sign = (x >= 0) ? 1 : -1;"
                rust: "let sign = if x >= 0 { 1 } else { -1 };"
                note: "Sign determination pattern"
              - c: "return (x >= 0) ? x : -x;"
                rust: "if x >= 0 { x } else { -x }"
                note: "Ternary in return → if expression as implicit return"
              - c: "grade = (x >= 90) ? 'A' : (x >= 80) ? 'B' : 'C';"
                rust: "let grade = if x >= 90 { 'A' } else if x >= 80 { 'B' } else { 'C' };"
                note: "Nested ternary → if-else-if chain (MUCH more readable)"
              - c: "grade = (x >= 90) ? 'A' : (x >= 80) ? 'B' : (x >= 70) ? 'C' : 'F';"
                rust: "let grade = if x >= 90 { 'A' } else if x >= 80 { 'B' } else if x >= 70 { 'C' } else { 'F' };"
                note: "Deeply nested ternary dramatically more readable as if-else-if"
              - c: "result = is_cached() ? get_cached() : compute();"
                rust: "let result = if is_cached() { get_cached() } else { compute() };"
                note: "Function calls: short-circuit preserved, only one called"
              - c: "value = (ptr != NULL) ? ptr->data : default;"
                rust: "let value = if let Some(ptr) = opt { ptr.data } else { default };"
                note: "NULL check → Option pattern matching (safe)"
              - c: "result = (b != 0) ? a / b : 0;"
                rust: "let result = if b != 0 { a / b } else { 0 };"
                note: "Zero check guard (prevent division by zero)"
              - c: "clamped = (x < MIN) ? MIN : (x > MAX) ? MAX : x;"
                rust: "let clamped = if x < MIN { MIN } else if x > MAX { MAX } else { x };"
                note: "Clamp/bounds check pattern (three-way decision)"
              - c: "is_valid = (x >= 0 && x < 100) ? 1 : 0;"
                rust: "let is_valid = x >= 0 && x < 100;"
                note: "Boolean result: unnecessary ternary eliminated (type safety)"
            validation_reference: "K&R §2.11, ISO C99 §6.5.15"
            test_name: "test_ternary_operator"
            test_file: "ternary_operator_documentation_test.rs"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Ternary operator (? :) → if expression (SAFE, 100% coverage). Critical differences: (1) Rust if expressions are TYPE-SAFE (both branches must match types, C allows implicit conversions), (2) Condition must be bool in Rust (C allows any integer), (3) If-else-if chains dramatically more readable than nested ternaries, (4) Option pattern matching replaces NULL checks safely. Short-circuit evaluation preserved. All transformations safe (0 unsafe blocks). Test file demonstrates: simple max/min, sign determination, return expressions, nested grades (3-4 levels), function calls, NULL/zero checks, clamping, boolean simplification, array initialization, printing, pointer truthy checks, sign extension, default values. Syntax difference makes nested conditions vastly more maintainable."

          - id: "EXPR-COMMA"
            title: "Document comma operator"
            status: "completed"
            priority: "high"
            version: "v0.44.0"
            examples:
              - c: "x = (a = 1, b = 2, a + b);"
                rust: "let x = { a = 1; b = 2; a + b };"
                note: "Comma operator → block expression"
              - c: "for (i = 0, j = n; i < j; i++, j--) { ... }"
                rust: "{ i = 0; j = n; } for ... { ... i += 1; j -= 1; }"
                note: "For loop comma → separate init/update statements"
              - c: "while (x = f(), x > 0) { ... }"
                rust: "while { let x = f(); x > 0 } { ... }"
                note: "While condition comma → block expression"
              - c: "(expr1, expr2, expr3)"
                rust: "{ expr1; expr2; expr3 }"
                note: "Left-to-right evaluation, returns last value"
            validation_reference: "K&R §2.12, ISO C99 §6.5.17"
            test_name: "test_comma_operator"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Comma operator (lowest precedence) → block expressions. Guaranteed left-to-right evaluation in both C and Rust. All subexpressions evaluated for side effects. Returns rightmost value. Block expressions provide same semantics with explicit scoping. All transformations SAFE (0 unsafe blocks)."

      - id: "4.7"
        name: "Assignment Operators (C99 §6.5.16)"
        tasks:
          - id: "EXPR-ASSIGN-SIMPLE"
            title: "Document simple assignment"
            status: "completed"
            version: "v0.72.0"
            test_file: "crates/decy/tests/simple_assignment_documentation_test.rs"
            examples:
              - c: "int x = 0; x = 5;"
                rust: "let mut x = 0; x = 5;"
                note: "Simple assignment: Rust requires mut keyword (immutable by default)"
              - c: "int i; float f = 3.14; i = f;"
                rust: "let mut i: i32; let f: f32 = 3.14; i = f as i32;"
                note: "Type conversion: C implicit → Rust EXPLICIT cast required"
              - c: "x = a + b * c;"
                rust: "x = a + b * c;"
                note: "Assignment from expression: same syntax"
              - c: "int arr[10]; arr[0] = 42;"
                rust: "let mut arr: [i32; 10]; arr[0] = 42;"
                note: "Array element: array must be mut"
              - c: "struct Point p; p.x = 10;"
                rust: "let mut p: Point; p.x = 10;"
                note: "Struct field: struct must be mut"
              - c: "int* ptr; *ptr = 42;"
                rust: "let ptr: *mut i32; unsafe { *ptr = 42; }"
                note: "Pointer dereference: unsafe required in Rust"
              - c: "int a, b, c; a = b = c = 5;"
                rust: "let mut a: i32; let mut b: i32; let mut c: i32; c = 5; b = 5; a = 5;"
                note: "Chained assignment: C allows chaining, Rust must split (cannot chain)"
              - c: "if ((x = get_value()) != 0) { }"
                rust: "x = get_value(); if x != 0 { }"
                note: "Assignment in condition: C allows (common bug source), Rust must separate"
              - c: "const int x = 5;"
                rust: "let x = 5;"
                note: "Immutability: C const vs Rust let (immutable by default)"
              - c: "int max; max = (a > b) ? a : b;"
                rust: "let max = if a > b { a } else { b };"
                note: "Assignment from ternary: Rust if expression, can use let directly"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16"
            test_name: "test_simple_assignment_transformation_summary"
            critical_safety_differences:
              - "Mutability: C mutable by default, Rust IMMUTABLE by default (requires mut)"
              - "Assignment as statement: C returns value (can chain), Rust returns () (cannot chain)"
              - "Assignment in conditions: C allows (bug-prone), Rust COMPILE ERROR"
              - "Type conversions: C implicit, Rust EXPLICIT cast required (type-safe)"
              - "Pointer dereference: C direct, Rust requires unsafe block"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: "Required for pointer dereference only"
            note: "COMPREHENSIVE DOCUMENTATION: Simple assignment all C patterns. CRITICAL SAFETY: (1) Mutability: C variables mutable by default, Rust IMMUTABLE by default (prevents accidental modification), requires mut keyword for reassignment, (2) Assignment as expression: C assignment returns value (allows chaining x=y=5), Rust returns () unit type (COMPILE ERROR on chain), prevents complex assignment expressions, (3) Assignment in conditions: C allows if((x=foo())!=0) (common source of = vs == bugs), Rust COMPILE ERROR (must separate assignment and condition), (4) Type safety: C implicit conversions (int=float truncates silently), Rust EXPLICIT cast required (visible, intentional), (5) Chained assignments: C right-to-left evaluation (a=b=c=5 valid), Rust must split into separate statements (clearer intent). Transformations: simple assignment requires mut, type conversions need explicit cast, chained assignments split, assignment-in-condition separate, pointer dereference unsafe. Test file demonstrates all assignment patterns, mutability requirements, type conversions, chaining issues, condition assignments, const/immutable. Unsafe only for pointer operations."

          - id: "EXPR-ASSIGN-COMPOUND"
            title: "Document compound assignment"
            status: "completed"
            priority: "medium"
            version: "v0.63.0"
            examples:
              - c: "count += 5;"
                rust: "count += 5;"
                note: "Addition assignment: same syntax, type-safe, requires mut"
              - c: "balance -= 25;"
                rust: "balance -= 25;"
                note: "Subtraction assignment: checked overflow in debug"
              - c: "value *= 3;"
                rust: "value *= 3;"
                note: "Multiplication assignment: same syntax, type-safe"
              - c: "total /= 4;"
                rust: "total /= 4;"
                note: "Division assignment: panics on division by zero (safe)"
              - c: "index %= 10;"
                rust: "index %= 10;"
                note: "Modulo assignment: panics on mod by zero (safe)"
              - c: "flags &= mask;"
                rust: "flags &= mask;"
                note: "Bitwise AND: clear bits (masking pattern)"
              - c: "flags |= bit;"
                rust: "flags |= bit;"
                note: "Bitwise OR: set bits (most common flag operation)"
              - c: "state ^= toggle;"
                rust: "state ^= toggle;"
                note: "Bitwise XOR: toggle bits (XOR with same value = 0)"
              - c: "value <<= n;"
                rust: "value <<= n;"
                note: "Left shift: multiply by power of 2, panics on overflow"
              - c: "value >>= n;"
                rust: "value >>= n;"
                note: "Right shift: divide by power of 2, sign-extends signed"
              - c: "for (int i = 0; i < n; i++) { sum += arr[i]; }"
                rust: "for i in 0..n { sum += arr[i]; }"
                note: "Accumulation pattern in loops (most common use case)"
              - c: "arr[find_index()] += value;"
                rust: "arr[find_index()] += value;"
                note: "Complex lvalue: find_index() evaluated ONCE (same guarantee)"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16.2"
            test_name: "test_compound_assignment"
            test_file: "compound_assignment_documentation_test.rs"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: All 10 compound assignment operators (+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=) with 100% coverage. Critical differences: (1) C signed overflow is UNDEFINED BEHAVIOR, Rust panics in debug/wraps in release (well-defined), (2) Rust REQUIRES mut (compile-time check), C mutable by default, (3) Rust requires compatible types (compile error), C allows implicit conversions, (4) Division/modulo by zero: C is UNDEFINED BEHAVIOR, Rust panics safely. Same syntax as C. Left operand evaluated once (same guarantee, critical for side effects). Test file demonstrates: all 10 operators, loop accumulation, array elements, complex lvalues, multiple assignments, type safety, mutability requirements. All transformations safe (0 unsafe blocks). Arithmetic operators panic on overflow/div-by-zero in debug. Bitwise operators common for flags, masks, bit manipulation."

  - id: 5
    name: "Statements (C99 §6.8)"
    description: "Control flow, iteration, jumps"
    sections:
      - id: "5.1"
        name: "Expression Statements (C99 §6.8.3)"
        tasks:
          - id: "STMT-EXPR"
            title: "Document expression statements"
            status: "completed"
            version: "v0.76.0"
            examples:
              - c: "x = 5;"
                rust: "x = 5;"
                note: "Simple assignment statement"
              - c: "print_message();"
                rust: "print_message();"
                note: "Function call statement"
              - c: "x++;"
                rust: "x += 1;"
                note: "Increment → compound assignment"
              - c: "count--;"
                rust: "count -= 1;"
                note: "Decrement → compound assignment"
              - c: "total += amount;"
                rust: "total += amount;"
                note: "Compound assignment (same)"
              - c: "while (*p++) ;"
                rust: "while { ... } { }"
                note: "Empty statement → empty block"
              - c: "x = 1; y = 2; z = 3;"
                rust: "x = 1; y = 2; z = 3;"
                note: "Sequential statements (same)"
              - c: "{ x = 5; y = x + 1; }"
                rust: "{ x = 5; y = x + 1; }"
                note: "Statements in block (same)"
              - c: "arr[i] = 42;"
                rust: "arr[i] = 42;"
                note: "Array assignment (same)"
              - c: "point.x = 10; point.y = 20;"
                rust: "point.x = 10; point.y = 20;"
                note: "Struct field assignment (same)"
              - c: "*ptr = 100;"
                rust: "*ptr = 100;"
                note: "Pointer dereference assignment (same)"
              - c: "increment_counter(); update_state();"
                rust: "increment_counter(); update_state();"
                note: "Side effect statements (same)"
              - c: "// Blocks don't return values"
                rust: "let x = { let a = 5; a + 1 };"
                note: "Rust blocks are expressions"
              - c: "calculate();"
                rust: "let _ = calculate();"
                note: "Explicit ignore for must_use types"
              - c: "if ((x = foo()) != 0) { }"
                rust: "x = foo(); if x != 0 { }"
                note: "Assignment NOT allowed in condition"
            validation_reference: "K&R §3.2, ISO C99 §6.8.3"
            test_name: "test_expression_statement"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "SAFETY: Expression statements transform safely. Key difference: Rust blocks are expressions (can return value). Assignment NOT allowed in conditions (prevents = vs == bugs). Unused value warnings for Result/must_use types. Semicolon distinction critical."

          - id: "STMT-MIXED-DECL"
            title: "Document mixed declarations and code"
            status: "completed"
            priority: "high"
            version: "v0.39.0"
            examples:
              - c: "int x = 10; printf(\"%d\", x); int y = 20;"
                rust: "let x = 10; println!(\"{}\", x); let y = 20;"
                note: "C99 allows declarations anywhere (C89/K&R required at block start)"
              - c: "for (int i = 0; i < n; i++) { int value = get(i); use(value); }"
                rust: "for i in 0..n { let value = get(i); use(value); }"
                note: "Declare close to first use"
              - c: "if (cond) { printf(\"yes\"); } int x = 10;"
                rust: "if cond { println!(\"yes\"); } let x = 10;"
                note: "Declaration after control flow"
            validation_reference: "ISO C99 §6.8 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_mixed_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R required all declarations at block start. C99 removed this restriction (major improvement). Rust always allowed declarations anywhere (like C99). Both encourage 'declare near use' principle. Reduces variable scope → fewer bugs. More natural code flow. Purely syntactic - no semantic differences."

      - id: "5.2"
        name: "Selection Statements (C99 §6.8.4)"
        tasks:
          - id: "STMT-IF"
            title: "Document if statements"
            status: "completed"
            version: "v0.77.0"
            examples:
              - c: "if (x > 0) { printf(\"positive\\n\"); }"
                rust: "if x > 0 { println!(\"positive\"); }"
                note: "Simple if (remove parens, keep comparison)"
              - c: "if (x) { do_something(); }"
                rust: "if x != 0 { do_something(); }"
                note: "Implicit bool → explicit comparison"
              - c: "if (x > 0) { y = 1; } else { y = -1; }"
                rust: "if x > 0 { y = 1; } else { y = -1; }"
                note: "If-else (same structure)"
              - c: "if (x > 0) { r = 1; } else if (x < 0) { r = -1; } else { r = 0; }"
                rust: "if x > 0 { r = 1; } else if x < 0 { r = -1; } else { r = 0; }"
                note: "If-else if-else chain (same)"
              - c: "int y; if (x > 0) { y = 1; } else { y = -1; }"
                rust: "let y = if x > 0 { 1 } else { -1 };"
                note: "If as expression (Rust can assign)"
              - c: "if (x > 0) { if (y > 0) { printf(\"both\\n\"); } }"
                rust: "if x > 0 { if y > 0 { println!(\"both\"); } }"
                note: "Nested if (braces clarify)"
              - c: "if (x <= 0) { return -1; }"
                rust: "if x <= 0 { return -1; }"
                note: "Early return guard clause (same)"
              - c: "if (x > 0 && y > 0) { printf(\"both\\n\"); }"
                rust: "if x > 0 && y > 0 { println!(\"both\"); }"
                note: "Logical AND (same)"
              - c: "if (x < 0 || y < 0) { printf(\"one\\n\"); }"
                rust: "if x < 0 || y < 0 { println!(\"one\"); }"
                note: "Logical OR (same)"
              - c: "if (!(x > 0)) { printf(\"not pos\\n\"); }"
                rust: "if !(x > 0) { println!(\"not pos\"); }"
                note: "Negation (parens optional in Rust)"
              - c: "if (ptr != NULL) { use_ptr(ptr); }"
                rust: "if !ptr.is_null() { use_ptr(ptr); }"
                note: "Pointer check (NULL → is_null())"
              - c: "if (x > 0) printf(\"pos\\n\");"
                rust: "if x > 0 { println!(\"pos\"); }"
                note: "Single statement (braces required in Rust)"
              - c: "if (x == 0) { printf(\"zero\\n\"); }"
                rust: "if x == 0 { println!(\"zero\"); }"
                note: "Equality (same)"
              - c: "if (x != 0) { process(x); }"
                rust: "if x != 0 { process(x); }"
                note: "Inequality (same)"
              - c: "// C if is statement (no value)"
                rust: "let result: i32 = if condition { 42 } else { 0 };"
                note: "If expression with type inference"
            validation_reference: "K&R §3.2, ISO C99 §6.8.4.1"
            test_name: "test_if_statement"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "SAFETY: If statements transform safely. Key differences: condition must be bool (no implicit conversion), parentheses optional, braces required, if is expression (can return value), no dangling else ambiguity. Prevents = vs == bugs in conditions."

          - id: "STMT-IF-PATTERNS"
            title: "Document if/else statement patterns"
            status: "completed"
            priority: "high"
            version: "v0.54.0"
            examples:
              - c: "if (x > 0) { y = 1; }"
                rust: "if x > 0 { y = 1; }"
                note: "Simple if (boolean condition required in Rust)"
              - c: "if (x > 0) { y = 1; } else { y = 0; }"
                rust: "if x > 0 { y = 1; } else { y = 0; }"
                note: "If-else (same structure)"
              - c: "if (x >= 90) ... else if (x >= 80) ... else ..."
                rust: "if x >= 90 ... else if x >= 80 ... else ..."
                note: "Else-if chain (same structure)"
              - c: "if (x > 0) { if (y > 0) { ... } }"
                rust: "if x > 0 { if y > 0 { ... } }"
                note: "Nested if statements"
              - c: "if (x > 0 && y > 0) { ... }"
                rust: "if x > 0 && y > 0 { ... }"
                note: "Complex condition with logical operators"
              - c: "if (error) { return -1; }"
                rust: "if error { return -1; }"
                note: "Guard clause (early return)"
              - c: "if (x) stmt;"
                rust: "if x != 0 { stmt; }"
                note: "C int as bool → Rust explicit comparison"
              - c: "int r; if (c) r=1; else r=0;"
                rust: "let r = if c { 1 } else { 0 };"
                note: "Rust if as expression (can return value)"
              - c: "if (x = 5) { ... }"
                rust: "Compile error in Rust"
                note: "Assignment in condition prevented (common C bug)"
            validation_reference: "K&R §3.2, ISO C99 §6.8.4.1"
            test_name: "test_if_else_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "If/else statements: Nearly identical syntax in C and Rust. Key difference: C allows int as bool (0=false, non-zero=true), Rust requires explicit bool. Rust if is expression (can return value), C if is statement only. Rust always requires braces (prevents dangling else bugs). Rust prevents assignment in condition (compile error for if (x = 5)). Same else-binding rule (else binds to nearest if). All comparison and logical operators work identically. Common patterns: simple if, if-else, else-if chains, nested conditions, guard clauses. All transformations SAFE (0 unsafe blocks). Type-safe boolean conditions prevent common C bugs."

          - id: "STMT-SWITCH"
            title: "Document switch → match"
            status: "completed"
            version: "v0.92.0"
            priority: "high"
            examples:
              - c: "switch (x) { case 1: y=10; break; default: y=0; }"
                rust: "let y = match x { 1 => 10, _ => 0 };"
                note: "Basic switch → match, expression-based"
              - c: "switch (x) { case 1: return 10; }"
                rust: "match x { 1 => 10, _ => 0 }"
                note: "Return values → match expression"
              - c: "switch (x) { case 1: case 2: case 3: break; }"
                rust: "match x { 1 | 2 | 3 => {}, _ => {} }"
                note: "Multiple cases → pattern alternatives |"
              - c: "switch (x) { case 1: break; }"
                rust: "match x { 1 => {}, _ => panic!() }"
                note: "No default → _ required (exhaustiveness)"
              - c: "switch (x) { case 1: break; }"
                rust: "match x { 1 => {}, _ => {} }"
                note: "Empty case → empty arm {}"
              - c: "switch (c) { case 'a': break; }"
                rust: "match c { b'a' => {}, _ => {} }"
                note: "Character switch → byte literal"
              - c: "switch (x) { case 1: switch (y) { } break; }"
                rust: "match x { 1 => match y { _ => {} }, _ => {} }"
                note: "Nested switch → nested match"
              - c: "switch (x) { case 0: case 1: case 2: break; }"
                rust: "match x { 0..=2 => {}, _ => {} }"
                note: "Consecutive values → range pattern ..="
              - c: "switch (color) { case RED: break; case GREEN: break; }"
                rust: "match color { Color::Red => {}, Color::Green => {}, Color::Blue => {} }"
                note: "Enum switch → exhaustive enum match"
              - c: "switch (x) { case 1: { int t=x*2; } break; }"
                rust: "match x { 1 => { let t=x*2; t+1 }, _ => 0 }"
                note: "Blocks in case → blocks in arm"
              - c: "for (...) { switch (x) { case 0: continue; } }"
                rust: "for ... { match x { 0 => continue, _ => {} } }"
                note: "Loop control → preserved in match"
              - c: "switch (x) { case 1: if (y>10) {...} break; }"
                rust: "match x { 1 if y>10 => {...}, 1 => {...}, _ => {} }"
                note: "Complex conditions → pattern guards"
              - c: "switch (x) { case 1: /* forgot break */ case 2: break; }"
                rust: "match x { 1 => {}, 2 => {}, _ => {} }"
                note: "Fall-through bug prevented (no fall-through in Rust)"
              - c: "switch (flag) { case 0: x=0; break; case 1: x=1; break; }"
                rust: "let x = if flag != 0 { 1 } else { 0 };"
                note: "Boolean switch → if-else (more idiomatic)"
              - c: "#define ERR 1; switch (x) { case ERR: break; }"
                rust: "const ERR: i32 = 1; match x { ERR => {}, _ => {} }"
                note: "Macros → constants in patterns"
            validation_reference: "K&R §3.4, ISO C99 §6.8.4.2"
            test_name: "test_switch_to_match"
            test_file: "switch_to_match_documentation_test.rs"
            completed_ticket: "DECY-092"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "IMPORTANT TRANSFORMATION: switch → match eliminates fall-through bugs and adds exhaustiveness checking. 100% safe transformation (0 unsafe blocks). Rust match provides no fall-through (each arm isolated, prevents common C bug where break is forgotten), exhaustiveness checking (compiler ensures all cases handled), expression-based (returns values, more functional), pattern matching power (ranges, guards, destructuring beyond C's integer-only), no break needed (cleaner syntax). Key differences: (1) C implicit fall-through (dangerous), Rust no fall-through (safer), (2) C break required, Rust not needed, (3) C default optional (can miss cases), Rust exhaustiveness enforced (_ arm required), (4) C statement-based, Rust expression-based (returns value), (5) C constant integers only, Rust rich patterns (ranges, guards, destructuring). Patterns: Basic switch → match expression, return → match value, multiple cases → |, no default → _ required, empty → {}, char → byte literal, nested → composition, range → ..=, enum → exhaustive, blocks → arm blocks, loop control → preserved, guards → if patterns, fall-through prevented, boolean → if-else, macros → constants. Test file demonstrates all patterns with 17 comprehensive tests covering complete switch transformation."

          - id: "STMT-SWITCH-PATTERNS"
            title: "Document switch/match statement patterns"
            status: "completed"
            priority: "high"
            version: "v0.51.0"
            examples:
              - c: "switch (x) { case 1: y=10; break; default: y=0; }"
                rust: "match x { 1 => { y = 10; }, _ => { y = 0; } }"
                note: "Basic switch with break → match arm (no break needed)"
              - c: "switch (x) { case 1: return 10; }"
                rust: "match x { 1 => { return 10; }, _ => {} }"
                note: "Return in case (no break needed), Rust adds wildcard"
              - c: "switch (status) { case 200: ... case 404: ... default: ... }"
                rust: "match status { 200 => { ... }, 404 => { ... }, _ => { ... } }"
                note: "Multiple distinct cases"
              - c: "switch (x + 1) { case 2: ... }"
                rust: "match x + 1 { 2 => { ... }, _ => {} }"
                note: "Expression as condition"
              - c: "switch (c) { case 'a': ... break; }"
                rust: "match c { b'a' => { ... }, _ => {} }"
                note: "Character cases (byte literal in Rust)"
              - c: "case 1:\ncase 2:\n  action();\n  break;"
                rust: "1 | 2 => { action(); }"
                note: "C fallthrough → Rust OR pattern"
              - c: "for (...) { switch (i) { case 0: continue; } }"
                rust: "for ... { match i { 0 => { continue; }, _ => {} } }"
                note: "Continue in switch within loop"
              - c: "switch (state) { case INIT: next=RUN; break; }"
                rust: "match state { INIT => { next = RUN; }, _ => {} }"
                note: "State machine pattern"
              - c: "switch (code) { case -1: ... case 0: ... }"
                rust: "match code { -1 => { ... }, 0 => { ... }, _ => {} }"
                note: "Negative case values"
            validation_reference: "K&R §3.4, ISO C99 §6.8.4.2"
            test_name: "test_switch_match_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Switch → Match: C switch is statement with fallthrough (error-prone), Rust match is expression with no fallthrough (safe). C requires break to prevent fallthrough, Rust never falls through. C allows non-exhaustive switch, Rust requires wildcard (_) for exhaustiveness. C intentional fallthrough (case 1: case 2:) → Rust OR pattern (1 | 2). Match is expression (can return value). No break statements in Rust (not needed). Empty cases become empty blocks. Return in case needs no break. Expression conditions supported. Character cases use byte literals. State machines natural with match. All transformations SAFE (0 unsafe blocks). Key advantage: prevents fallthrough bugs (major C pitfall)."

      - id: "5.3"
        name: "Iteration Statements (C99 §6.8.5)"
        tasks:
          - id: "STMT-WHILE"
            title: "Document while loops"
            status: "completed"
            version: "v0.83.0"
            examples:
              - c: "while (x < 10) { x++; }"
                rust: "while x < 10 { x += 1; }"
              - c: "int running = 1; while (running) { running = 0; }"
                rust: "let mut running = true; while running { running = false; }"
              - c: "while (x < 100) { if (x == 50) { break; } x++; }"
                rust: "while x < 100 { if x == 50 { break; } x += 1; }"
              - c: "while (x < 10) { x++; if (x % 2 == 0) { continue; } }"
                rust: "while x < 10 { x += 1; if x % 2 == 0 { continue; } }"
              - c: "while (1) { if (done) break; }"
                rust: "loop { if done { break; } }"
              - c: "while (x < 10 && y > 0) { x++; y--; }"
                rust: "while x < 10 && y > 0 { x += 1; y -= 1; }"
              - c: "while ((c = getchar()) != EOF) { putchar(c); }"
                rust: "loop { let c = getchar(); if c == EOF { break; } putchar(c); }"
              - c: "int n = 10; while (n > 0) { n--; }"
                rust: "let mut n = 10; while n > 0 { n -= 1; }"
              - c: "while (i < rows) { while (j < cols) { j++; } i++; }"
                rust: "while i < rows { while j < cols { j += 1; } i += 1; }"
              - c: "Node* current = head; while (current) { current = current->next; }"
                rust: "let mut current = head; while current.is_some() { current = current.next; }"
              - c: "while (is_busy());"
                rust: "while is_busy() {}"
              - c: "while (!done) { work(); }"
                rust: "while !done { work(); }"
              - c: "int i = 0; while (str[i] != '\\0') { i++; }"
                rust: "let mut i = 0; while str[i] != '\\0' { i += 1; }"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.1"
            test_name: "test_while_loop"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - while loops transform directly with critical differences: no parentheses, bool-only conditions, assignment-in-condition → loop+break"

          - id: "STMT-WHILE-PATTERNS"
            title: "Document while loop patterns"
            status: "completed"
            priority: "high"
            version: "v0.52.0"
            examples:
              - c: "while (x < 10) { x++; }"
                rust: "while x < 10 { x += 1; }"
                note: "Basic while loop (pre-test, may execute 0 times)"
              - c: "while (x < 5 && y > 0) { ... }"
                rust: "while x < 5 && y > 0 { ... }"
                note: "Complex condition with logical operators"
              - c: "while (1) { if (done) break; }"
                rust: "while true { if done { break; } }"
                note: "Infinite loop with break (C int → Rust bool)"
              - c: "while (i < len) { if (skip) continue; process(i); i++; }"
                rust: "while i < len { if skip { continue; } process(i); i += 1; }"
                note: "Continue skips to next iteration"
              - c: "while (has_next()) { process(); }"
                rust: "while has_next() { process(); }"
                note: "Function call in condition"
              - c: "while (i < len) { sum += arr[i]; i++; }"
                rust: "while i < len { sum += arr[i]; i += 1; }"
                note: "Array processing pattern"
              - c: "while (arr[i] != 0) { process(arr[i]); i++; }"
                rust: "while arr[i] != 0 { process(arr[i]); i += 1; }"
                note: "Sentinel value pattern (loop until special value)"
              - c: "int found = 0; while (!found && i < n) { ... }"
                rust: "let mut found = false; while !found && i < n { ... }"
                note: "Boolean flag pattern (C int → Rust bool)"
              - c: "while (i < 10) { while (j < 10) { ... } }"
                rust: "while i < 10 { while j < 10 { ... } }"
                note: "Nested while loops"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.1"
            test_name: "test_while_loop_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "While loops: Pre-test loop (condition checked BEFORE body, may execute 0 times). C and Rust have similar syntax. Key difference: C allows int as bool (0=false, non-zero=true), Rust requires explicit bool. C while (1) → Rust while true or loop. C while (ptr) → Rust while ptr.is_some(). Both support break/continue. Common patterns: countdown, array processing, sentinel values, boolean flags, nested loops, function call conditions. All transformations SAFE (0 unsafe blocks). Type-safe boolean conditions prevent common C bugs."

          - id: "STMT-DO-WHILE"
            title: "Document do-while loops"
            status: "completed"
            priority: "high"
            version: "v0.43.0"
            examples:
              - c: "do { x = x + 1; } while (x < 5);"
                rust: "loop { x = x + 1; if !(x < 5) { break; } }"
                note: "Condition evaluated AFTER first iteration"
              - c: "do { process(); } while (should_continue());"
                rust: "loop { process(); if !should_continue() { break; } }"
                note: "Guaranteed at least one iteration"
              - c: "int x = 10; do { x++; } while (x < 5);"
                rust: "let mut x = 10; loop { x += 1; if !(x < 5) { break; } }"
                note: "Body executes once even when condition false"
            validation_reference: "K&R §3.6, ISO C99 §6.8.5.2"
            test_name: "test_do_while_loops"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Do-while loops → loop with conditional break at end. Guaranteed at least one iteration (key difference from while). Condition evaluated AFTER body. break/continue work correctly. Rust has NO native do-while (use loop + if + break). All transformations SAFE (0 unsafe blocks)."

          - id: "STMT-FOR"
            title: "Document for loops"
            status: "completed"
            priority: "high"
            version: "v0.58.0"
            examples:
              - c: "for (int i = 0; i < 10; i++) { process(i); }"
                rust: "for i in 0..10 { process(i); }"
                note: "Simple counting: C three-part syntax → Rust range (more concise)"
              - c: "for (int i = 0; i <= 10; i++) { process(i); }"
                rust: "for i in 0..=10 { process(i); }"
                note: "Inclusive range: C <= → Rust ..= (explicit, prevents off-by-one errors)"
              - c: "for (int i = 0; i < 20; i += 2) { process(i); }"
                rust: "for i in (0..20).step_by(2) { process(i); }"
                note: "Custom step: C += 2 → Rust .step_by(2) method"
              - c: "for (int i = 10; i > 0; i--) { process(i); }"
                rust: "for i in (1..=10).rev() { process(i); }"
                note: "Reverse iteration: C decrement → Rust .rev() method"
              - c: "for (int i = 0; i < arr_len; i++) { sum += arr[i]; }"
                rust: "for &item in arr.iter() { sum += item; }"
                note: "Array iteration: C manual index → Rust iterator (safer, no bounds checking)"
              - c: "for (int i = 0; i < arr_len; i++) { printf(\"%d: %d\", i, arr[i]); }"
                rust: "for (i, &item) in arr.iter().enumerate() { println!(\"{}: {}\", i, item); }"
                note: "Index + value: C manual → Rust .enumerate() (provides both)"
              - c: "for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { matrix[i][j] = i * m + j; } }"
                rust: "for i in 0..n { for j in 0..m { matrix[i][j] = i * m + j; } }"
                note: "Nested loops: structure preserved, Rust range syntax cleaner"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] == target) break; }"
                rust: "for i in 0..n { if arr[i] == target { break; } }"
                note: "Loop with break: early exit works same in both"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] < 0) continue; sum += arr[i]; }"
                rust: "for i in 0..n { if arr[i] < 0 { continue; } sum += arr[i]; }"
                note: "Loop with continue: filter pattern works same in both"
              - c: "for (;;) { process(); if (done) break; }"
                rust: "loop { process(); if done { break; } }"
                note: "Infinite loop: C for(;;) → Rust loop keyword (more idiomatic)"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.3"
            test_name: "test_for_loop_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "For loops: C uses three-part syntax (init; condition; increment), Rust uses iterator-based range syntax (more concise and safer). Rust ranges: 0..n (exclusive), 0..=n (inclusive) - explicit syntax prevents off-by-one errors. Custom step: C uses += in increment, Rust uses .step_by() method. Reverse: C uses decrement, Rust uses .rev() method. Array iteration: C requires manual indexing (error-prone), Rust iterators guarantee safe access (no bounds checking needed). Enumerate: C needs separate index variable, Rust .enumerate() provides both index and value. Nested loops: both languages support, Rust syntax cleaner. Break/continue: work identically in both. Infinite loop: C for(;;) → Rust loop (more idiomatic). Iterator patterns: Rust can use functional style (.sum(), .filter(), .map()) instead of explicit loops - more expressive. All transformations type-safe (0 unsafe blocks). Rust for loops prevent common C bugs: off-by-one errors, out-of-bounds access, uninitialized loop variables."

          - id: "STMT-FOR-DECL"
            title: "Document for loop variable declarations"
            status: "completed"
            priority: "high"
            version: "v0.38.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
                note: "C99 allows declarations in for loop (NOT in C89/K&R)"
              - c: "for (int i = 0; i < 20; i += 2) { ... }"
                rust: "for i in (0..20).step_by(2) { ... }"
                note: "Custom increment with step_by"
              - c: "for (int i = 10; i > 0; i--) { ... }"
                rust: "for i in (1..=10).rev() { ... }"
                note: "Reverse iteration"
              - c: "for (int i = 0; i < arr_len; i++) { arr[i] = ...; }"
                rust: "for (i, val) in arr.iter_mut().enumerate() { ... }"
                note: "Enumerate for index + value"
            validation_reference: "ISO C99 §6.8.5.3 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_for_loop_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 added variable declarations in for loops (NOT in C89/K&R). Both C99 and Rust scope variable to loop body. Rust range syntax more concise. Rust iterators prevent off-by-one errors. step_by for custom increment, rev() for reverse, enumerate() for index+value."

      - id: "5.4"
        name: "Jump Statements (C99 §6.8.6)"
        tasks:
          - id: "STMT-RETURN"
            title: "Document return statements"
            status: "completed"
            priority: "high"
            version: "v0.55.0"
            examples:
              - c: "int get_value() { return 42; }"
                rust: "fn get_value() -> i32 { 42 }"
                note: "Idiomatic Rust: implicit return (no semicolon, no return keyword)"
              - c: "int add(int a, int b) { return a + b; }"
                rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
                note: "Expression return without keyword (more concise)"
              - c: "void process() { do_work(); return; }"
                rust: "fn process() { do_work(); }"
                note: "Unit return: C void → Rust (), return omitted"
              - c: "int divide(int a, int b) { if (b == 0) return -1; return a / b; }"
                rust: "fn divide(a: i32, b: i32) -> i32 { if b == 0 { return -1; } a / b }"
                note: "Guard clause: explicit return for early exit, implicit for success"
              - c: "int classify(int x) { if (x < 0) return -1; if (x == 0) return 0; return 1; }"
                rust: "fn classify(x: i32) -> i32 { if x < 0 { return -1; } if x == 0 { return 0; } 1 }"
                note: "Multiple guards: explicit for early exits, implicit for final case"
              - c: "int get_sign(int x) { if (x >= 0) { return 1; } else { return -1; } }"
                rust: "fn get_sign(x: i32) -> i32 { if x >= 0 { 1 } else { -1 } }"
                note: "If as expression: no return keywords needed (idiomatic)"
              - c: "int find(int arr[], int len, int x) { for (...) { if (arr[i] == x) return i; } return -1; }"
                rust: "fn find(arr: &[i32], x: i32) -> i32 { for (i, &val) in arr.iter().enumerate() { if val == x { return i as i32; } } -1 }"
                note: "Loop search: explicit return in loop, implicit for not-found"
              - c: "int wrapper(int x) { return process(x); }"
                rust: "fn wrapper(x: i32) -> i32 { process(x) }"
                note: "Function call result: implicit return (no keyword)"
              - c: "int max(int a, int b) { return (a > b) ? a : b; }"
                rust: "fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }"
                note: "Ternary → if expression: no return keyword needed"
              - c: "int handle_state(int s) { switch (s) { case 0: return 10; case 1: return 20; default: return -1; } }"
                rust: "fn handle_state(s: i32) -> i32 { match s { 0 => 10, 1 => 20, _ => -1, } }"
                note: "Match as expression: no return keywords in any arm"
            validation_reference: "K&R §4.1, ISO C99 §6.8.6.4"
            test_name: "test_return_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Return statements: Critical safety difference - C missing return is UNDEFINED BEHAVIOR, Rust enforces proper returns at compile time. Rust prefers implicit returns (expression without semicolon) for final values, explicit 'return' keyword for early exits. C requires 'return' keyword always. Idiomatic Rust: use if/match as expressions to avoid explicit returns. If-else with returns in both branches → if expression. Multiple early returns → guard clauses with explicit return, final case implicit. Loop search → explicit return when found, implicit for fall-through. Function call result → implicit return. All transformations type-safe (0 unsafe blocks). Key patterns: guard clauses, if expressions, match expressions, loop early exit, void/unit functions."

          - id: "STMT-BREAK"
            title: "Document break statements"
            status: "completed"
            priority: "high"
            version: "v0.56.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { if (condition) break; }"
                rust: "for i in 0..n { if condition { break; } }"
                note: "Simple loop break: identical syntax in both languages"
              - c: "while (1) { process(); if (done) break; }"
                rust: "loop { process(); if done { break; } }"
                note: "Infinite loop with break: C while(1) → Rust loop"
              - c: "switch (x) { case 1: handle(); break; case 2: process(); break; }"
                rust: "match x { 1 => handle(), 2 => process(), _ => {} }"
                note: "C switch REQUIRES break, Rust match doesn't (no fallthrough)"
              - c: "int found = 0; for (...) { for (...) { if (match) { found = 1; break; } } if (found) break; }"
                rust: "'outer: for ... { for ... { if match { break 'outer; } } }"
                note: "Nested loops: C needs flag variable, Rust has labeled break"
              - c: "for (int i = 0; i < len; i++) { if (arr[i] == target) { result = i; break; } }"
                rust: "for i in 0..len { if arr[i] == target { result = i; break; } }"
                note: "Search pattern: break when found (same in both)"
              - c: "while (has_data()) { int val = read(); if (val == ERROR) break; process(val); }"
                rust: "while has_data() { let val = read(); if val == ERROR { break; } process(val); }"
                note: "Error detection: early exit on error condition"
              - c: "int count = 0; while (1) { process(); count++; if (count >= MAX) break; }"
                rust: "let mut count = 0; loop { process(); count += 1; if count >= MAX { break; } }"
                note: "Limit check: break when counter reaches limit"
              - c: "while (running) { if (check_early()) break; step1(); if (should_stop()) break; step2(); }"
                rust: "while running { if check_early() { break; } step1(); if should_stop() { break; } step2(); }"
                note: "Multiple breaks: different exit conditions at different points"
              - c: "int result = -1; for (int i = 0; i < n; i++) { if (arr[i] > 0) { result = arr[i]; break; } }"
                rust: "let result = 'search: loop { for i in 0..n { if arr[i] > 0 { break 'search arr[i]; } } break -1; };"
                note: "Break with value (Rust only): C needs variable, Rust can break with value"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] == x) { arr[i] = NEW; found_index = i; break; } }"
                rust: "for i in 0..n { if arr[i] == x { arr[i] = NEW; found_index = i; break; } }"
                note: "Modify then break: multiple statements before break"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.3"
            test_name: "test_break_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Break statements: Used to exit loops and switch statements. C and Rust have similar break syntax for simple loops, but key differences exist. C switch REQUIRES break after each case (prevents fallthrough bugs), Rust match doesn't need break (no fallthrough possible). Nested loops: C requires flag variable + two breaks, Rust has labeled break ('outer:) for direct outer loop exit - more concise and clear. Break with value: Rust only feature, can break with value from loop expression (more functional style). C needs variable to store result before break. Common patterns: search and exit, error detection, limit checks, nested loop exit. All transformations type-safe (0 unsafe blocks). Rust labeled break eliminates need for flag variables in nested loops."

          - id: "STMT-CONTINUE"
            title: "Document continue statements"
            status: "completed"
            priority: "high"
            version: "v0.57.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { if (arr[i] < 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] < 0 { continue; } process(arr[i]); }"
                note: "Simple continue: identical syntax, skip to next iteration"
              - c: "for (i = 0; i < n; i++) { if (arr[i] == SKIP) continue; if (arr[i] == 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] == SKIP { continue; } if arr[i] == 0 { continue; } process(arr[i]); }"
                note: "Filter pattern: multiple continues for sequential filtering"
              - c: "while (has_data()) { int val = get_next(); if (is_invalid(val)) continue; process(val); }"
                rust: "while has_data() { let val = get_next(); if is_invalid(val) { continue; } process(val); }"
                note: "While loop continue: validation pattern, skip invalid data"
              - c: "while (1) { int val = read(); if (val == 0) continue; if (val < 0) break; process(val); }"
                rust: "loop { let val = read(); if val == 0 { continue; } if val < 0 { break; } process(val); }"
                note: "Infinite loop: C while(1) → Rust loop, continue and break together"
              - c: "for (i = 0; i < n; i++) { if (arr[i] < MIN || arr[i] > MAX) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] < MIN || arr[i] > MAX { continue; } process(arr[i]); }"
                note: "Complex condition: range check with logical operators"
              - c: "for (i = 0; i < n; i++) { count++; if (arr[i] == 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { count += 1; if arr[i] == 0 { continue; } process(arr[i]); }"
                note: "Partial processing: continue after some operations, not always at start"
              - c: "for (i = 0; i < n; i++) { for (j = 0; j < m; j++) { if (matrix[i][j] == 0) continue; process(matrix[i][j]); } }"
                rust: "for i in 0..n { for j in 0..m { if matrix[i][j] == 0 { continue; } process(matrix[i][j]); } }"
                note: "Nested loops: continue only affects innermost loop (same in both)"
              - c: "int skip = 0; for (i = 0; i < n; i++) { for (j = 0; j < m; j++) { if (condition) { skip = 1; break; } } if (skip) { skip = 0; continue; } process(i); }"
                rust: "'outer: for i in 0..n { for j in 0..m { if condition { continue 'outer; } } process(i); }"
                note: "Labeled continue (Rust): C needs flag + break + continue, Rust skips outer iteration directly"
              - c: "for (i = 0; i < n; i++) { if (!is_valid(arr[i])) continue; if (arr[i] == NULL) continue; process(arr[i]); }"
                rust: "for i in 0..n { if !is_valid(arr[i]) { continue; } if arr[i].is_none() { continue; } process(arr[i]); }"
                note: "Validation pattern: skip items that fail validation checks"
              - c: "for (i = 0; i < len; i++) { char c = str[i]; if (c == ' ') continue; if (c == '\\t') continue; process(c); }"
                rust: "for i in 0..len { let c = str[i]; if c == b' ' { continue; } if c == b'\\t' { continue; } process(c); }"
                note: "Character processing: skip whitespace characters"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.2"
            test_name: "test_continue_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Continue statements: Skip to next iteration of loop. C and Rust have identical syntax for simple cases. Common in filter/skip patterns, validation, guard clauses. Both skip to next iteration of innermost loop only. Labeled continue (Rust only): skip outer loop iteration from inner loop directly - more concise than C flag pattern. C requires flag variable + break + outer continue check (verbose). Rust 'outer: continue 'outer eliminates flag variables. For loop: C jumps to increment then condition, Rust advances iterator. While loop: both jump back to condition check. Iterator patterns: Rust can use .filter() instead of explicit continue (more functional). All transformations type-safe (0 unsafe blocks). Continue complementary to break: break exits loop, continue skips to next iteration."

          - id: "STMT-GOTO"
            title: "Document goto → eliminate or loop/match"
            status: "completed"
            priority: "low"
            version: "v0.22.0"
            examples:
              - c: "if (err) goto cleanup; ... cleanup: free(p);"
                rust: "let p = Box::new(0); // RAII cleanup via Drop"
              - c: "for (...) { if (found) goto done; } done: ..."
                rust: "'outer: for ... { break 'outer; }"
              - c: "state1: ... goto state2; state2: ..."
                rust: "loop { match state { State1 => ..., State2 => ... } }"
            validation_reference: "K&R §3.8, ISO C99 §6.8.6.1"
            test_name: "test_goto_documentation"
            sprint: 4
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - goto eliminated via Result+RAII (error handling), labeled break (nested loops), loop+match (state machines), loop+continue (retry logic), if restructuring (forward jumps). Rust has NO goto statement."

  - id: 6
    name: "Functions (C99 §6.9.1)"
    description: "Function declarations, definitions, parameters"
    tasks:
      - id: "FUNC-DECL"
        title: "Document function declarations"
        status: "completed"
        version: "v0.64.0"
        examples:
          - c: "int add(int a, int b) { return a + b; }"
            rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
            note: "Simple function: implicit return (no semicolon)"
          - c: "void print(int x) { printf(\"%d\", x); }"
            rust: "fn print(x: i32) { println!(\"{}\", x); }"
            note: "Void function: omit return type (defaults to unit ())"
          - c: "int get_value(void) { return 42; }"
            rust: "fn get_value() -> i32 { 42 }"
            note: "No parameters: empty () (not void)"
          - c: "int divide(int a, int b) { if (b == 0) return -1; return a / b; }"
            rust: "fn divide(a: i32, b: i32) -> i32 { if b == 0 { return -1; } a / b }"
            note: "Early return: explicit return keyword, final value implicit"
          - c: "int is_even(int x) { return x % 2 == 0; }"
            rust: "fn is_even(x: i32) -> bool { x % 2 == 0 }"
            note: "Boolean: return bool (not int), simplify to direct expression"
          - c: "float avg(float a, float b) { return (a + b) / 2.0f; }"
            rust: "fn avg(a: f32, b: f32) -> f32 { (a + b) / 2.0 }"
            note: "Floating point: float → f32, double → f64"
          - c: "int fib(int n) { if (n <= 1) return n; return fib(n-1) + fib(n-2); }"
            rust: "fn fib(n: i32) -> i32 { if n <= 1 { return n; } fib(n-1) + fib(n-2) }"
            note: "Recursion: same pattern, works identically"
          - c: "int sum(int arr[], int n) { int s = 0; for (int i = 0; i < n; i++) s += arr[i]; return s; }"
            rust: "fn sum(arr: &[i32]) -> i32 { let mut s = 0; for &item in arr { s += item; } s }"
            note: "Array parameter: pointer+length → slice (&[T]), no separate length needed"
          - c: "static int helper(int x) { return x * 2; }"
            rust: "fn helper(x: i32) -> i32 { x * 2 }"
            note: "Static function: module-private by default (no pub), static keyword not needed"
        validation_reference: "K&R §4.1, ISO C99 §6.9.1"
        test_name: "test_function_declaration"
        test_file: "function_declaration_documentation_test.rs"
        completed_date: "2025-10-17"
        tests_added: 17
        coverage: "100%"
        unsafe_blocks: 0
        note: "COMPREHENSIVE DOCUMENTATION: Function declarations and definitions with 100% coverage. Critical differences: (1) Rust has no separate declarations (definition = declaration, modules replace headers), (2) void → omit return type (defaults to unit ()), (3) No parameters: empty () not void, (4) Implicit returns idiomatic (expression without semicolon), explicit return for early exits, (5) No forward declarations needed (order independent within module), (6) Array parameters: pointer+length → slices (&[T]) with built-in length. Same syntax for calls. Type-safe parameters (no implicit conversions). Test file demonstrates: simple returns, void functions, no parameters, multiple parameters, early returns, booleans, floats/doubles, mixed types, function composition, complex bodies, recursion, multiple return paths, array parameters, static functions. All transformations safe (0 unsafe blocks). Rust more concise and type-safe."

      - id: "FUNC-DEF"
        title: "Document function definitions"
        status: "completed"
        version: "v0.64.0"
        note: "Combined with FUNC-DECL (v0.64.0) - Rust has no distinction between declaration and definition"

      - id: "FUNC-VOID-PARAMS"
        title: "Document void parameter lists"
        status: "completed"
        version: "v0.64.0"
        note: "Combined with FUNC-DECL (v0.64.0) - covered in comprehensive function documentation"

      - id: "FUNC-VARIADIC"
        title: "Document variadic functions"
        status: "completed"
        priority: "low"
        version: "v0.21.0"
        examples:
          - c: "int sum(int count, ...);"
            rust: "fn sum(values: &[i32]) -> i32 { values.iter().sum() }"
          - c: "int printf(const char* fmt, ...);"
            rust: "println!(...) or custom macro_rules!"
        validation_reference: "K&R §7.3, ISO C99 §6.9.1, §7.15"
        test_name: "test_variadic_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - variadic functions transform to slices (homogeneous), macros (format strings), or tuples (fixed arity). C's runtime variadic replaced with compile-time type safety."

      - id: "FUNC-INLINE"
        title: "Document inline functions"
        status: "completed"
        priority: "medium"
        version: "v0.36.0"
        examples:
          - c: "inline int add(int a, int b) { return a + b; }"
            rust: "#[inline] fn add(a: i32, b: i32) -> i32 { a + b }"
            note: "C99 inline keyword → Rust #[inline] attribute"
          - c: "static inline int max(int a, int b) { return (a > b) ? a : b; }"
            rust: "#[inline] fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }"
            note: "static inline → #[inline] with appropriate visibility"
          - c: "inline __attribute__((always_inline)) int double_value(int x) { return x * 2; }"
            rust: "#[inline(always)] fn double_value(x: i32) -> i32 { x * 2 }"
            note: "GCC always_inline → #[inline(always)]"
          - c: "__attribute__((noinline)) int complex_calculation(int x) { return x * x + x * 2 + 1; }"
            rust: "#[inline(never)] fn complex_calculation(x: i32) -> i32 { x * x + x * 2 + 1 }"
            note: "GCC noinline → #[inline(never)]"
        validation_reference: "ISO C99 §6.7.4 (new in C99), NOT in K&R (pre-C99)"
        test_name: "test_inline_functions"
        sprint: 5
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "C99 inline functions → Rust #[inline] attribute. Both are optimization hints (not guarantees). Rust compiler excellent at auto-inlining without hints. const fn provides compile-time evaluation (more powerful). Generic functions implicitly inline-eligible. All transformations SAFE (0 unsafe blocks)."

  - id: 7
    name: "Standard Library (C99 §7)"
    description: "stdio, stdlib, string, etc."
    sections:
      - id: "7.1"
        name: "stdio.h (C99 §7.19)"
        tasks:
          - id: "STDLIB-PRINTF"
            title: "Document printf → println!"
            status: "completed"
            version: "v0.82.0"
            examples:
              - c: "printf(\"Hello, World!\\n\");"
                rust: "println!(\"Hello, World!\");"
              - c: "printf(\"Hello\");"
                rust: "print!(\"Hello\");"
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
              - c: "printf(\"Hello, %s!\\n\", name);"
                rust: "println!(\"Hello, {}!\", name);"
              - c: "printf(\"Pi: %f\\n\", pi);"
                rust: "println!(\"Pi: {}\", pi);"
              - c: "printf(\"Char: %c\\n\", ch);"
                rust: "println!(\"Char: {}\", ch);"
              - c: "printf(\"Name: %s, Age: %d, Score: %f\\n\", name, age, score);"
                rust: "println!(\"Name: {}, Age: {}, Score: {}\", name, age, score);"
              - c: "printf(\"%5d\\n\", x);"
                rust: "println!(\"{:5}\", x);"
              - c: "printf(\"%.2f\\n\", pi);"
                rust: "println!(\"{:.2}\", pi);"
              - c: "printf(\"%05d\\n\", x);"
                rust: "println!(\"{:05}\", x);"
              - c: "printf(\"Hex: %x\\n\", value);"
                rust: "println!(\"Hex: {:x}\", value);"
              - c: "printf(\"Hex: %X\\n\", value);"
                rust: "println!(\"Hex: {:X}\", value);"
              - c: "printf(\"Pointer: %p\\n\", ptr);"
                rust: "println!(\"Pointer: {:p}\", ptr);"
              - c: "if (x > 0) { printf(\"Positive: %d\\n\", x); }"
                rust: "if x > 0 { println!(\"Positive: {}\", x); }"
              - c: "for (int i = 0; i < n; i++) { printf(\"Index: %d\\n\", i); }"
                rust: "for i in 0..n { println!(\"Index: {}\", i); }"
              - c: "printf(\"Starting program...\\n\");"
                rust: "println!(\"Starting program...\");"
            validation_reference: "K&R §7.2, ISO C99 §7.19.6.1"
            test_name: "test_printf_to_println"
            sprint: 9
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - printf transforms to println!/print!, providing type safety and buffer overflow protection"

          - id: "STDLIB-SCANF"
            title: "Document scanf → read from stdin"
            status: "completed"
            priority: "low"
            version: "v0.19.0"
            examples:
              - c: "scanf(\"%d\", &x);"
                rust: "io::stdin().read_line(&mut buffer).unwrap(); let x: i32 = buffer.trim().parse().unwrap();"
            validation_reference: "K&R §7.4, ISO C99 §7.19.6.2"
            test_name: "test_scanf_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - scanf transforms to stdin().read_line() + parse(), eliminating buffer overflow risks"

      - id: "7.2"
        name: "stdlib.h (C99 §7.20)"
        tasks:
          - id: "STDLIB-MALLOC"
            title: "Document malloc → Box/Vec"
            status: "completed"
            version: "v0.81.0"
            examples:
              - c: "int* p = malloc(sizeof(int)); *p = 42; free(p);"
                rust: "let mut p = Box::new(0i32); *p = 42;"
                note: "Single value → Box (automatic Drop)"
              - c: "int* arr = malloc(n * sizeof(int)); free(arr);"
                rust: "let mut arr = Vec::with_capacity(n);"
                note: "Array → Vec::with_capacity (uninitialized)"
              - c: "struct Point* p = malloc(sizeof(struct Point)); free(p);"
                rust: "let p = Box::new(Point { x: 0, y: 0 });"
                note: "Struct allocation"
              - c: "int* p = malloc(sizeof(int)); if (p == NULL) return -1;"
                rust: "let p = Box::new(0i32);"
                note: "NULL check eliminated (panics on OOM)"
              - c: "int* p = (int*)malloc(sizeof(int)); free(p);"
                rust: "let p = Box::new(0i32);"
                note: "Cast eliminated (type safe)"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.3"
            test_name: "test_memory_allocation_documentation"
            completed_ticket: "DECY-044"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "malloc → Box/Vec transformation: Single value → Box::new, array → Vec::with_capacity. Critical safety: automatic Drop (no manual free), prevents double free/use after free/memory leaks via ownership. NULL check eliminated (panic on OOM, or use try_reserve for Result). Type safety (no void* casting). Scope-based lifetime (RAII). Combined with calloc/realloc/free in comprehensive test."

          - id: "STDLIB-FREE"
            title: "Document free → automatic Drop"
            status: "completed"
            version: "v0.6.0"
            examples:
              - c: "free(p);"
                rust: "// Automatic when Box/Vec goes out of scope"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.2"
            test_name: "test_free_elimination"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-CALLOC"
            title: "Document calloc → vec![0; n]"
            status: "completed"
            version: "v0.81.0"
            priority: "high"
            examples:
              - c: "int* arr = calloc(10, sizeof(int)); free(arr);"
                rust: "let arr = vec![0i32; 10];"
                note: "Zero-initialized array (automatic Drop)"
              - c: "double* values = calloc(n, sizeof(double)); free(values);"
                rust: "let values = vec![0.0f64; n];"
                note: "Runtime size, zero-initialized"
              - c: "struct Point* arr = calloc(10, sizeof(struct Point)); free(arr);"
                rust: "let arr = vec![Point::default(); 10];"
                note: "Struct array (requires Default trait)"
            validation_reference: "ISO C99 §7.20.3.1"
            test_name: "test_memory_allocation_documentation"
            sprint: 1
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "calloc → vec![0; n] transformation: Zero-initialized array allocation. Simpler than C (no need for count * size). Automatic initialization vs C's explicit zeroing. Automatic Drop (no manual free). Type safe. Combined with malloc/realloc/free in comprehensive test."

          - id: "STDLIB-REALLOC"
            title: "Document realloc → Vec methods"
            status: "completed"
            version: "v0.81.0"
            priority: "medium"
            examples:
              - c: "arr = realloc(arr, 20 * sizeof(int));"
                rust: "arr.resize(20, 0);"
                note: "Grow array (new elements initialized)"
              - c: "arr = realloc(arr, 50 * sizeof(int));"
                rust: "arr.resize(50, 0);"
                note: "Shrink array (elements truncated)"
              - c: "arr = realloc(arr, 0);"
                rust: "arr.clear();"
                note: "Free equivalent (size 0)"
              - c: "arr = realloc(NULL, size);"
                rust: "let arr = vec![0i32; count];"
                note: "Malloc equivalent (NULL pointer)"
            validation_reference: "ISO C99 §7.20.3.4"
            test_name: "test_memory_allocation_documentation"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "realloc → vec.resize() transformation: Grows or shrinks Vec. Simpler semantics than C (no NULL return on failure, old pointer doesn't become invalid). Edge cases: realloc(p, 0) → clear(), realloc(NULL, size) → new Vec. Type safe. Combined with malloc/calloc/free in comprehensive test."

      - id: "7.3"
        name: "string.h (C99 §7.21)"
        tasks:
          - id: "STDLIB-STRLEN"
            title: "Document strlen → .len()"
            status: "completed"
            version: "v0.13.0"
            priority: "medium"
            examples:
              - c: "size_t len = strlen(s);"
                rust: "let len = s.len();"
            validation_reference: "K&R §B3, ISO C99 §7.21.6.3"
            test_name: "test_strlen_to_len"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-STRCPY"
            title: "Document strcpy → String/clone"
            status: "completed"
            version: "v0.14.0"
            priority: "medium"
            examples:
              - c: "strcpy(dest, src);"
                rust: "dest = src.to_string();"
            validation_reference: "K&R §B3, ISO C99 §7.21.3.1"
            test_name: "test_strcpy_transformation"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

  - id: 8
    name: "Preprocessor (C99 §6.10)"
    description: "#define, #include, #ifdef, etc."
    tasks:
      - id: "PREP-INCLUDE"
        title: "Document #include → use statements"
        status: "completed"
        priority: "high"
        version: "v0.17.0"
        examples:
          - c: "#include <stdio.h>"
            rust: "// Built-in, no import needed"
          - c: "#include \"myheader.h\""
            rust: "mod mymodule;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.2"
        test_name: "test_include_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 10
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - system headers map to built-ins, local headers become modules"

      - id: "PREP-DEFINE-CONST"
        title: "Document #define constants → const"
        status: "completed"
        priority: "high"
        version: "v0.16.0"
        examples:
          - c: "#define MAX 100"
            rust: "const MAX: i32 = 100;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_const"
        sprint: 2
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0

      - id: "PREP-DEFINE-MACRO"
        title: "Document #define macros → functions or macros"
        status: "completed"
        priority: "medium"
        version: "v0.18.0"
        examples:
          - c: "#define SQR(x) ((x) * (x))"
            rust: "fn sqr(x: i32) -> i32 { x * x }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_macro_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - expression macros become functions, statement macros become macro_rules! or use std library"

      - id: "PREP-IFDEF"
        title: "Document #ifdef → cfg"
        status: "completed"
        priority: "low"
        version: "v0.23.0"
        examples:
          - c: "#ifdef DEBUG ... #endif"
            rust: "#[cfg(debug_assertions)] { ... }"
          - c: "#ifdef __linux__ ... #endif"
            rust: "#[cfg(target_os = \"linux\")] { ... }"
          - c: "#if defined(X) && !defined(Y) ... #endif"
            rust: "#[cfg(all(feature = \"x\", not(feature = \"y\")))] { ... }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.1"
        test_name: "test_ifdef_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 13
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - #ifdef/#ifndef become cfg attributes. Rust cfg is type-aware (evaluated during compilation) unlike C's text-based preprocessor. Supports debug_assertions, target_os, target_arch, features (Cargo.toml), test, and complex combinators (all, any, not)."

completed_features:
  - title: "Basic types (int, float, char)"
    version: "v0.1.0"
    tasks: ["TYPE-BASIC-INT", "TYPE-BASIC-FLOAT"]
    tests: 5
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Integer and float literals"
    version: "v0.1.0"
    tasks: ["LEX-CONST-INT", "LEX-CONST-FLOAT"]
    tests: 6
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Basic arithmetic and comparison operators"
    version: "v0.1.0"
    tasks: ["EXPR-ARITH-BINARY", "EXPR-CMP-RELATIONAL", "EXPR-CMP-EQUALITY"]
    tests: 8
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Function declarations and definitions"
    version: "v0.1.0"
    tasks: ["FUNC-DECL", "FUNC-DEF", "FUNC-VOID-PARAMS"]
    tests: 4
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Control flow (if, while, for)"
    version: "v0.2.0"
    tasks: ["STMT-IF", "STMT-WHILE", "STMT-FOR"]
    tests: 12
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Pointers and malloc/free → Box"
    version: "v0.3.0"
    tasks: ["TYPE-PTR-MALLOC", "STDLIB-MALLOC", "STDLIB-FREE"]
    tests: 9
    methodology: "EXTREME TDD + Ownership Inference"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

  - title: "sizeof operator"
    version: "v0.3.0"
    tasks: ["EXPR-UNARY-SIZEOF"]
    tests: 9
    methodology: "EXTREME TDD + Property Testing"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

high_priority_next_tasks:
  description: "Next 20 tasks to implement"
  tasks:
    - id: "TYPE-PTR-NULL"
      title: "NULL → Option<T>"
      priority: 1
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Eliminates null pointer dereferences"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STDLIB-CALLOC"
      title: "calloc → Vec::with_capacity"
      priority: 2
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Pattern-based allocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STMT-SWITCH"
      title: "switch → match"
      priority: 3
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 15

    - id: "TYPE-ARRAY-VLA"
      title: "Variable-length arrays → Vec"
      priority: 4
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Stack overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-ARITH-PTR"
      title: "Pointer arithmetic → slice indexing"
      priority: 5
      status: "🔶 BLOCKED - RED PHASE COMPLETE (Sprint 3)"
      phase: "RED"
      ownership_inference_impact: "CRITICAL"
      unsafe_reduction: "Eliminates pointer arithmetic"
      red_phase_date: "2025-10-15"
      tests_added: 9
      blocked_reason: "Needs ownership inference infrastructure"

    - id: "STDLIB-REALLOC"
      title: "realloc → Vec::resize"
      priority: 6
      status: "✅ COMPLETED (Sprint 2)"
      ownership_inference_impact: "MEDIUM"
      unsafe_reduction: "Pattern-based reallocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-POSTFIX-INCR"
      title: "Post-increment/decrement"
      priority: 7
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "EXPR-UNARY-INCR"
      title: "Pre-increment/decrement"
      priority: 8
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "EXPR-ASSIGN-COMPOUND"
      title: "Compound assignment (+=, *=, etc.)"
      priority: 9
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "PREP-DEFINE-CONST"
      title: "#define constants → const"
      priority: 10
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "PREP-INCLUDE"
      title: "#include → use statements"
      priority: 11
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "None (module system)"
      completed_date: "2025-10-15"
      tests_added: 10

    - id: "PREP-DEFINE-MACRO"
      title: "#define macros → functions or macros"
      priority: 12
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type safety from functions"
      completed_date: "2025-10-15"
      tests_added: 16

    - id: "STDLIB-STRLEN"
      title: "strlen → .len()"
      priority: 13
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "STDLIB-STRCPY"
      title: "strcpy → String/clone"
      priority: 14
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "TYPE-STRUCT-NESTED"
      title: "Nested structs"
      priority: 15
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "STDLIB-SCANF"
      title: "scanf → stdin reading"
      priority: 16
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type-safe parsing + buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 14

    - id: "FUNC-VARIADIC"
      title: "Variadic functions"
      priority: 17
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Type safety from macros or Vec (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "STMT-GOTO"
      title: "goto elimination"
      priority: 18
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Structured control flow (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "TYPE-QUAL-VOLATILE"
      title: "volatile → atomic"
      priority: 19
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Atomic types are SAFE (0 unsafe for concurrency), MMIO requires unsafe"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "DECY-045"
      title: "Comprehensive sizeof edge case testing"
      priority: 20
      status: "✅ COMPLETED (Sprint 4)"
  last_completed:
    task_id: "STDLIB-MALLOC/CALLOC/REALLOC"
    title: "Memory allocation comprehensive documentation"
    version: "v0.81.0"
    date: "2025-10-17"
    unsafe_blocks_added: 0
    tests_added: 17
    coverage: "100%"
  - "Pull ANDON CORD immediately when bugs found during validation"
  - "Track unsafe block count per sprint (target: <5 per 1000 LOC)"
  - "Use STOP THE LINE protocol for all validation failures"
  - "Document all transformations with C99/K&R references"
  - "Prioritize ownership inference improvements in decy-ownership crate"

status:
  overall: "IN_PROGRESS"
  completion_percent: 67
  completed_tasks: 100
  in_progress_tasks: 0
  blocked_tasks: 1
  not_started_tasks: 49
  total_tasks: 150
  methodology: "EXTREME TDD (RED-GREEN-REFACTOR) + Ownership Inference"
  goal: "100% C99 language coverage with <5 unsafe blocks per 1000 LOC"
  last_completed:
    task_id: "EXPR-POSTFIX-ARRAY"
    title: "Array subscripting comprehensive documentation"
    version: "v0.78.0"
    date: "2025-10-17"
    unsafe_blocks_added: 0
    tests_added: 16
    coverage: "100%"
  current_sprint: 5
  current_unsafe_count_per_1000_loc: 0
  target_unsafe_count_per_1000_loc: 5
