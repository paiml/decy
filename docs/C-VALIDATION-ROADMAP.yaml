---
roadmap:
  title: "C Language Validation Roadmap - EXTREME TDD"
  goal: "Document every C construct transformation to idiomatic Rust with minimal unsafe"
  methodology: "EXTREME TDD (Test-First, RED-GREEN-REFACTOR)"
  reference: "ISO C99 Standard (ISO/IEC 9899:1999) + K&R C (2nd Edition)"
  status: "IN_PROGRESS"
  completion: "20%"
  unsafe_blocks_per_1000_loc_target: "<5"

  statistics:
    total_tasks: 150
    completed: 82
    partial_support: 0
    in_progress: 0
    blocked: 1
    not_started: 67
    coverage_percent: 55

extreme_tdd_workflow:
  description: "Standard workflow for each task"
  steps:
    - id: 1
      name: "RED"
      description: "Write failing test first"
      example: |
        #[test]
        fn test_<feature>_transformation() {
            let c_code = "<C input>";
            let expected_rust = "<expected rust>";

            let result = transpile(c_code)?;
            assert_eq!(result, expected_rust);

            // Verify unsafe block count
            let unsafe_count = count_unsafe_blocks(&result);
            assert!(unsafe_count <= MAX_UNSAFE_PER_MODULE);
        }

    - id: 2
      name: "GREEN"
      description: "Implement transformation"
      substeps:
        - "Update parser for C construct (decy-parser)"
        - "Update HIR representation (decy-hir)"
        - "Update analyzer for safety checks (decy-analyzer)"
        - "Update ownership inference (decy-ownership)"
        - "Update codegen (decy-codegen)"
        - "Verify safety properties (decy-verify)"

    - id: 3
      name: "REFACTOR"
      description: "Clean up implementation and minimize unsafe"
      substeps:
        - "Extract common patterns"
        - "Add helper functions"
        - "Document edge cases"
        - "Reduce unsafe blocks through better ownership inference"
        - "Add SAFETY comments to remaining unsafe blocks"

    - id: 4
      name: "DOCUMENT"
      description: "Add to examples and documentation"
      substeps:
        - "Update examples/"
        - "Add to test fixtures"
        - "Update CHANGELOG.md"
        - "Document unsafe rationale if any remain"

stop_the_line_protocol:
  description: "ANDON CORD - Pull when validation reveals bugs"
  trigger_conditions:
    - "Transpiled code doesn't compile"
    - "Transpiled code has different behavior than C"
    - "Unsafe block count exceeds target"
    - "Parser fails on valid C99 construct"
    - "Ownership inference creates memory leak"
    - "Verification stage fails safety checks"

  procedure:
    - step: 1
      action: "STOP all feature development immediately"
      responsible: "Developer who discovered issue"

    - step: 2
      action: "Create P0 ticket in roadmap.yaml"
      template: |
        P0-<CONSTRUCT>-<NUMBER>:
          title: "[P0] Fix <construct> transpilation bug"
          type: bug
          priority: critical
          story_points: <estimated>
          status: in_progress
          phase: RED
          discovered_during_validation: true
          validation_reference: "<ISO C99 section or K&R page>"
          c_input: |
            <failing C code>
          expected_rust: |
            <correct Rust output>
          actual_rust: |
            <buggy Rust output or error>
          safety_impact: "<memory safety, undefined behavior, etc.>"

    - step: 3
      action: "Apply EXTREME TDD fix (RED-GREEN-REFACTOR)"
      requirements:
        - "Must add failing test first (RED)"
        - "Must fix with minimal implementation (GREEN)"
        - "Must meet quality gates (REFACTOR)"
        - "Must verify unsafe count didn't increase"

    - step: 4
      action: "Resume validation only after fix verified"
      verification_checklist:
        - "All tests pass (make test)"
        - "Quality gates pass (make quality-gates)"
        - "Coverage ≥80% (≥90% for decy-ownership)"
        - "Unsafe count ≤5 per 1000 LOC"
        - "Original validation case passes"

validation_references:
  primary:
    - name: "ISO C99 Standard"
      identifier: "ISO/IEC 9899:1999"
      sections: 300+
      url: "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"
      coverage: "Complete C language specification"

    - name: "K&R C (2nd Edition)"
      authors: "Brian Kernighan, Dennis Ritchie"
      isbn: "0131103628"
      chapters: 8
      appendix_sections: 6
      coverage: "Canonical C reference with examples"

  supplementary:
    - name: "GCC Documentation"
      url: "https://gcc.gnu.org/onlinedocs/gcc/"
      coverage: "Extensions and compiler-specific behavior"

    - name: "Clang Documentation"
      url: "https://clang.llvm.org/docs/"
      coverage: "AST structure and libclang API"

unsafe_minimization_strategy:
  description: "4-phase strategy to reduce unsafe blocks"
  target: "<5 unsafe blocks per 1000 LOC"

  phases:
    - id: 1
      name: "Pattern-Based"
      description: "Detect common patterns and generate safe Rust"
      target_reduction: "100% → 50%"
      patterns:
        - "malloc/free → Box::new()"
        - "calloc/free → Vec::with_capacity()"
        - "Array allocation → Vec"
        - "String allocation → String/CString"
      status: "IN_PROGRESS"

    - id: 2
      name: "Ownership Inference"
      description: "Infer ownership from pointer usage"
      target_reduction: "50% → 20%"
      techniques:
        - "Classify pointers: owning vs borrowing"
        - "Detect unique ownership → Box"
        - "Detect shared read-only → &T"
        - "Detect exclusive mutable → &mut T"
        - "Build pointer dataflow graph"
      status: "IN_PROGRESS"
      critical_crate: "decy-ownership"

    - id: 3
      name: "Lifetime Inference"
      description: "Infer lifetimes from C variable scopes"
      target_reduction: "20% → 10%"
      techniques:
        - "Map C scope to Rust lifetime"
        - "Generate lifetime annotations"
        - "Validate lifetime constraints"
      status: "NOT_STARTED"

    - id: 4
      name: "Safe Wrappers"
      description: "Wrap remaining unsafe in safe abstractions"
      target_reduction: "10% → <5%"
      techniques:
        - "Create safe wrapper functions"
        - "Add SAFETY comments for audit trail"
        - "Document invariants"
      status: "NOT_STARTED"

chapters:
  # Based on ISO C99 Standard structure

  - id: 1
    name: "Scope & Terms (C99 §1-4)"
    description: "Foundational definitions and conformance"
    tasks:
      - id: "SCOPE-001"
        title: "Document C99 conformance scope"
        status: "completed"
        version: "v0.1.0"
        notes: "DECY targets C99 as baseline, with selective GCC extensions"
        validation_reference: "ISO C99 §1-2"

  - id: 2
    name: "Lexical Elements (C99 §6.4)"
    description: "Tokens, keywords, identifiers, constants"
    sections:
      - id: "2.1"
        name: "Keywords (C99 §6.4.1)"
        tasks:
          - id: "LEX-KW-001"
            title: "Document C keywords to Rust keywords mapping"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "int x;"
                rust: "let x: i32;"
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
              - c: "return 0;"
                rust: "return 0;"
            validation_reference: "K&R §2.1, ISO C99 §6.4.1"

      - id: "2.2"
        name: "Identifiers (C99 §6.4.2)"
        tasks:
          - id: "LEX-ID-001"
            title: "Document identifier naming rules"
            status: "completed"
            version: "v0.1.0"
            notes: "C identifiers map to Rust snake_case for variables/functions, PascalCase for types"
            validation_reference: "K&R §2.2, ISO C99 §6.4.2"

      - id: "2.3"
        name: "Constants (C99 §6.4.4)"
        tasks:
          - id: "LEX-CONST-INT"
            title: "Document integer constants"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "int x = 42;"
                rust: "let x: i32 = 42;"
              - c: "long y = 42L;"
                rust: "let y: i64 = 42;"
              - c: "unsigned int z = 42U;"
                rust: "let z: u32 = 42;"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.1"
            test_name: "test_integer_literal_transformation"

          - id: "LEX-CONST-FLOAT"
            title: "Document floating-point constants"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "float pi = 3.14f;"
                rust: "let pi: f32 = 3.14;"
              - c: "double e = 2.718;"
                rust: "let e: f64 = 2.718;"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.2"
            test_name: "test_float_literal_transformation"

          - id: "LEX-CONST-CHAR"
            title: "Document character constants"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "char c = 'A';"
                rust: "let c: u8 = b'A';"
              - c: "char newline = '\\n';"
                rust: "let newline: u8 = b'\\n';"
            validation_reference: "K&R §2.3, ISO C99 §6.4.4.4"
            test_name: "test_char_literal_transformation"

          - id: "LEX-CONST-STR"
            title: "Document string literals"
            status: "completed"
            version: "v0.65.0"
            examples:
              - c: "char* msg = \"Hello\";"
                rust: "let msg: &str = \"Hello\";"
                note: "Simple string: char* → &str (string slice, UTF-8, not null-terminated)"
              - c: "char* escaped = \"Line1\\nLine2\\tTab\";"
                rust: "let escaped = \"Line1\\nLine2\\tTab\";"
                note: "Escape sequences: same syntax (\\n, \\t, \\\", \\\\, \\0)"
              - c: "char* empty = \"\";"
                rust: "let empty = \"\";"
                note: "Empty string: same syntax, length 0"
              - c: "char* concat = \"Hello\" \" \" \"World\";"
                rust: "let concat = concat!(\"Hello\", \" \", \"World\");"
                note: "Concatenation: C auto-concatenates adjacent literals, Rust uses concat!() macro"
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
                note: "Format strings: %d → {}, type-safe formatting"
              - c: "if (strcmp(s, \"test\") == 0) { ... }"
                rust: "if s == \"test\" { ... }"
                note: "String comparison: strcmp() → direct == (more intuitive, type-safe)"
              - c: "char* path = \"C:\\\\Users\\\\John\";"
                rust: "let path = \"C:\\\\Users\\\\John\";"
                note: "Backslashes: same escaping rules (\\\\)"
              - c: "char* quote = \"He said \\\"Hi\\\"\";"
                rust: "let quote = \"He said \\\"Hi\\\"\";"
                note: "Quotes: \\\" for embedded quotes"
            validation_reference: "K&R §2.3, ISO C99 §6.4.5"
            test_name: "test_string_literal_transformation"
            test_file: "string_literals_documentation_test.rs"
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: String literals with 100% coverage. CRITICAL SAFETY DIFFERENCES: (1) C strings null-terminated (implicit \\0), Rust length stored separately (no null needed), (2) C strlen() O(n) runtime scan, Rust len() O(1) constant time, (3) C modifying string literals is UNDEFINED BEHAVIOR (but compiles), Rust immutable by default (compile error), (4) C char* conflates pointer and array, Rust clear distinction (&str borrowed vs String owned), (5) C byte-oriented (no encoding), Rust always valid UTF-8 (compile-time check), (6) C strcmp() needed for comparison, Rust direct == works (type-safe). Same escape sequences. Adjacent literal concatenation: C automatic, Rust concat!() macro. Format strings: printf %s/%d → println! {}. Test file demonstrates: simple literals, escape sequences (\\n, \\t, \\\", \\\\, \\0), empty strings, concatenation, printf/println transformation, string comparison, struct initialization, multiline strings, embedded nulls. All transformations safe (0 unsafe blocks). Rust strings safer, more ergonomic, and UTF-8 guaranteed."

          - id: "LEX-CONST-HEXFLOAT"
            title: "Document hexadecimal floating-point literals"
            status: "completed"
            priority: "medium"
            version: "v0.41.0"
            examples:
              - c: "double x = 0x1.8p3;"
                rust: "let x: f64 = 12.0;  // 1.5 * 2^3"
                note: "Rust has no hex float syntax, compute or use from_bits()"
              - c: "double pi = 0x1.921fb54442d18p1;"
                rust: "let pi = f64::from_bits(0x400921fb54442d18);"
                note: "Use from_bits() for exact IEEE 754 representation"
              - c: "float f = 0x1.0p0f;"
                rust: "let f: f32 = 1.0;"
                note: "f suffix → f32 type"
            validation_reference: "ISO C99 §6.4.4.2 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_hexadecimal_float_literals"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R: Only decimal float literals. C99: Added hex float literals (0x1.8p3). Rust: NO hex float syntax (compute or from_bits()). Format: 0x<mantissa>p<exponent> = mantissa × 2^exponent. Purpose: exact binary representation without decimal rounding. Useful for constants, bit-exact values, IEEE 754 patterns. Common in scientific/low-level computing."

  - id: 3
    name: "Types (C99 §6.2.5, §6.7)"
    description: "Basic types, derived types, type qualifiers"
    sections:
      - id: "3.1"
        name: "Basic Types (C99 §6.2.5)"
        tasks:
          - id: "TYPE-BASIC-INT"
            title: "Document integer types"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "char c;"
                rust: "let c: i8;"
              - c: "short s;"
                rust: "let s: i16;"
              - c: "int i;"
                rust: "let i: i32;"
              - c: "long l;"
                rust: "let l: i64;"
              - c: "unsigned int u;"
                rust: "let u: u32;"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_integer_type_mapping"

          - id: "TYPE-BASIC-FLOAT"
            title: "Document floating-point types"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "float f;"
                rust: "let f: f32;"
              - c: "double d;"
                rust: "let d: f64;"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_float_type_mapping"

          - id: "TYPE-BASIC-VOID"
            title: "Document void type"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "void func(void) {}"
                rust: "fn func() {}"
              - c: "void* ptr;"
                rust: "let ptr: *mut u8;"
                note: "void* requires unsafe handling"
            validation_reference: "K&R §2.2, ISO C99 §6.2.5"
            test_name: "test_void_type_mapping"

          - id: "TYPE-BASIC-BOOL"
            title: "Document boolean type"
            status: "completed"
            priority: "high"
            version: "v0.31.0"
            examples:
              - c: "#include <stdbool.h>\nbool flag = true;"
                rust: "let flag = true;"
                note: "Built-in bool type, no header needed"
              - c: "int flag = 1; if (flag) {}"
                rust: "let flag = true; if flag {}"
                note: "Pre-C99 int as bool → explicit bool"
              - c: "int x = (int)flag;"
                rust: "let x = flag as i32;"
                note: "Explicit conversion required"
              - c: "bool b = (x != 0);"
                rust: "let b = x != 0;"
                note: "Explicit comparison for int to bool"
            validation_reference: "ISO C99 §7.16 (stdbool.h), K&R (pre-C99)"
            test_name: "test_bool_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 bool → Rust bool (built-in). Same size (1 byte), same semantics. No implicit int conversions (type-safe). No bitwise operators on bool. Pre-C99 int flags → explicit bool."

          - id: "TYPE-BASIC-LONGLONG"
            title: "Document long long type"
            status: "completed"
            priority: "high"
            version: "v0.40.0"
            examples:
              - c: "long long x = 42LL;"
                rust: "let x: i64 = 42;"
                note: "C99 long long → Rust i64 (exactly 64 bits)"
              - c: "unsigned long long y = 42ULL;"
                rust: "let y: u64 = 42;"
                note: "Unsigned variant"
              - c: "long long timestamp = 1609459200000000000LL;"
                rust: "let timestamp: i64 = 1609459200000000000;"
                note: "Common use: nanosecond timestamps"
              - c: "long long file_size = 5368709120LL;"
                rust: "let file_size: i64 = 5368709120;"
                note: "Common use: file sizes > 4GB"
            validation_reference: "ISO C99 §6.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_long_long_type"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R had no standard 64-bit type. C99 added long long (at least 64 bits). Rust i64/u64 exactly 64 bits. C signed overflow = undefined behavior, Rust panics in debug/wraps in release. Use checked/wrapping methods. Common uses: timestamps, file sizes, large counters. 64-bit arithmetic native on modern CPUs."

      - id: "3.2"
        name: "Derived Types - Pointers (C99 §6.7.5.1)"
        tasks:
          - id: "TYPE-PTR-BASIC"
            title: "Document basic pointer types"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p;"
                rust: "let p: &i32;"
                note: "Or &mut i32 or Box<i32> depending on ownership"
            validation_reference: "K&R §5.1, ISO C99 §6.7.5.1"
            test_name: "test_pointer_type_basic"
            ownership_inference: "CRITICAL"

          - id: "TYPE-PTR-MALLOC"
            title: "Document malloc/free pattern → Box"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p = malloc(sizeof(int)); free(p);"
                rust: "let p = Box::new(0i32);"
                unsafe_count: 0
            validation_reference: "K&R §8.7, ISO C99 §7.20.3"
            test_name: "test_malloc_to_box_transformation"
            completed_ticket: "DECY-044"

          - id: "TYPE-PTR-ARRAY"
            title: "Document array allocation → Vec"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* arr = malloc(n * sizeof(int)); free(arr);"
                rust: "let arr = vec![0i32; n];"
                unsafe_count: 0
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_array_malloc_to_vec"

          - id: "TYPE-PTR-NULL"
            title: "Document NULL → Option"
            status: "completed"
            version: "v0.4.0"
            examples:
              - c: "int* p = NULL; if (p) { ... }"
                rust: "let p: Option<Box<i32>> = None; if let Some(p) = p { ... }"
                unsafe_count: 0
            validation_reference: "K&R §5.4, ISO C99 §7.17"
            test_name: "test_null_to_option"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"

          - id: "TYPE-FUNC-PTR"
            title: "Document function pointers"
            status: "completed"
            priority: "high"
            version: "v0.32.0"
            examples:
              - c: "int (*fp)(int, int);"
                rust: "let fp: fn(i32, i32) -> i32;"
                note: "Function pointer type (NOT nullable)"
              - c: "int (*fp)(int) = NULL;"
                rust: "let fp: Option<fn(i32) -> i32> = None;"
                note: "Nullable function pointer → Option<fn>"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
                note: "Function pointer typedef"
              - c: "struct Handler { int (*callback)(int); };"
                rust: "struct Handler { callback: fn(i32) -> i32 }"
                note: "Function pointer in struct"
            validation_reference: "K&R §5.11, §5.12, ISO C99 §6.7.5.3"
            test_name: "test_function_pointers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Function pointers → fn types (SAFE). NOT nullable (use Option<fn>). Type-safe (no unsafe casts). Separate from closures (Fn/FnMut/FnOnce). Common patterns: callbacks, strategy pattern, virtual dispatch, higher-order functions."

      - id: "3.3"
        name: "Derived Types - Arrays (C99 §6.7.5.2)"
        tasks:
          - id: "TYPE-ARRAY-FIXED"
            title: "Document fixed-size arrays"
            status: "completed"
            priority: "high"
            version: "v0.59.0"
            examples:
              - c: "int arr[10] = {0};"
                rust: "let arr: [i32; 10] = [0; 10];"
                note: "Zero init: C {0} → Rust [0; 10] (explicit repeat syntax)"
              - c: "int arr[5] = {1, 2, 3, 4, 5};"
                rust: "let arr: [i32; 5] = [1, 2, 3, 4, 5];"
                note: "Explicit values: same literal syntax in both"
              - c: "int val = arr[5];"
                rust: "let val = arr[5];  // Bounds checked at runtime"
                note: "Array access: C no bounds check (UNSAFE), Rust panics on out-of-bounds (SAFE)"
              - c: "arr[3] = 42;"
                rust: "arr[3] = 42;  // Requires mut"
                note: "Array modification: Rust requires mut keyword for writes"
              - c: "void process(int arr[], int len) { ... } process(data, 10);"
                rust: "fn process(arr: &[i32]) { ... } process(&data);"
                note: "Function param: C loses size (unsafe), Rust slice preserves size (safe)"
              - c: "int matrix[3][4] = {0};"
                rust: "let matrix: [[i32; 4]; 3] = [[0; 4]; 3];"
                note: "Multidimensional: type syntax [[inner; cols]; rows]"
              - c: "for (int i = 0; i < 10; i++) { arr[i] = i; }"
                rust: "for i in 0..10 { arr[i] = i; }"
                note: "Iteration: manual indexing works, but .iter_mut() more idiomatic"
              - c: "int sum = 0; for (int i = 0; i < 5; i++) { sum += arr[i]; }"
                rust: "let sum: i32 = arr.iter().sum();"
                note: "Sum pattern: Rust iterator .sum() more idiomatic than manual loop"
              - c: "const int lookup[5] = {10, 20, 30, 40, 50};"
                rust: "const LOOKUP: [i32; 5] = [10, 20, 30, 40, 50];"
                note: "Const array: compile-time constant, Rust uses SCREAMING_CASE"
              - c: "float values[5] = {1.0, 2.0, 3.0, 4.0, 5.0};"
                rust: "let values: [f32; 5] = [1.0, 2.0, 3.0, 4.0, 5.0];"
                note: "Different types: works with any Copy type (C float → Rust f32)"
            validation_reference: "K&R §5.2, ISO C99 §6.7.5.2"
            test_name: "test_fixed_array_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Fixed-size arrays: Stack-allocated, compile-time size. Critical safety differences: C arrays uninitialized by default (UNDEFINED VALUES), Rust requires initialization (compile error otherwise). C has NO bounds checking (buffer overflow possible), Rust checks bounds at runtime (panics on out-of-bounds - safe crash). C arrays decay to pointers implicitly (loses size information), Rust requires explicit slice conversion (preserves size). Function parameters: C int arr[] loses size (caller must pass length separately), Rust &[T] slice preserves size. Multidimensional: C [rows][cols], Rust [[T; cols]; rows]. Iteration: manual indexing works in both, Rust .iter() and .iter_mut() more idiomatic and safer. Copy: Rust arrays impl Copy if T: Copy (simple assignment copies). Const arrays: compile-time constants for lookup tables. All transformations enforce memory safety (0 unsafe blocks)."

          - id: "TYPE-ARRAY-INIT"
            title: "Document array initialization patterns"
            status: "completed"
            priority: "high"
            version: "v0.46.0"
            examples:
              - c: "int arr[10] = {0};"
                rust: "let arr: [i32; 10] = [0; 10];"
                note: "Zero initialization (all elements)"
              - c: "int arr[10] = {1, 2, 3};"
                rust: "let arr = [1, 2, 3, 0, 0, 0, 0, 0, 0, 0];"
                note: "Partial init: C zeros rest, Rust needs explicit"
              - c: "int arr[] = {1, 2, 3};"
                rust: "let arr = [1, 2, 3];"
                note: "Implicit size from initializer"
              - c: "char str[] = \"hello\";"
                rust: "let str = \"hello\";"
                note: "String literal (different: C has null terminator)"
              - c: "int matrix[2][2] = {{1,2},{3,4}};"
                rust: "let matrix: [[i32; 2]; 2] = [[1,2],[3,4]];"
                note: "Multidimensional array initialization"
              - c: "const int lookup[3] = {10, 20, 30};"
                rust: "const LOOKUP: [i32; 3] = [10, 20, 30];"
                note: "Const array initialization"
            validation_reference: "K&R §4.9, ISO C99 §6.7.8"
            test_name: "test_array_initialization"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Array initialization patterns: zero init ({0}), partial init (rest zeroed in C), full init, implicit size, string literals (include null in C), multidimensional, const arrays, struct arrays. C partial initialization zeros remaining elements implicitly. Rust requires explicit initialization. C allows array-to-pointer decay (implicit, unsafe). Rust requires explicit slices (safe). All transformations SAFE (0 unsafe blocks)."

          - id: "TYPE-ARRAY-VLA"
            title: "Document variable-length arrays → Vec"
            status: "completed"
            version: "v0.9.0"
            priority: "high"
            examples:
              - c: "int n = 10; int arr[n];"
                rust: "let n = 10; let arr = vec![0i32; n];"
            validation_reference: "ISO C99 §6.7.5.2 (VLA)"
            test_name: "test_vla_to_vec"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"
            unsafe_blocks: 0

      - id: "3.4"
        name: "Derived Types - Structs (C99 §6.7.2.1)"
        tasks:
          - id: "TYPE-STRUCT-BASIC"
            title: "Document struct definition"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "struct Point { int x; int y; };"
                rust: "struct Point { x: i32, y: i32 }"
            validation_reference: "K&R §6.1, ISO C99 §6.7.2.1"
            test_name: "test_struct_definition"

          - id: "TYPE-STRUCT-NESTED"
            title: "Document nested structs"
            status: "completed"
            version: "v0.15.0"
            priority: "medium"
            examples:
              - c: "struct Outer { struct Inner { int x; } inner; };"
                rust: "struct Inner { x: i32 } struct Outer { inner: Inner }"
            validation_reference: "K&R §6.2, ISO C99 §6.7.2.1"
            test_name: "test_nested_struct"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "TYPE-FLEXIBLE-ARRAY"
            title: "Document flexible array members"
            status: "completed"
            priority: "high"
            version: "v0.35.0"
            examples:
              - c: "struct Buffer { size_t len; char data[]; };"
                rust: "struct Buffer { len: usize, data: Vec<u8> }"
                note: "Flexible array member → Vec"
              - c: "malloc(sizeof(struct Buffer) + n);"
                rust: "Buffer { len: n, data: vec![0; n] }"
                note: "Allocation → Vec with capacity"
              - c: "struct Packet { int id; uint8_t payload[]; };"
                rust: "struct Packet { id: i32, payload: Vec<u8> }"
                note: "Variable-length payload"
            validation_reference: "ISO C99 §6.7.2.1 paragraph 16 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_flexible_array_members"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 flexible array members → Rust Vec<T>. Must be last member in C99, no such restriction in Rust. Automatic memory management. Bounds checking. Alternative patterns: &[T] for borrowed data, Box<[T]> for fixed-size heap slice."

          - id: "TYPE-UNION"
            title: "Document union → enum"
            status: "completed"
            priority: "high"
            version: "v0.27.0"
            examples:
              - c: "union Value { int i; float f; };"
                rust: "enum Value { Int(i32), Float(f32) }"
                note: "Type-safe enum instead of unsafe union"
              - c: "struct Tagged { int type; union { int i; float f; } data; };"
                rust: "enum Tagged { Int(i32), Float(f32) }"
                note: "Discriminated union → enum"
              - c: "union FFI { int i; };"
                rust: "#[repr(C)] union FFI { i: i32 }"
                note: "FFI union requires unsafe to read"
            validation_reference: "K&R §6.8, ISO C99 §6.7.2.1"
            test_name: "test_union_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Unions transform to enums (SAFE) for type safety. Discriminated unions become enums with built-in tag. FFI unions use #[repr(C)] union (unsafe to read). Option/Result replace common tagged union patterns."

          - id: "TYPE-ENUM"
            title: "Document enum types"
            status: "completed"
            priority: "high"
            version: "v0.30.0"
            examples:
              - c: "enum Color { RED, GREEN, BLUE };"
                rust: "#[repr(i32)] enum Color { Red, Green, Blue }"
                note: "Type-safe enum with C representation"
              - c: "enum Status { OK = 0, ERROR = 1 };"
                rust: "#[repr(i32)] enum Status { Ok = 0, Error = 1 }"
                note: "Explicit values preserved"
              - c: "int val = status;"
                rust: "let val = status as i32;"
                note: "Explicit conversion required"
              - c: "enum { MAX = 100 };"
                rust: "const MAX: i32 = 100;"
                note: "Anonymous enum → const declarations"
            validation_reference: "K&R §2.3, ISO C99 §6.7.2.2"
            test_name: "test_enum_types"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 18
            coverage: "100%"
            unsafe_blocks: 0
            note: "C enums → Rust enums with #[repr(i32)] for C ABI. Type-safe (cannot mix with int). Exhaustiveness checking in match. Can carry data (more powerful than C). Anonymous enums → const declarations."

      - id: "3.5"
        name: "Type Qualifiers (C99 §6.7.3)"
        tasks:
          - id: "TYPE-QUAL-CONST"
            title: "Document const qualifier"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "const int MAX = 100;"
                rust: "const MAX: i32 = 100;"
              - c: "const int* p;"
                rust: "let p: &i32;"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_const_qualifier"

          - id: "TYPE-QUAL-VOLATILE"
            title: "Document volatile → unsafe or atomic"
            status: "completed"
            priority: "low"
            version: "v0.20.0"
            examples:
              - c: "volatile int flag;"
                rust: "AtomicI32 (safe) or ptr::read_volatile() (unsafe for MMIO)"
            validation_reference: "K&R §A8.2, ISO C99 §6.7.3"
            test_name: "test_volatile_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation task - Atomic types are SAFE (0 unsafe), MMIO operations require unsafe. C volatile does NOT provide atomicity."

          - id: "TYPE-QUAL-RESTRICT"
            title: "Document restrict keyword"
            status: "completed"
            priority: "high"
            version: "v0.37.0"
            examples:
              - c: "void copy(int* restrict dest, const int* restrict src, size_t n);"
                rust: "fn copy(dest: &mut [i32], src: &[i32])"
                note: "C restrict promise → Rust borrow checker enforcement"
              - c: "int* restrict ptr = malloc(n * sizeof(int));"
                rust: "let ptr = vec![0; n];"
                note: "Exclusive ownership guaranteed"
              - c: "void add(int* restrict a, int* restrict b, int* restrict c) { *a = *b + *c; }"
                rust: "fn add(a: &mut i32, b: &i32, c: &i32) { *a = *b + *c; }"
                note: "Borrow checker enforces non-aliasing"
              - c: "const int* restrict arr;"
                rust: "&[i32]"
                note: "Immutable non-aliasing reference"
            validation_reference: "ISO C99 §6.7.3.1 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_restrict_keyword"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 restrict keyword → Rust borrow checker. C restrict is PROMISE (not verified), Rust borrow checker ENFORCES non-aliasing. Violations: C = undefined behavior, Rust = compile error. Rust provides STRONGER guarantees. Same optimization benefits. &mut is conceptually 'restrict by default'."

      - id: "3.6"
        name: "Type Definitions (C99 §6.7.7)"
        tasks:
          - id: "TYPE-TYPEDEF"
            title: "Document typedef → type alias"
            status: "completed"
            priority: "high"
            version: "v0.26.0"
            examples:
              - c: "typedef int Integer;"
                rust: "type Integer = i32;"
              - c: "typedef int* IntPtr;"
                rust: "type IntPtr<'a> = &'a i32;"
              - c: "typedef struct Point { int x; int y; } Point;"
                rust: "struct Point { x: i32, y: i32 }"
                note: "Rust struct names are already types"
              - c: "typedef int (*Callback)(int);"
                rust: "type Callback = fn(i32) -> i32;"
            validation_reference: "K&R §6.7, ISO C99 §6.7.7"
            test_name: "test_typedef_documentation"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Type aliases for primitives, pointers (with lifetimes), structs, arrays, function pointers. Rust newtype pattern provides stronger typing than C typedef. All transformations are safe (0 unsafe blocks)."

      - id: "3.7"
        name: "Initialization (C99 §6.7.8)"
        tasks:
          - id: "TYPE-INIT-DESIGNATED"
            title: "Document designated initializers"
            status: "completed"
            priority: "high"
            version: "v0.33.0"
            examples:
              - c: "struct Point p = { .x = 10, .y = 20 };"
                rust: "let p = Point { x: 10, y: 20 };"
                note: "Designated initializer → struct literal"
              - c: "struct Point p = { .x = 10 };"
                rust: "let p = Point { x: 10, ..Default::default() };"
                note: "Partial initialization → Default trait"
              - c: "int arr[5] = { [0] = 1, [4] = 5 };"
                rust: "let mut arr = [0; 5]; arr[0] = 1; arr[4] = 5;"
                note: "Array designators → manual initialization"
              - c: "struct Outer o = { .inner = { .x = 1 } };"
                rust: "let o = Outer { inner: Inner { x: 1 } };"
                note: "Nested designated initializers"
            validation_reference: "ISO C99 §6.7.8.17-38 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_designated_initializers"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 designated initializers → Rust struct literals. Syntax: .field = value → field: value. Partial init requires Default trait. No array designators (manual init). Order independent. Type-safe field names."

  - id: 4
    name: "Expressions (C99 §6.5)"
    description: "Operators, precedence, evaluation"
    sections:
      - id: "4.1"
        name: "Primary Expressions (C99 §6.5.1)"
        tasks:
          - id: "EXPR-PRIMARY-ID"
            title: "Document identifier expressions"
            status: "completed"
            version: "v0.1.0"
            validation_reference: "K&R §2.1, ISO C99 §6.5.1"

      - id: "4.2"
        name: "Postfix Operators (C99 §6.5.2)"
        tasks:
          - id: "EXPR-POSTFIX-ARRAY"
            title: "Document array subscripting"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "arr[i]"
                rust: "arr[i]"
            validation_reference: "K&R §5.2, ISO C99 §6.5.2.1"
            test_name: "test_array_subscript"

          - id: "EXPR-COMPOUND-LITERAL"
            title: "Document compound literals"
            status: "completed"
            priority: "high"
            version: "v0.34.0"
            examples:
              - c: "(struct Point){ .x = 10, .y = 20 }"
                rust: "Point { x: 10, y: 20 }"
                note: "No cast syntax needed in Rust"
              - c: "draw((struct Point){ .x = 1, .y = 2 });"
                rust: "draw(Point { x: 1, y: 2 });"
                note: "Temporary struct as function argument"
              - c: "(int[]){ 1, 2, 3, 4, 5 }"
                rust: "[1, 2, 3, 4, 5]"
                note: "Array literal (no cast needed)"
              - c: "struct Point* p = &(struct Point){ .x = 1 };"
                rust: "let temp = Point { x: 1, y: 0 }; let p = &temp;"
                note: "Reference to temporary"
            validation_reference: "ISO C99 §6.5.2.5 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_compound_literals"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 compound literals → Rust struct/array literals. No (Type){} cast syntax needed. Automatic storage duration. Can be modified (lvalue). Combines with designated initializers. Rust temporaries have clear lifetime rules."

          - id: "EXPR-POSTFIX-CALL"
            title: "Document function calls"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "func(x, y)"
                rust: "func(x, y)"
            validation_reference: "K&R §4.2, ISO C99 §6.5.2.2"
            test_name: "test_function_call"

          - id: "EXPR-POSTFIX-MEMBER"
            title: "Document struct member access"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "point.x"
                rust: "point.x"
              - c: "point->x"
                rust: "point.x"
                note: "Pointer dereference eliminated with ownership"
            validation_reference: "K&R §6.1, ISO C99 §6.5.2.3"
            test_name: "test_member_access"

          - id: "EXPR-MEMBER-ACCESS-PATTERNS"
            title: "Document struct member access patterns"
            status: "completed"
            priority: "high"
            version: "v0.47.0"
            examples:
              - c: "struct.field"
                rust: "struct.field"
                note: "Direct member access (same syntax)"
              - c: "ptr->field"
                rust: "point.field"
                note: "Arrow operator eliminated with ownership"
              - c: "(*ptr).field"
                rust: "ptr.field"
                note: "Auto-deref in Rust (cleaner)"
              - c: "outer.inner.field"
                rust: "outer.inner.field"
                note: "Nested member access (same)"
              - c: "arr[i].field"
                rust: "arr[i].field"
                note: "Array of structs (same)"
              - c: "node->next->data"
                rust: "node.next.data"
                note: "Pointer chain eliminated with references"
            validation_reference: "K&R §6.1-6.3, ISO C99 §6.5.2.3"
            test_name: "test_struct_member_access"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "Struct member access: C has dot (.) and arrow (->), Rust uses dot for both. Arrow operator ptr->field is shorthand for (*ptr).field in C. Rust eliminates arrow with ownership and auto-deref. References use dot operator (automatic dereferencing). No null pointer dereferences in safe Rust. Nested access and array access have same syntax. Pointer chains use references or Box (ownership-based). All basic member access transformations SAFE (0 unsafe for direct access, some pointer patterns may need unsafe in current transpiler)."

          - id: "EXPR-POSTFIX-INCR"
            title: "Document post-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.10.0"
            examples:
              - c: "x++"
                rust: "{ let tmp = x; x += 1; tmp }"
              - c: "x--"
                rust: "{ let tmp = x; x -= 1; tmp }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.2.4"
            test_name: "test_postfix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "EXPR-INCR-DECR-PATTERNS"
            title: "Document increment/decrement operator patterns"
            status: "completed"
            priority: "high"
            version: "v0.50.0"
            examples:
              - c: "int y = x++;"
                rust: "let y = { let tmp = x; x += 1; tmp };"
                note: "Post-increment: returns old value, then increments"
              - c: "int y = ++x;"
                rust: "let y = { x += 1; x };"
                note: "Pre-increment: increments first, then returns new value"
              - c: "int y = x--;"
                rust: "let y = { let tmp = x; x -= 1; tmp };"
                note: "Post-decrement: returns old value, then decrements"
              - c: "int y = --x;"
                rust: "let y = { x -= 1; x };"
                note: "Pre-decrement: decrements first, then returns new value"
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
                note: "Loop counter pattern (idiomatic Rust range)"
              - c: "result = x++ + 10;"
                rust: "result = { let tmp = x; x += 1; tmp } + 10;"
                note: "Post-increment in expression (uses old value)"
              - c: "result = ++x + 10;"
                rust: "result = { x += 1; x } + 10;"
                note: "Pre-increment in expression (uses new value)"
              - c: "arr[i++]"
                rust: "arr[{ let tmp = i; i += 1; tmp }]"
                note: "Array indexing with post-increment (use index, then increment)"
              - c: "arr[--i]"
                rust: "arr[{ i -= 1; i }]"
                note: "Array indexing with pre-decrement (decrement first, then use)"
              - c: "while (n > 0) { sum += n--; }"
                rust: "while n > 0 { sum += { let tmp = n; n -= 1; tmp }; }"
                note: "Decrement in loop (countdown pattern)"
            validation_reference: "K&R §2.8, ISO C99 §6.5.2.4 (post), §6.5.3.1 (pre)"
            test_name: "test_increment_decrement_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Increment/decrement operators (++/--): Rust has NO native ++/-- operators. Post-increment (x++) returns old value, then increments. Pre-increment (++x) increments first, then returns new value. Same for decrement. C allows undefined behavior with multiple modifications in single expression (x++ + x++). Rust block expressions enforce sequencing (SAFE). All transformations use block expressions with explicit steps. Requires mutable variables (mut). Common patterns: loop counters, array indexing, sequence operations. Post uses tmp variable to save old value. Pre directly uses new value after increment. All transformations SAFE (0 unsafe blocks). Rust ranges (0..n) preferred for simple loops."

      - id: "4.3"
        name: "Unary Operators (C99 §6.5.3)"
        tasks:
          - id: "EXPR-UNARY-INCR"
            title: "Document pre-increment/decrement"
            status: "completed"
            priority: "medium"
            version: "v0.11.0"
            examples:
              - c: "++x"
                rust: "{ x += 1; x }"
              - c: "--x"
                rust: "{ x -= 1; x }"
            validation_reference: "K&R §2.8, ISO C99 §6.5.3.1"
            test_name: "test_prefix_increment"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

          - id: "EXPR-UNARY-ADDR"
            title: "Document address-of operator (&)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "&x"
                rust: "&x"
                note: "Safe borrow in Rust"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_address_of"

          - id: "EXPR-UNARY-DEREF"
            title: "Document dereference operator (*)"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "*p"
                rust: "*p"
                note: "Safe with references, may need unsafe with raw pointers"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_dereference"

          - id: "EXPR-ADDR-DEREF-PATTERNS"
            title: "Document address-of and dereference patterns"
            status: "completed"
            priority: "high"
            version: "v0.48.0"
            examples:
              - c: "int* ptr = &x;"
                rust: "let ptr: &i32 = &x;"
                note: "Address-of creates reference (safe)"
              - c: "int value = *ptr;"
                rust: "let value = *ptr;"
                note: "Dereference read (safe with &T)"
              - c: "*ptr = 20;"
                rust: "*ptr = 20;"
                note: "Dereference write (needs &mut T)"
              - c: "int** pp = &ptr;"
                rust: "let pp: &&i32 = &&x;"
                note: "Double indirection with references"
              - c: "void func(int* p) { *p = 5; }"
                rust: "fn func(p: &mut i32) { *p = 5; }"
                note: "Pointer parameters → mutable references"
              - c: "const int* cp = &x;"
                rust: "let cp: &i32 = &x;"
                note: "Const pointer → immutable reference (default)"
              - c: "int* p = &arr[i];"
                rust: "let p = &arr[i];"
                note: "Address of array element"
            validation_reference: "K&R §5.1, ISO C99 §6.5.3.2"
            test_name: "test_address_of_dereference"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Address-of (&) and dereference (*) operators: C creates raw pointers (can be null, no lifetime tracking), Rust creates references (never null, borrow checker enforces lifetimes). C pointers: int* (mutable by default). Rust: &T (immutable) or &mut T (mutable, explicit). Dereference for reading safe with &T. Dereference for writing requires &mut T. Double indirection works with references. Pointer parameters become references. Const pointers map to immutable references. All reference operations SAFE (0 unsafe blocks). Raw pointers exist but require unsafe to dereference."

          - id: "DECL-MULTIPLE"
            title: "Document multiple variable declarations"
            status: "completed"
            priority: "high"
            version: "v0.49.0"
            examples:
              - c: "int a, b, c;"
                rust: "let a: i32;\nlet b: i32;\nlet c: i32;"
                note: "Multiple simple declarations → separate declarations"
              - c: "int x = 10, y = 20, z = 30;"
                rust: "let x = 10;\nlet y = 20;\nlet z = 30;"
                note: "With initialization → separate let statements"
              - c: "int a = 5, b, c = 10;"
                rust: "let a = 5;\nlet b: i32;\nlet c = 10;"
                note: "Mixed initialized/uninitialized → separate declarations"
              - c: "int *p, q;"
                rust: "let p: &i32;\nlet q: i32;"
                note: "CONFUSING: p is pointer, q is int (NOT pointer!)"
              - c: "int *p, *q;"
                rust: "let p: &i32;\nlet q: &i32;"
                note: "Both pointers (each needs * in C)"
              - c: "int arr[5], brr[3];"
                rust: "let arr: [i32; 5];\nlet brr: [i32; 3];"
                note: "Multiple arrays → separate declarations"
              - c: "const int MIN = 0, MAX = 100;"
                rust: "const MIN: i32 = 0;\nconst MAX: i32 = 100;"
                note: "Const multiple declarations → separate const"
              - c: "struct Point p1, p2, p3;"
                rust: "let p1: Point;\nlet p2: Point;\nlet p3: Point;"
                note: "Multiple struct instances → separate declarations"
              - c: "for (int i = 0, j = 10; i < j; i++)"
                rust: "let mut i = 0;\nlet mut j = 10;\nfor ..."
                note: "For loop multiple declarations → separate let statements"
            validation_reference: "K&R §2.2, ISO C99 §6.7"
            test_name: "test_multiple_declarations"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Multiple variable declarations (C99 §6.7): C allows declaring multiple variables in one statement (int a, b, c;). CONFUSING pattern: int *p, q; makes p a pointer but q an int (NOT a pointer). Each declarator can have different initialization. Rust requires separate declarations (clearer intent). Transformation: each variable gets its own let/const statement. Pointer/value mixing eliminated (safer). Each declaration explicit (more readable). Common patterns: simple vars, initialized vars, mixed init, multiple pointers (confusing), arrays, globals, consts, struct instances, for loops. All transformations SAFE (0 unsafe blocks). Rust approach prevents pointer/value confusion."

          - id: "EXPR-UNARY-SIZEOF"
            title: "Document sizeof operator"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "sizeof(int)"
                rust: "std::mem::size_of::<i32>()"
              - c: "sizeof(x)"
                rust: "std::mem::size_of_val(&x)"
            validation_reference: "K&R §5.4, ISO C99 §6.5.3.4"
            test_name: "test_sizeof_expression"
            completed_ticket: "DECY-044"

          - id: "EXPR-CAST"
            title: "Document cast operators"
            status: "completed"
            priority: "high"
            version: "v0.29.0"
            examples:
              - c: "int i = (int)3.14;"
                rust: "let i = 3.14 as i32;"
                note: "Numeric cast uses as operator (SAFE)"
              - c: "unsigned u = (unsigned)-1;"
                rust: "let u = -1i32 as u32;"
                note: "Wrapping is well-defined"
              - c: "int bits = *(int*)&f;"
                rust: "let bits = f.to_bits();"
                note: "Type punning has safe methods"
              - c: "void* vp = (void*)ptr;"
                rust: "let vp = ptr as *const ();"
                note: "Pointer casts safe to create, unsafe to deref"
            validation_reference: "K&R §2.7, ISO C99 §6.5.4"
            test_name: "test_cast_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 20
            coverage: "100%"
            unsafe_blocks: 0
            note: "Cast operators → as operator (SAFE for most casts). Numeric conversions explicit and well-defined. Type punning has safe methods (to_bits). Only transmute requires unsafe. From/Into traits for struct conversions."

      - id: "4.4"
        name: "Arithmetic Operators (C99 §6.5.5-6.5.7)"
        tasks:
          - id: "EXPR-ARITH-BINARY"
            title: "Document binary arithmetic"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "a + b"
                rust: "a + b"
              - c: "a * b"
                rust: "a * b"
              - c: "a / b"
                rust: "a / b"
                note: "Rust panics on division by zero (safer)"
            validation_reference: "K&R §2.5, ISO C99 §6.5.5-6"
            test_name: "test_arithmetic_operators"

          - id: "EXPR-ARITH-BINARY-PATTERNS"
            title: "Document binary arithmetic operator patterns"
            status: "completed"
            priority: "high"
            version: "v0.53.0"
            examples:
              - c: "sum = a + b;"
                rust: "sum = a + b;"
                note: "Addition (same syntax)"
              - c: "diff = a - b;"
                rust: "diff = a - b;"
                note: "Subtraction (same syntax)"
              - c: "product = a * b;"
                rust: "product = a * b;"
                note: "Multiplication (same syntax)"
              - c: "quotient = a / b;"
                rust: "quotient = a / b;"
                note: "Division (C undefined for /0, Rust panics - safe)"
              - c: "remainder = a % b;"
                rust: "remainder = a % b;"
                note: "Modulus (C undefined for %0, Rust panics - safe)"
              - c: "result = a + b * c;"
                rust: "result = a + b * c;"
                note: "Precedence: * before + (same in both)"
              - c: "result = (a + b) * c;"
                rust: "result = (a + b) * c;"
                note: "Parentheses force evaluation order"
              - c: "result = 7 / 2;"
                rust: "result = 7 / 2;"
                note: "Integer division truncates (3, not 3.5)"
              - c: "remainder = -17 % 5;"
                rust: "remainder = -17 % 5;"
                note: "Modulus sign matches dividend (-2)"
              - c: "formula = a*x*x + b*x + c;"
                rust: "formula = a*x*x + b*x + c;"
                note: "Compound expressions work identically"
            validation_reference: "K&R §2.5, ISO C99 §6.5.5 (multiplicative), §6.5.6 (additive)"
            test_name: "test_binary_arithmetic_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Binary arithmetic operators (+, -, *, /, %): Same syntax in C and Rust. Key difference: C has undefined behavior for division/modulus by zero, Rust panics (safe). Operator precedence identical (* / % before + -). Integer division truncates toward zero in both. Modulus sign matches dividend (first operand). Rust stricter on type mixing (requires explicit casts). Integer overflow: C undefined (signed) or wraps (unsigned), Rust panics in debug, wraps in release. All transformations SAFE (0 unsafe blocks). Performance identical (same machine instructions)."

          - id: "EXPR-ARITH-PTR"
            title: "Document pointer arithmetic → slice indexing"
            status: "blocked"
            phase: "RED"
            priority: "high"
            examples:
              - c: "p + 1"
                rust: "&arr[i + 1]"
                note: "Eliminate pointer arithmetic with slices"
            validation_reference: "K&R §5.3, ISO C99 §6.5.6"
            test_name: "test_pointer_arithmetic_safe"
            sprint: 3
            ownership_inference: "CRITICAL"
            red_phase_date: "2025-10-15"
            tests_added: 9
            tests_passing: 1
            tests_failing: 8
            blocked_reason: "Requires ownership inference infrastructure (pointer dataflow, array detection, pointer classification)"
            implementation_plan: "docs/EXPR-ARITH-PTR-implementation-plan.md"
            note: "RED phase complete - paused pending ownership inference foundation"

          - id: "EXPR-BITWISE"
            title: "Document bitwise operators"
            status: "completed"
            version: "v0.25.0"
            priority: "high"
            examples:
              - c: "a & b"
                rust: "a & b"
              - c: "a | b"
                rust: "a | b"
              - c: "a ^ b"
                rust: "a ^ b"
              - c: "~a"
                rust: "!a"
                note: "C uses ~, Rust uses ! for bitwise NOT"
              - c: "a << n"
                rust: "a << n"
              - c: "a >> n"
                rust: "a >> n"
            validation_reference: "K&R §2.9, ISO C99 §6.5.10-6.5.12"
            test_name: "test_bitwise_operators"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "Bitwise operators (&, |, ^, ~, <<, >>) for bit manipulation, flags, masks. All operations are safe. Syntax identical to C except NOT (~→!). Type-safe signed/unsigned handling."

      - id: "4.5"
        name: "Comparison Operators (C99 §6.5.8-6.5.9)"
        tasks:
          - id: "EXPR-CMP-RELATIONAL"
            title: "Document relational operators"
            status: "completed"
            priority: "high"
            version: "v0.61.0"
            examples:
              - c: "if (a < b) { smaller = a; }"
                rust: "if a < b { smaller = a; }"
                note: "Less than: same syntax, returns bool in Rust (not int)"
              - c: "if (a > b) { larger = a; }"
                rust: "if a > b { larger = a; }"
                note: "Greater than: common for max/sorting operations"
              - c: "if (a <= b) { process(); }"
                rust: "if a <= b { process(); }"
                note: "Less than or equal: inclusive lower bound"
              - c: "if (a >= b) { process(); }"
                rust: "if a >= b { process(); }"
                note: "Greater than or equal: inclusive upper bound"
              - c: "if (x >= MIN && x <= MAX) { in_range = 1; }"
                rust: "if x >= MIN && x <= MAX { in_range = true; }"
                note: "Range check: combining comparisons for validation"
              - c: "int min = (a < b) ? a : b;"
                rust: "let min = if a < b { a } else { b };"
                note: "Finding min/max: ternary → if expression"
            validation_reference: "K&R §2.6, ISO C99 §6.5.8"
            test_name: "test_comparison_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Relational operators (<, >, <=, >=): Same syntax in C and Rust. Return type: C returns int (0 or 1), Rust returns bool (type-safe). Type requirements: Rust requires PartialOrd trait. Common patterns: range checking, loop bounds, finding min/max, sorting. All transformations type-safe (0 unsafe blocks). Combined with equality operators in single test file."

          - id: "EXPR-CMP-EQUALITY"
            title: "Document equality operators"
            status: "completed"
            priority: "high"
            version: "v0.61.0"
            examples:
              - c: "if (a == b) { handle_equal(); }"
                rust: "if a == b { handle_equal(); }"
                note: "Equality: same syntax, returns bool in Rust"
              - c: "if (a != b) { handle_different(); }"
                rust: "if a != b { handle_different(); }"
                note: "Inequality: common for sentinel/NULL checks"
              - c: "if (ptr != NULL && value != 0) { ... }"
                rust: "if let Some(ptr) = opt { if value != 0 { ... } }"
                note: "NULL check: C uses !=, Rust uses Option pattern"
              - c: "if (strcmp(str1, str2) == 0) { strings_equal(); }"
                rust: "if str1 == str2 { strings_equal(); }"
                note: "String comparison: C needs strcmp, Rust uses direct =="
              - c: "int is_equal = (a == b);"
                rust: "let is_equal = a == b;"
                note: "Comparison as value: C stores int, Rust stores bool"
            validation_reference: "K&R §2.6, ISO C99 §6.5.9"
            test_name: "test_comparison_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Equality operators (==, !=): Same syntax in C and Rust. Return type: C returns int (0 or 1), Rust returns bool (type-safe). Type requirements: Rust requires PartialEq trait. String comparison: C needs strcmp function, Rust supports direct == (more intuitive). NULL checks: C uses ptr != NULL, Rust uses Option pattern. Common patterns: sentinel checks, validation, loop termination. All transformations type-safe (0 unsafe blocks). Combined with relational operators in single test file."

      - id: "4.6"
        name: "Logical Operators (C99 §6.5.13-6.5.14)"
        tasks:
          - id: "EXPR-LOGICAL-AND"
            title: "Document logical AND (&&)"
            status: "completed"
            priority: "high"
            version: "v0.60.0"
            examples:
              - c: "if (a && b) { process(); }"
                rust: "if a && b { process(); }"
                note: "Simple AND: same syntax, Rust requires bool operands (type safe)"
              - c: "if (a && b && c) { process(); }"
                rust: "if a && b && c { process(); }"
                note: "Multiple AND: left-to-right, short-circuit on first false"
              - c: "if (is_valid(ptr) && expensive_check(ptr)) { ... }"
                rust: "if is_valid(ptr) && expensive_check(ptr) { ... }"
                note: "Short-circuit: expensive_check NOT called if is_valid false"
              - c: "if (ptr != NULL && ptr->field > 0) { ... }"
                rust: "if let Some(ptr) = opt { if ptr.field > 0 { ... } }"
                note: "NULL check: C short-circuit prevents deref, Rust uses Option"
              - c: "if (x >= MIN && x <= MAX) { in_range(x); }"
                rust: "if x >= MIN && x <= MAX { in_range(x); }"
                note: "Range check: combines lower and upper bounds"
              - c: "int x = 5; if (x && y) { ... }"
                rust: "let x = 5; if x != 0 && y { ... }"
                note: "C allows int as bool (implicit), Rust requires explicit comparison"
            validation_reference: "K&R §2.6, ISO C99 §6.5.13"
            test_name: "test_logical_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Logical AND (&&): Short-circuit evaluation (if left false, right NOT evaluated). C and Rust same syntax. Critical difference: C allows any integer as bool (0=false, non-zero=true), Rust REQUIRES bool type (compile error for int). Short-circuit prevents null deref in C (ptr != NULL && ptr->field), prevents expensive computation. Common patterns: multiple conditions, NULL/Option checks, range validation, function guards. Type safety: Rust prevents assignment in condition (if x = 5 is error), C allows (common bug source). All transformations type-safe (0 unsafe blocks)."

          - id: "EXPR-LOGICAL-OR"
            title: "Document logical OR (||)"
            status: "completed"
            priority: "high"
            version: "v0.60.0"
            examples:
              - c: "if (a || b) { process(); }"
                rust: "if a || b { process(); }"
                note: "Simple OR: same syntax, Rust requires bool operands"
              - c: "if (a || b || c) { process(); }"
                rust: "if a || b || c { process(); }"
                note: "Multiple OR: left-to-right, short-circuit on first true"
              - c: "if ((a && b) || c) { process(); }"
                rust: "if (a && b) || c { process(); }"
                note: "Combined: AND binds tighter than OR, use parens for clarity"
              - c: "int value = get_cached() || get_computed();"
                rust: "let value = get_cached() || get_computed();"
                note: "Fallback pattern: try cached first, compute only if needed"
              - c: "if (!(a && b)) { ... }"
                rust: "if !(a && b) { ... }  // Or: if !a || !b { ... }"
                note: "De Morgan's law: !(a && b) == !a || !b"
            validation_reference: "K&R §2.6, ISO C99 §6.5.14"
            test_name: "test_logical_operators_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Logical OR (||): Short-circuit evaluation (if left true, right NOT evaluated). C and Rust same syntax. Type safety: Rust requires bool, C allows int (0=false, non-zero=true). Common patterns: fallback/default values, multiple exit conditions, error checks. Precedence: AND (&&) binds tighter than OR (||). De Morgan's laws apply. All transformations type-safe (0 unsafe blocks). Combined with AND documentation in single comprehensive test file."

          - id: "EXPR-SHORT-CIRCUIT"
            title: "Document short-circuit evaluation"
            status: "completed"
            priority: "high"
            version: "v0.45.0"
            examples:
              - c: "if (ptr != NULL && ptr->value > 0) { ... }"
                rust: "if ptr.is_some() && ptr.unwrap().value > 0 { ... }"
                note: "Null check prevents crash (right not evaluated if left false)"
              - c: "if (i < len && arr[i] > 0) { ... }"
                rust: "if i < len && arr[i] > 0 { ... }"
                note: "Bounds check prevents out-of-bounds access"
              - c: "result = 0 && expensive();"
                rust: "result = false && expensive();"
                note: "expensive() NOT called (short-circuit)"
              - c: "result = 1 || expensive();"
                rust: "result = true || expensive();"
                note: "expensive() NOT called (short-circuit)"
              - c: "if (cached || (cached = init())) { ... }"
                rust: "if cached || { cached = init(); cached } { ... }"
                note: "Lazy initialization pattern"
            validation_reference: "K&R §2.6, ISO C99 §6.5.13-6.5.14"
            test_name: "test_short_circuit_evaluation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Short-circuit evaluation: && stops at first false, || stops at first true. Right operand NOT evaluated if result determined from left. Critical for safety (null checks, bounds checks). Same semantics in C and Rust. Evaluation order: left-to-right (guaranteed). Common patterns: ptr && ptr->field, i < len && arr[i], cheap() && expensive(), cached || init(). All transformations SAFE (0 unsafe blocks)."

          - id: "EXPR-TERNARY"
            title: "Document ternary operator (? :)"
            status: "completed"
            priority: "high"
            version: "v0.62.0"
            examples:
              - c: "max = (a > b) ? a : b;"
                rust: "let max = if a > b { a } else { b };"
                note: "Simple ternary → if expression (same short-circuit)"
              - c: "sign = (x >= 0) ? 1 : -1;"
                rust: "let sign = if x >= 0 { 1 } else { -1 };"
                note: "Sign determination pattern"
              - c: "return (x >= 0) ? x : -x;"
                rust: "if x >= 0 { x } else { -x }"
                note: "Ternary in return → if expression as implicit return"
              - c: "grade = (x >= 90) ? 'A' : (x >= 80) ? 'B' : 'C';"
                rust: "let grade = if x >= 90 { 'A' } else if x >= 80 { 'B' } else { 'C' };"
                note: "Nested ternary → if-else-if chain (MUCH more readable)"
              - c: "grade = (x >= 90) ? 'A' : (x >= 80) ? 'B' : (x >= 70) ? 'C' : 'F';"
                rust: "let grade = if x >= 90 { 'A' } else if x >= 80 { 'B' } else if x >= 70 { 'C' } else { 'F' };"
                note: "Deeply nested ternary dramatically more readable as if-else-if"
              - c: "result = is_cached() ? get_cached() : compute();"
                rust: "let result = if is_cached() { get_cached() } else { compute() };"
                note: "Function calls: short-circuit preserved, only one called"
              - c: "value = (ptr != NULL) ? ptr->data : default;"
                rust: "let value = if let Some(ptr) = opt { ptr.data } else { default };"
                note: "NULL check → Option pattern matching (safe)"
              - c: "result = (b != 0) ? a / b : 0;"
                rust: "let result = if b != 0 { a / b } else { 0 };"
                note: "Zero check guard (prevent division by zero)"
              - c: "clamped = (x < MIN) ? MIN : (x > MAX) ? MAX : x;"
                rust: "let clamped = if x < MIN { MIN } else if x > MAX { MAX } else { x };"
                note: "Clamp/bounds check pattern (three-way decision)"
              - c: "is_valid = (x >= 0 && x < 100) ? 1 : 0;"
                rust: "let is_valid = x >= 0 && x < 100;"
                note: "Boolean result: unnecessary ternary eliminated (type safety)"
            validation_reference: "K&R §2.11, ISO C99 §6.5.15"
            test_name: "test_ternary_operator"
            test_file: "ternary_operator_documentation_test.rs"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: Ternary operator (? :) → if expression (SAFE, 100% coverage). Critical differences: (1) Rust if expressions are TYPE-SAFE (both branches must match types, C allows implicit conversions), (2) Condition must be bool in Rust (C allows any integer), (3) If-else-if chains dramatically more readable than nested ternaries, (4) Option pattern matching replaces NULL checks safely. Short-circuit evaluation preserved. All transformations safe (0 unsafe blocks). Test file demonstrates: simple max/min, sign determination, return expressions, nested grades (3-4 levels), function calls, NULL/zero checks, clamping, boolean simplification, array initialization, printing, pointer truthy checks, sign extension, default values. Syntax difference makes nested conditions vastly more maintainable."

          - id: "EXPR-COMMA"
            title: "Document comma operator"
            status: "completed"
            priority: "high"
            version: "v0.44.0"
            examples:
              - c: "x = (a = 1, b = 2, a + b);"
                rust: "let x = { a = 1; b = 2; a + b };"
                note: "Comma operator → block expression"
              - c: "for (i = 0, j = n; i < j; i++, j--) { ... }"
                rust: "{ i = 0; j = n; } for ... { ... i += 1; j -= 1; }"
                note: "For loop comma → separate init/update statements"
              - c: "while (x = f(), x > 0) { ... }"
                rust: "while { let x = f(); x > 0 } { ... }"
                note: "While condition comma → block expression"
              - c: "(expr1, expr2, expr3)"
                rust: "{ expr1; expr2; expr3 }"
                note: "Left-to-right evaluation, returns last value"
            validation_reference: "K&R §2.12, ISO C99 §6.5.17"
            test_name: "test_comma_operator"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 13
            coverage: "100%"
            unsafe_blocks: 0
            note: "Comma operator (lowest precedence) → block expressions. Guaranteed left-to-right evaluation in both C and Rust. All subexpressions evaluated for side effects. Returns rightmost value. Block expressions provide same semantics with explicit scoping. All transformations SAFE (0 unsafe blocks)."

      - id: "4.7"
        name: "Assignment Operators (C99 §6.5.16)"
        tasks:
          - id: "EXPR-ASSIGN-SIMPLE"
            title: "Document simple assignment"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "x = 5"
                rust: "x = 5"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16"
            test_name: "test_simple_assignment"

          - id: "EXPR-ASSIGN-COMPOUND"
            title: "Document compound assignment"
            status: "completed"
            priority: "medium"
            version: "v0.63.0"
            examples:
              - c: "count += 5;"
                rust: "count += 5;"
                note: "Addition assignment: same syntax, type-safe, requires mut"
              - c: "balance -= 25;"
                rust: "balance -= 25;"
                note: "Subtraction assignment: checked overflow in debug"
              - c: "value *= 3;"
                rust: "value *= 3;"
                note: "Multiplication assignment: same syntax, type-safe"
              - c: "total /= 4;"
                rust: "total /= 4;"
                note: "Division assignment: panics on division by zero (safe)"
              - c: "index %= 10;"
                rust: "index %= 10;"
                note: "Modulo assignment: panics on mod by zero (safe)"
              - c: "flags &= mask;"
                rust: "flags &= mask;"
                note: "Bitwise AND: clear bits (masking pattern)"
              - c: "flags |= bit;"
                rust: "flags |= bit;"
                note: "Bitwise OR: set bits (most common flag operation)"
              - c: "state ^= toggle;"
                rust: "state ^= toggle;"
                note: "Bitwise XOR: toggle bits (XOR with same value = 0)"
              - c: "value <<= n;"
                rust: "value <<= n;"
                note: "Left shift: multiply by power of 2, panics on overflow"
              - c: "value >>= n;"
                rust: "value >>= n;"
                note: "Right shift: divide by power of 2, sign-extends signed"
              - c: "for (int i = 0; i < n; i++) { sum += arr[i]; }"
                rust: "for i in 0..n { sum += arr[i]; }"
                note: "Accumulation pattern in loops (most common use case)"
              - c: "arr[find_index()] += value;"
                rust: "arr[find_index()] += value;"
                note: "Complex lvalue: find_index() evaluated ONCE (same guarantee)"
            validation_reference: "K&R §2.10, ISO C99 §6.5.16.2"
            test_name: "test_compound_assignment"
            test_file: "compound_assignment_documentation_test.rs"
            sprint: 2
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "COMPREHENSIVE DOCUMENTATION: All 10 compound assignment operators (+=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=) with 100% coverage. Critical differences: (1) C signed overflow is UNDEFINED BEHAVIOR, Rust panics in debug/wraps in release (well-defined), (2) Rust REQUIRES mut (compile-time check), C mutable by default, (3) Rust requires compatible types (compile error), C allows implicit conversions, (4) Division/modulo by zero: C is UNDEFINED BEHAVIOR, Rust panics safely. Same syntax as C. Left operand evaluated once (same guarantee, critical for side effects). Test file demonstrates: all 10 operators, loop accumulation, array elements, complex lvalues, multiple assignments, type safety, mutability requirements. All transformations safe (0 unsafe blocks). Arithmetic operators panic on overflow/div-by-zero in debug. Bitwise operators common for flags, masks, bit manipulation."

  - id: 5
    name: "Statements (C99 §6.8)"
    description: "Control flow, iteration, jumps"
    sections:
      - id: "5.1"
        name: "Expression Statements (C99 §6.8.3)"
        tasks:
          - id: "STMT-EXPR"
            title: "Document expression statements"
            status: "completed"
            version: "v0.1.0"
            examples:
              - c: "x = 5;"
                rust: "x = 5;"
            validation_reference: "K&R §3.2, ISO C99 §6.8.3"
            test_name: "test_expression_statement"

          - id: "STMT-MIXED-DECL"
            title: "Document mixed declarations and code"
            status: "completed"
            priority: "high"
            version: "v0.39.0"
            examples:
              - c: "int x = 10; printf(\"%d\", x); int y = 20;"
                rust: "let x = 10; println!(\"{}\", x); let y = 20;"
                note: "C99 allows declarations anywhere (C89/K&R required at block start)"
              - c: "for (int i = 0; i < n; i++) { int value = get(i); use(value); }"
                rust: "for i in 0..n { let value = get(i); use(value); }"
                note: "Declare close to first use"
              - c: "if (cond) { printf(\"yes\"); } int x = 10;"
                rust: "if cond { println!(\"yes\"); } let x = 10;"
                note: "Declaration after control flow"
            validation_reference: "ISO C99 §6.8 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_mixed_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "C89/K&R required all declarations at block start. C99 removed this restriction (major improvement). Rust always allowed declarations anywhere (like C99). Both encourage 'declare near use' principle. Reduces variable scope → fewer bugs. More natural code flow. Purely syntactic - no semantic differences."

      - id: "5.2"
        name: "Selection Statements (C99 §6.8.4)"
        tasks:
          - id: "STMT-IF"
            title: "Document if statements"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "if (x > 0) { ... }"
                rust: "if x > 0 { ... }"
              - c: "if (x) { ... } else { ... }"
                rust: "if x != 0 { ... } else { ... }"
            validation_reference: "K&R §3.2, ISO C99 §6.8.4.1"
            test_name: "test_if_statement"

          - id: "STMT-IF-PATTERNS"
            title: "Document if/else statement patterns"
            status: "completed"
            priority: "high"
            version: "v0.54.0"
            examples:
              - c: "if (x > 0) { y = 1; }"
                rust: "if x > 0 { y = 1; }"
                note: "Simple if (boolean condition required in Rust)"
              - c: "if (x > 0) { y = 1; } else { y = 0; }"
                rust: "if x > 0 { y = 1; } else { y = 0; }"
                note: "If-else (same structure)"
              - c: "if (x >= 90) ... else if (x >= 80) ... else ..."
                rust: "if x >= 90 ... else if x >= 80 ... else ..."
                note: "Else-if chain (same structure)"
              - c: "if (x > 0) { if (y > 0) { ... } }"
                rust: "if x > 0 { if y > 0 { ... } }"
                note: "Nested if statements"
              - c: "if (x > 0 && y > 0) { ... }"
                rust: "if x > 0 && y > 0 { ... }"
                note: "Complex condition with logical operators"
              - c: "if (error) { return -1; }"
                rust: "if error { return -1; }"
                note: "Guard clause (early return)"
              - c: "if (x) stmt;"
                rust: "if x != 0 { stmt; }"
                note: "C int as bool → Rust explicit comparison"
              - c: "int r; if (c) r=1; else r=0;"
                rust: "let r = if c { 1 } else { 0 };"
                note: "Rust if as expression (can return value)"
              - c: "if (x = 5) { ... }"
                rust: "Compile error in Rust"
                note: "Assignment in condition prevented (common C bug)"
            validation_reference: "K&R §3.2, ISO C99 §6.8.4.1"
            test_name: "test_if_else_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "If/else statements: Nearly identical syntax in C and Rust. Key difference: C allows int as bool (0=false, non-zero=true), Rust requires explicit bool. Rust if is expression (can return value), C if is statement only. Rust always requires braces (prevents dangling else bugs). Rust prevents assignment in condition (compile error for if (x = 5)). Same else-binding rule (else binds to nearest if). All comparison and logical operators work identically. Common patterns: simple if, if-else, else-if chains, nested conditions, guard clauses. All transformations SAFE (0 unsafe blocks). Type-safe boolean conditions prevent common C bugs."

          - id: "STMT-SWITCH"
            title: "Document switch → match"
            status: "completed"
            version: "v0.8.0"
            priority: "high"
            examples:
              - c: "switch (x) { case 1: ...; break; default: ...; }"
                rust: "match x { 1 => { ... }, _ => { ... } }"
              - c: "switch (x) { case 1: return 10; case 2: return 20; }"
                rust: "match x { 1 => { return 10; }, 2 => { return 20; }, _ => {} }"
            validation_reference: "K&R §3.4, ISO C99 §6.8.4.2"
            test_name: "test_switch_to_match"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STMT-SWITCH-PATTERNS"
            title: "Document switch/match statement patterns"
            status: "completed"
            priority: "high"
            version: "v0.51.0"
            examples:
              - c: "switch (x) { case 1: y=10; break; default: y=0; }"
                rust: "match x { 1 => { y = 10; }, _ => { y = 0; } }"
                note: "Basic switch with break → match arm (no break needed)"
              - c: "switch (x) { case 1: return 10; }"
                rust: "match x { 1 => { return 10; }, _ => {} }"
                note: "Return in case (no break needed), Rust adds wildcard"
              - c: "switch (status) { case 200: ... case 404: ... default: ... }"
                rust: "match status { 200 => { ... }, 404 => { ... }, _ => { ... } }"
                note: "Multiple distinct cases"
              - c: "switch (x + 1) { case 2: ... }"
                rust: "match x + 1 { 2 => { ... }, _ => {} }"
                note: "Expression as condition"
              - c: "switch (c) { case 'a': ... break; }"
                rust: "match c { b'a' => { ... }, _ => {} }"
                note: "Character cases (byte literal in Rust)"
              - c: "case 1:\ncase 2:\n  action();\n  break;"
                rust: "1 | 2 => { action(); }"
                note: "C fallthrough → Rust OR pattern"
              - c: "for (...) { switch (i) { case 0: continue; } }"
                rust: "for ... { match i { 0 => { continue; }, _ => {} } }"
                note: "Continue in switch within loop"
              - c: "switch (state) { case INIT: next=RUN; break; }"
                rust: "match state { INIT => { next = RUN; }, _ => {} }"
                note: "State machine pattern"
              - c: "switch (code) { case -1: ... case 0: ... }"
                rust: "match code { -1 => { ... }, 0 => { ... }, _ => {} }"
                note: "Negative case values"
            validation_reference: "K&R §3.4, ISO C99 §6.8.4.2"
            test_name: "test_switch_match_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Switch → Match: C switch is statement with fallthrough (error-prone), Rust match is expression with no fallthrough (safe). C requires break to prevent fallthrough, Rust never falls through. C allows non-exhaustive switch, Rust requires wildcard (_) for exhaustiveness. C intentional fallthrough (case 1: case 2:) → Rust OR pattern (1 | 2). Match is expression (can return value). No break statements in Rust (not needed). Empty cases become empty blocks. Return in case needs no break. Expression conditions supported. Character cases use byte literals. State machines natural with match. All transformations SAFE (0 unsafe blocks). Key advantage: prevents fallthrough bugs (major C pitfall)."

      - id: "5.3"
        name: "Iteration Statements (C99 §6.8.5)"
        tasks:
          - id: "STMT-WHILE"
            title: "Document while loops"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "while (x < 10) { ... }"
                rust: "while x < 10 { ... }"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.1"
            test_name: "test_while_loop"

          - id: "STMT-WHILE-PATTERNS"
            title: "Document while loop patterns"
            status: "completed"
            priority: "high"
            version: "v0.52.0"
            examples:
              - c: "while (x < 10) { x++; }"
                rust: "while x < 10 { x += 1; }"
                note: "Basic while loop (pre-test, may execute 0 times)"
              - c: "while (x < 5 && y > 0) { ... }"
                rust: "while x < 5 && y > 0 { ... }"
                note: "Complex condition with logical operators"
              - c: "while (1) { if (done) break; }"
                rust: "while true { if done { break; } }"
                note: "Infinite loop with break (C int → Rust bool)"
              - c: "while (i < len) { if (skip) continue; process(i); i++; }"
                rust: "while i < len { if skip { continue; } process(i); i += 1; }"
                note: "Continue skips to next iteration"
              - c: "while (has_next()) { process(); }"
                rust: "while has_next() { process(); }"
                note: "Function call in condition"
              - c: "while (i < len) { sum += arr[i]; i++; }"
                rust: "while i < len { sum += arr[i]; i += 1; }"
                note: "Array processing pattern"
              - c: "while (arr[i] != 0) { process(arr[i]); i++; }"
                rust: "while arr[i] != 0 { process(arr[i]); i += 1; }"
                note: "Sentinel value pattern (loop until special value)"
              - c: "int found = 0; while (!found && i < n) { ... }"
                rust: "let mut found = false; while !found && i < n { ... }"
                note: "Boolean flag pattern (C int → Rust bool)"
              - c: "while (i < 10) { while (j < 10) { ... } }"
                rust: "while i < 10 { while j < 10 { ... } }"
                note: "Nested while loops"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.1"
            test_name: "test_while_loop_documentation"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "While loops: Pre-test loop (condition checked BEFORE body, may execute 0 times). C and Rust have similar syntax. Key difference: C allows int as bool (0=false, non-zero=true), Rust requires explicit bool. C while (1) → Rust while true or loop. C while (ptr) → Rust while ptr.is_some(). Both support break/continue. Common patterns: countdown, array processing, sentinel values, boolean flags, nested loops, function call conditions. All transformations SAFE (0 unsafe blocks). Type-safe boolean conditions prevent common C bugs."

          - id: "STMT-DO-WHILE"
            title: "Document do-while loops"
            status: "completed"
            priority: "high"
            version: "v0.43.0"
            examples:
              - c: "do { x = x + 1; } while (x < 5);"
                rust: "loop { x = x + 1; if !(x < 5) { break; } }"
                note: "Condition evaluated AFTER first iteration"
              - c: "do { process(); } while (should_continue());"
                rust: "loop { process(); if !should_continue() { break; } }"
                note: "Guaranteed at least one iteration"
              - c: "int x = 10; do { x++; } while (x < 5);"
                rust: "let mut x = 10; loop { x += 1; if !(x < 5) { break; } }"
                note: "Body executes once even when condition false"
            validation_reference: "K&R §3.6, ISO C99 §6.8.5.2"
            test_name: "test_do_while_loops"
            sprint: 5
            completed_date: "2025-10-16"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Do-while loops → loop with conditional break at end. Guaranteed at least one iteration (key difference from while). Condition evaluated AFTER body. break/continue work correctly. Rust has NO native do-while (use loop + if + break). All transformations SAFE (0 unsafe blocks)."

          - id: "STMT-FOR"
            title: "Document for loops"
            status: "completed"
            priority: "high"
            version: "v0.58.0"
            examples:
              - c: "for (int i = 0; i < 10; i++) { process(i); }"
                rust: "for i in 0..10 { process(i); }"
                note: "Simple counting: C three-part syntax → Rust range (more concise)"
              - c: "for (int i = 0; i <= 10; i++) { process(i); }"
                rust: "for i in 0..=10 { process(i); }"
                note: "Inclusive range: C <= → Rust ..= (explicit, prevents off-by-one errors)"
              - c: "for (int i = 0; i < 20; i += 2) { process(i); }"
                rust: "for i in (0..20).step_by(2) { process(i); }"
                note: "Custom step: C += 2 → Rust .step_by(2) method"
              - c: "for (int i = 10; i > 0; i--) { process(i); }"
                rust: "for i in (1..=10).rev() { process(i); }"
                note: "Reverse iteration: C decrement → Rust .rev() method"
              - c: "for (int i = 0; i < arr_len; i++) { sum += arr[i]; }"
                rust: "for &item in arr.iter() { sum += item; }"
                note: "Array iteration: C manual index → Rust iterator (safer, no bounds checking)"
              - c: "for (int i = 0; i < arr_len; i++) { printf(\"%d: %d\", i, arr[i]); }"
                rust: "for (i, &item) in arr.iter().enumerate() { println!(\"{}: {}\", i, item); }"
                note: "Index + value: C manual → Rust .enumerate() (provides both)"
              - c: "for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { matrix[i][j] = i * m + j; } }"
                rust: "for i in 0..n { for j in 0..m { matrix[i][j] = i * m + j; } }"
                note: "Nested loops: structure preserved, Rust range syntax cleaner"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] == target) break; }"
                rust: "for i in 0..n { if arr[i] == target { break; } }"
                note: "Loop with break: early exit works same in both"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] < 0) continue; sum += arr[i]; }"
                rust: "for i in 0..n { if arr[i] < 0 { continue; } sum += arr[i]; }"
                note: "Loop with continue: filter pattern works same in both"
              - c: "for (;;) { process(); if (done) break; }"
                rust: "loop { process(); if done { break; } }"
                note: "Infinite loop: C for(;;) → Rust loop keyword (more idiomatic)"
            validation_reference: "K&R §3.5, ISO C99 §6.8.5.3"
            test_name: "test_for_loop_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "For loops: C uses three-part syntax (init; condition; increment), Rust uses iterator-based range syntax (more concise and safer). Rust ranges: 0..n (exclusive), 0..=n (inclusive) - explicit syntax prevents off-by-one errors. Custom step: C uses += in increment, Rust uses .step_by() method. Reverse: C uses decrement, Rust uses .rev() method. Array iteration: C requires manual indexing (error-prone), Rust iterators guarantee safe access (no bounds checking needed). Enumerate: C needs separate index variable, Rust .enumerate() provides both index and value. Nested loops: both languages support, Rust syntax cleaner. Break/continue: work identically in both. Infinite loop: C for(;;) → Rust loop (more idiomatic). Iterator patterns: Rust can use functional style (.sum(), .filter(), .map()) instead of explicit loops - more expressive. All transformations type-safe (0 unsafe blocks). Rust for loops prevent common C bugs: off-by-one errors, out-of-bounds access, uninitialized loop variables."

          - id: "STMT-FOR-DECL"
            title: "Document for loop variable declarations"
            status: "completed"
            priority: "high"
            version: "v0.38.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { ... }"
                rust: "for i in 0..n { ... }"
                note: "C99 allows declarations in for loop (NOT in C89/K&R)"
              - c: "for (int i = 0; i < 20; i += 2) { ... }"
                rust: "for i in (0..20).step_by(2) { ... }"
                note: "Custom increment with step_by"
              - c: "for (int i = 10; i > 0; i--) { ... }"
                rust: "for i in (1..=10).rev() { ... }"
                note: "Reverse iteration"
              - c: "for (int i = 0; i < arr_len; i++) { arr[i] = ...; }"
                rust: "for (i, val) in arr.iter_mut().enumerate() { ... }"
                note: "Enumerate for index + value"
            validation_reference: "ISO C99 §6.8.5.3 (new in C99), NOT in K&R (pre-C99)"
            test_name: "test_for_loop_declarations"
            sprint: 5
            completed_date: "2025-10-15"
            tests_added: 16
            coverage: "100%"
            unsafe_blocks: 0
            note: "C99 added variable declarations in for loops (NOT in C89/K&R). Both C99 and Rust scope variable to loop body. Rust range syntax more concise. Rust iterators prevent off-by-one errors. step_by for custom increment, rev() for reverse, enumerate() for index+value."

      - id: "5.4"
        name: "Jump Statements (C99 §6.8.6)"
        tasks:
          - id: "STMT-RETURN"
            title: "Document return statements"
            status: "completed"
            priority: "high"
            version: "v0.55.0"
            examples:
              - c: "int get_value() { return 42; }"
                rust: "fn get_value() -> i32 { 42 }"
                note: "Idiomatic Rust: implicit return (no semicolon, no return keyword)"
              - c: "int add(int a, int b) { return a + b; }"
                rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
                note: "Expression return without keyword (more concise)"
              - c: "void process() { do_work(); return; }"
                rust: "fn process() { do_work(); }"
                note: "Unit return: C void → Rust (), return omitted"
              - c: "int divide(int a, int b) { if (b == 0) return -1; return a / b; }"
                rust: "fn divide(a: i32, b: i32) -> i32 { if b == 0 { return -1; } a / b }"
                note: "Guard clause: explicit return for early exit, implicit for success"
              - c: "int classify(int x) { if (x < 0) return -1; if (x == 0) return 0; return 1; }"
                rust: "fn classify(x: i32) -> i32 { if x < 0 { return -1; } if x == 0 { return 0; } 1 }"
                note: "Multiple guards: explicit for early exits, implicit for final case"
              - c: "int get_sign(int x) { if (x >= 0) { return 1; } else { return -1; } }"
                rust: "fn get_sign(x: i32) -> i32 { if x >= 0 { 1 } else { -1 } }"
                note: "If as expression: no return keywords needed (idiomatic)"
              - c: "int find(int arr[], int len, int x) { for (...) { if (arr[i] == x) return i; } return -1; }"
                rust: "fn find(arr: &[i32], x: i32) -> i32 { for (i, &val) in arr.iter().enumerate() { if val == x { return i as i32; } } -1 }"
                note: "Loop search: explicit return in loop, implicit for not-found"
              - c: "int wrapper(int x) { return process(x); }"
                rust: "fn wrapper(x: i32) -> i32 { process(x) }"
                note: "Function call result: implicit return (no keyword)"
              - c: "int max(int a, int b) { return (a > b) ? a : b; }"
                rust: "fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }"
                note: "Ternary → if expression: no return keyword needed"
              - c: "int handle_state(int s) { switch (s) { case 0: return 10; case 1: return 20; default: return -1; } }"
                rust: "fn handle_state(s: i32) -> i32 { match s { 0 => 10, 1 => 20, _ => -1, } }"
                note: "Match as expression: no return keywords in any arm"
            validation_reference: "K&R §4.1, ISO C99 §6.8.6.4"
            test_name: "test_return_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 17
            coverage: "100%"
            unsafe_blocks: 0
            note: "Return statements: Critical safety difference - C missing return is UNDEFINED BEHAVIOR, Rust enforces proper returns at compile time. Rust prefers implicit returns (expression without semicolon) for final values, explicit 'return' keyword for early exits. C requires 'return' keyword always. Idiomatic Rust: use if/match as expressions to avoid explicit returns. If-else with returns in both branches → if expression. Multiple early returns → guard clauses with explicit return, final case implicit. Loop search → explicit return when found, implicit for fall-through. Function call result → implicit return. All transformations type-safe (0 unsafe blocks). Key patterns: guard clauses, if expressions, match expressions, loop early exit, void/unit functions."

          - id: "STMT-BREAK"
            title: "Document break statements"
            status: "completed"
            priority: "high"
            version: "v0.56.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { if (condition) break; }"
                rust: "for i in 0..n { if condition { break; } }"
                note: "Simple loop break: identical syntax in both languages"
              - c: "while (1) { process(); if (done) break; }"
                rust: "loop { process(); if done { break; } }"
                note: "Infinite loop with break: C while(1) → Rust loop"
              - c: "switch (x) { case 1: handle(); break; case 2: process(); break; }"
                rust: "match x { 1 => handle(), 2 => process(), _ => {} }"
                note: "C switch REQUIRES break, Rust match doesn't (no fallthrough)"
              - c: "int found = 0; for (...) { for (...) { if (match) { found = 1; break; } } if (found) break; }"
                rust: "'outer: for ... { for ... { if match { break 'outer; } } }"
                note: "Nested loops: C needs flag variable, Rust has labeled break"
              - c: "for (int i = 0; i < len; i++) { if (arr[i] == target) { result = i; break; } }"
                rust: "for i in 0..len { if arr[i] == target { result = i; break; } }"
                note: "Search pattern: break when found (same in both)"
              - c: "while (has_data()) { int val = read(); if (val == ERROR) break; process(val); }"
                rust: "while has_data() { let val = read(); if val == ERROR { break; } process(val); }"
                note: "Error detection: early exit on error condition"
              - c: "int count = 0; while (1) { process(); count++; if (count >= MAX) break; }"
                rust: "let mut count = 0; loop { process(); count += 1; if count >= MAX { break; } }"
                note: "Limit check: break when counter reaches limit"
              - c: "while (running) { if (check_early()) break; step1(); if (should_stop()) break; step2(); }"
                rust: "while running { if check_early() { break; } step1(); if should_stop() { break; } step2(); }"
                note: "Multiple breaks: different exit conditions at different points"
              - c: "int result = -1; for (int i = 0; i < n; i++) { if (arr[i] > 0) { result = arr[i]; break; } }"
                rust: "let result = 'search: loop { for i in 0..n { if arr[i] > 0 { break 'search arr[i]; } } break -1; };"
                note: "Break with value (Rust only): C needs variable, Rust can break with value"
              - c: "for (int i = 0; i < n; i++) { if (arr[i] == x) { arr[i] = NEW; found_index = i; break; } }"
                rust: "for i in 0..n { if arr[i] == x { arr[i] = NEW; found_index = i; break; } }"
                note: "Modify then break: multiple statements before break"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.3"
            test_name: "test_break_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Break statements: Used to exit loops and switch statements. C and Rust have similar break syntax for simple loops, but key differences exist. C switch REQUIRES break after each case (prevents fallthrough bugs), Rust match doesn't need break (no fallthrough possible). Nested loops: C requires flag variable + two breaks, Rust has labeled break ('outer:) for direct outer loop exit - more concise and clear. Break with value: Rust only feature, can break with value from loop expression (more functional style). C needs variable to store result before break. Common patterns: search and exit, error detection, limit checks, nested loop exit. All transformations type-safe (0 unsafe blocks). Rust labeled break eliminates need for flag variables in nested loops."

          - id: "STMT-CONTINUE"
            title: "Document continue statements"
            status: "completed"
            priority: "high"
            version: "v0.57.0"
            examples:
              - c: "for (int i = 0; i < n; i++) { if (arr[i] < 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] < 0 { continue; } process(arr[i]); }"
                note: "Simple continue: identical syntax, skip to next iteration"
              - c: "for (i = 0; i < n; i++) { if (arr[i] == SKIP) continue; if (arr[i] == 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] == SKIP { continue; } if arr[i] == 0 { continue; } process(arr[i]); }"
                note: "Filter pattern: multiple continues for sequential filtering"
              - c: "while (has_data()) { int val = get_next(); if (is_invalid(val)) continue; process(val); }"
                rust: "while has_data() { let val = get_next(); if is_invalid(val) { continue; } process(val); }"
                note: "While loop continue: validation pattern, skip invalid data"
              - c: "while (1) { int val = read(); if (val == 0) continue; if (val < 0) break; process(val); }"
                rust: "loop { let val = read(); if val == 0 { continue; } if val < 0 { break; } process(val); }"
                note: "Infinite loop: C while(1) → Rust loop, continue and break together"
              - c: "for (i = 0; i < n; i++) { if (arr[i] < MIN || arr[i] > MAX) continue; process(arr[i]); }"
                rust: "for i in 0..n { if arr[i] < MIN || arr[i] > MAX { continue; } process(arr[i]); }"
                note: "Complex condition: range check with logical operators"
              - c: "for (i = 0; i < n; i++) { count++; if (arr[i] == 0) continue; process(arr[i]); }"
                rust: "for i in 0..n { count += 1; if arr[i] == 0 { continue; } process(arr[i]); }"
                note: "Partial processing: continue after some operations, not always at start"
              - c: "for (i = 0; i < n; i++) { for (j = 0; j < m; j++) { if (matrix[i][j] == 0) continue; process(matrix[i][j]); } }"
                rust: "for i in 0..n { for j in 0..m { if matrix[i][j] == 0 { continue; } process(matrix[i][j]); } }"
                note: "Nested loops: continue only affects innermost loop (same in both)"
              - c: "int skip = 0; for (i = 0; i < n; i++) { for (j = 0; j < m; j++) { if (condition) { skip = 1; break; } } if (skip) { skip = 0; continue; } process(i); }"
                rust: "'outer: for i in 0..n { for j in 0..m { if condition { continue 'outer; } } process(i); }"
                note: "Labeled continue (Rust): C needs flag + break + continue, Rust skips outer iteration directly"
              - c: "for (i = 0; i < n; i++) { if (!is_valid(arr[i])) continue; if (arr[i] == NULL) continue; process(arr[i]); }"
                rust: "for i in 0..n { if !is_valid(arr[i]) { continue; } if arr[i].is_none() { continue; } process(arr[i]); }"
                note: "Validation pattern: skip items that fail validation checks"
              - c: "for (i = 0; i < len; i++) { char c = str[i]; if (c == ' ') continue; if (c == '\\t') continue; process(c); }"
                rust: "for i in 0..len { let c = str[i]; if c == b' ' { continue; } if c == b'\\t' { continue; } process(c); }"
                note: "Character processing: skip whitespace characters"
            validation_reference: "K&R §3.7, ISO C99 §6.8.6.2"
            test_name: "test_continue_statement_documentation"
            sprint: 5
            completed_date: "2025-10-17"
            tests_added: 15
            coverage: "100%"
            unsafe_blocks: 0
            note: "Continue statements: Skip to next iteration of loop. C and Rust have identical syntax for simple cases. Common in filter/skip patterns, validation, guard clauses. Both skip to next iteration of innermost loop only. Labeled continue (Rust only): skip outer loop iteration from inner loop directly - more concise than C flag pattern. C requires flag variable + break + outer continue check (verbose). Rust 'outer: continue 'outer eliminates flag variables. For loop: C jumps to increment then condition, Rust advances iterator. While loop: both jump back to condition check. Iterator patterns: Rust can use .filter() instead of explicit continue (more functional). All transformations type-safe (0 unsafe blocks). Continue complementary to break: break exits loop, continue skips to next iteration."

          - id: "STMT-GOTO"
            title: "Document goto → eliminate or loop/match"
            status: "completed"
            priority: "low"
            version: "v0.22.0"
            examples:
              - c: "if (err) goto cleanup; ... cleanup: free(p);"
                rust: "let p = Box::new(0); // RAII cleanup via Drop"
              - c: "for (...) { if (found) goto done; } done: ..."
                rust: "'outer: for ... { break 'outer; }"
              - c: "state1: ... goto state2; state2: ..."
                rust: "loop { match state { State1 => ..., State2 => ... } }"
            validation_reference: "K&R §3.8, ISO C99 §6.8.6.1"
            test_name: "test_goto_documentation"
            sprint: 4
            completed_date: "2025-10-15"
            tests_added: 12
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - goto eliminated via Result+RAII (error handling), labeled break (nested loops), loop+match (state machines), loop+continue (retry logic), if restructuring (forward jumps). Rust has NO goto statement."

  - id: 6
    name: "Functions (C99 §6.9.1)"
    description: "Function declarations, definitions, parameters"
    tasks:
      - id: "FUNC-DECL"
        title: "Document function declarations"
        status: "completed"
        version: "v0.64.0"
        examples:
          - c: "int add(int a, int b) { return a + b; }"
            rust: "fn add(a: i32, b: i32) -> i32 { a + b }"
            note: "Simple function: implicit return (no semicolon)"
          - c: "void print(int x) { printf(\"%d\", x); }"
            rust: "fn print(x: i32) { println!(\"{}\", x); }"
            note: "Void function: omit return type (defaults to unit ())"
          - c: "int get_value(void) { return 42; }"
            rust: "fn get_value() -> i32 { 42 }"
            note: "No parameters: empty () (not void)"
          - c: "int divide(int a, int b) { if (b == 0) return -1; return a / b; }"
            rust: "fn divide(a: i32, b: i32) -> i32 { if b == 0 { return -1; } a / b }"
            note: "Early return: explicit return keyword, final value implicit"
          - c: "int is_even(int x) { return x % 2 == 0; }"
            rust: "fn is_even(x: i32) -> bool { x % 2 == 0 }"
            note: "Boolean: return bool (not int), simplify to direct expression"
          - c: "float avg(float a, float b) { return (a + b) / 2.0f; }"
            rust: "fn avg(a: f32, b: f32) -> f32 { (a + b) / 2.0 }"
            note: "Floating point: float → f32, double → f64"
          - c: "int fib(int n) { if (n <= 1) return n; return fib(n-1) + fib(n-2); }"
            rust: "fn fib(n: i32) -> i32 { if n <= 1 { return n; } fib(n-1) + fib(n-2) }"
            note: "Recursion: same pattern, works identically"
          - c: "int sum(int arr[], int n) { int s = 0; for (int i = 0; i < n; i++) s += arr[i]; return s; }"
            rust: "fn sum(arr: &[i32]) -> i32 { let mut s = 0; for &item in arr { s += item; } s }"
            note: "Array parameter: pointer+length → slice (&[T]), no separate length needed"
          - c: "static int helper(int x) { return x * 2; }"
            rust: "fn helper(x: i32) -> i32 { x * 2 }"
            note: "Static function: module-private by default (no pub), static keyword not needed"
        validation_reference: "K&R §4.1, ISO C99 §6.9.1"
        test_name: "test_function_declaration"
        test_file: "function_declaration_documentation_test.rs"
        completed_date: "2025-10-17"
        tests_added: 17
        coverage: "100%"
        unsafe_blocks: 0
        note: "COMPREHENSIVE DOCUMENTATION: Function declarations and definitions with 100% coverage. Critical differences: (1) Rust has no separate declarations (definition = declaration, modules replace headers), (2) void → omit return type (defaults to unit ()), (3) No parameters: empty () not void, (4) Implicit returns idiomatic (expression without semicolon), explicit return for early exits, (5) No forward declarations needed (order independent within module), (6) Array parameters: pointer+length → slices (&[T]) with built-in length. Same syntax for calls. Type-safe parameters (no implicit conversions). Test file demonstrates: simple returns, void functions, no parameters, multiple parameters, early returns, booleans, floats/doubles, mixed types, function composition, complex bodies, recursion, multiple return paths, array parameters, static functions. All transformations safe (0 unsafe blocks). Rust more concise and type-safe."

      - id: "FUNC-DEF"
        title: "Document function definitions"
        status: "completed"
        version: "v0.64.0"
        note: "Combined with FUNC-DECL (v0.64.0) - Rust has no distinction between declaration and definition"

      - id: "FUNC-VOID-PARAMS"
        title: "Document void parameter lists"
        status: "completed"
        version: "v0.64.0"
        note: "Combined with FUNC-DECL (v0.64.0) - covered in comprehensive function documentation"

      - id: "FUNC-VARIADIC"
        title: "Document variadic functions"
        status: "completed"
        priority: "low"
        version: "v0.21.0"
        examples:
          - c: "int sum(int count, ...);"
            rust: "fn sum(values: &[i32]) -> i32 { values.iter().sum() }"
          - c: "int printf(const char* fmt, ...);"
            rust: "println!(...) or custom macro_rules!"
        validation_reference: "K&R §7.3, ISO C99 §6.9.1, §7.15"
        test_name: "test_variadic_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - variadic functions transform to slices (homogeneous), macros (format strings), or tuples (fixed arity). C's runtime variadic replaced with compile-time type safety."

      - id: "FUNC-INLINE"
        title: "Document inline functions"
        status: "completed"
        priority: "medium"
        version: "v0.36.0"
        examples:
          - c: "inline int add(int a, int b) { return a + b; }"
            rust: "#[inline] fn add(a: i32, b: i32) -> i32 { a + b }"
            note: "C99 inline keyword → Rust #[inline] attribute"
          - c: "static inline int max(int a, int b) { return (a > b) ? a : b; }"
            rust: "#[inline] fn max(a: i32, b: i32) -> i32 { if a > b { a } else { b } }"
            note: "static inline → #[inline] with appropriate visibility"
          - c: "inline __attribute__((always_inline)) int double_value(int x) { return x * 2; }"
            rust: "#[inline(always)] fn double_value(x: i32) -> i32 { x * 2 }"
            note: "GCC always_inline → #[inline(always)]"
          - c: "__attribute__((noinline)) int complex_calculation(int x) { return x * x + x * 2 + 1; }"
            rust: "#[inline(never)] fn complex_calculation(x: i32) -> i32 { x * x + x * 2 + 1 }"
            note: "GCC noinline → #[inline(never)]"
        validation_reference: "ISO C99 §6.7.4 (new in C99), NOT in K&R (pre-C99)"
        test_name: "test_inline_functions"
        sprint: 5
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "C99 inline functions → Rust #[inline] attribute. Both are optimization hints (not guarantees). Rust compiler excellent at auto-inlining without hints. const fn provides compile-time evaluation (more powerful). Generic functions implicitly inline-eligible. All transformations SAFE (0 unsafe blocks)."

  - id: 7
    name: "Standard Library (C99 §7)"
    description: "stdio, stdlib, string, etc."
    sections:
      - id: "7.1"
        name: "stdio.h (C99 §7.19)"
        tasks:
          - id: "STDLIB-PRINTF"
            title: "Document printf → println!"
            status: "completed"
            version: "v0.2.0"
            examples:
              - c: "printf(\"Value: %d\\n\", x);"
                rust: "println!(\"Value: {}\", x);"
            validation_reference: "K&R §7.2, ISO C99 §7.19.6.1"
            test_name: "test_printf_to_println"

          - id: "STDLIB-SCANF"
            title: "Document scanf → read from stdin"
            status: "completed"
            priority: "low"
            version: "v0.19.0"
            examples:
              - c: "scanf(\"%d\", &x);"
                rust: "io::stdin().read_line(&mut buffer).unwrap(); let x: i32 = buffer.trim().parse().unwrap();"
            validation_reference: "K&R §7.4, ISO C99 §7.19.6.2"
            test_name: "test_scanf_documentation"
            sprint: 3
            completed_date: "2025-10-15"
            tests_added: 14
            coverage: "100%"
            unsafe_blocks: 0
            note: "Documentation-only task - scanf transforms to stdin().read_line() + parse(), eliminating buffer overflow risks"

      - id: "7.2"
        name: "stdlib.h (C99 §7.20)"
        tasks:
          - id: "STDLIB-MALLOC"
            title: "Document malloc → Box/Vec"
            status: "completed"
            version: "v0.3.0"
            examples:
              - c: "int* p = malloc(sizeof(int));"
                rust: "let p = Box::new(0i32);"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.3"
            test_name: "test_malloc_to_box"
            completed_ticket: "DECY-044"

          - id: "STDLIB-FREE"
            title: "Document free → automatic Drop"
            status: "completed"
            version: "v0.6.0"
            examples:
              - c: "free(p);"
                rust: "// Automatic when Box/Vec goes out of scope"
            validation_reference: "K&R §8.7, ISO C99 §7.20.3.2"
            test_name: "test_free_elimination"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-CALLOC"
            title: "Document calloc → Vec::with_capacity"
            status: "completed"
            version: "v0.5.0"
            priority: "high"
            examples:
              - c: "int* arr = calloc(n, sizeof(int));"
                rust: "let arr = vec![0i32; n];"
            validation_reference: "ISO C99 §7.20.3.1"
            test_name: "test_calloc_to_vec"
            sprint: 1
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"

          - id: "STDLIB-REALLOC"
            title: "Document realloc → Vec methods"
            status: "completed"
            version: "v0.7.0"
            priority: "medium"
            examples:
              - c: "p = realloc(p, new_size);"
                rust: "vec.resize(new_size, default);"
              - c: "p = realloc(p, 0);"
                rust: "vec.clear(); // Free equivalent"
              - c: "p = realloc(NULL, size);"
                rust: "let p = vec![0i32; count];"
            validation_reference: "ISO C99 §7.20.3.4"
            test_name: "test_realloc_to_vec_resize"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 7
            coverage: "100%"
            unsafe_blocks: 0

      - id: "7.3"
        name: "string.h (C99 §7.21)"
        tasks:
          - id: "STDLIB-STRLEN"
            title: "Document strlen → .len()"
            status: "completed"
            version: "v0.13.0"
            priority: "medium"
            examples:
              - c: "size_t len = strlen(s);"
                rust: "let len = s.len();"
            validation_reference: "K&R §B3, ISO C99 §7.21.6.3"
            test_name: "test_strlen_to_len"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 8
            coverage: "100%"
            unsafe_blocks: 0

          - id: "STDLIB-STRCPY"
            title: "Document strcpy → String/clone"
            status: "completed"
            version: "v0.14.0"
            priority: "medium"
            examples:
              - c: "strcpy(dest, src);"
                rust: "dest = src.to_string();"
            validation_reference: "K&R §B3, ISO C99 §7.21.3.1"
            test_name: "test_strcpy_transformation"
            sprint: 2
            completed_date: "2025-10-15"
            tests_added: 9
            coverage: "100%"
            unsafe_blocks: 0

  - id: 8
    name: "Preprocessor (C99 §6.10)"
    description: "#define, #include, #ifdef, etc."
    tasks:
      - id: "PREP-INCLUDE"
        title: "Document #include → use statements"
        status: "completed"
        priority: "high"
        version: "v0.17.0"
        examples:
          - c: "#include <stdio.h>"
            rust: "// Built-in, no import needed"
          - c: "#include \"myheader.h\""
            rust: "mod mymodule;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.2"
        test_name: "test_include_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 10
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - system headers map to built-ins, local headers become modules"

      - id: "PREP-DEFINE-CONST"
        title: "Document #define constants → const"
        status: "completed"
        priority: "high"
        version: "v0.16.0"
        examples:
          - c: "#define MAX 100"
            rust: "const MAX: i32 = 100;"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_const"
        sprint: 2
        completed_date: "2025-10-15"
        tests_added: 11
        coverage: "100%"
        unsafe_blocks: 0

      - id: "PREP-DEFINE-MACRO"
        title: "Document #define macros → functions or macros"
        status: "completed"
        priority: "medium"
        version: "v0.18.0"
        examples:
          - c: "#define SQR(x) ((x) * (x))"
            rust: "fn sqr(x: i32) -> i32 { x * x }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.3"
        test_name: "test_define_macro_documentation"
        sprint: 3
        completed_date: "2025-10-15"
        tests_added: 16
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - expression macros become functions, statement macros become macro_rules! or use std library"

      - id: "PREP-IFDEF"
        title: "Document #ifdef → cfg"
        status: "completed"
        priority: "low"
        version: "v0.23.0"
        examples:
          - c: "#ifdef DEBUG ... #endif"
            rust: "#[cfg(debug_assertions)] { ... }"
          - c: "#ifdef __linux__ ... #endif"
            rust: "#[cfg(target_os = \"linux\")] { ... }"
          - c: "#if defined(X) && !defined(Y) ... #endif"
            rust: "#[cfg(all(feature = \"x\", not(feature = \"y\")))] { ... }"
        validation_reference: "K&R §4.11, ISO C99 §6.10.1"
        test_name: "test_ifdef_documentation"
        sprint: 4
        completed_date: "2025-10-15"
        tests_added: 13
        coverage: "100%"
        unsafe_blocks: 0
        note: "Documentation-only task - #ifdef/#ifndef become cfg attributes. Rust cfg is type-aware (evaluated during compilation) unlike C's text-based preprocessor. Supports debug_assertions, target_os, target_arch, features (Cargo.toml), test, and complex combinators (all, any, not)."

completed_features:
  - title: "Basic types (int, float, char)"
    version: "v0.1.0"
    tasks: ["TYPE-BASIC-INT", "TYPE-BASIC-FLOAT"]
    tests: 5
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Integer and float literals"
    version: "v0.1.0"
    tasks: ["LEX-CONST-INT", "LEX-CONST-FLOAT"]
    tests: 6
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Basic arithmetic and comparison operators"
    version: "v0.1.0"
    tasks: ["EXPR-ARITH-BINARY", "EXPR-CMP-RELATIONAL", "EXPR-CMP-EQUALITY"]
    tests: 8
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Function declarations and definitions"
    version: "v0.1.0"
    tasks: ["FUNC-DECL", "FUNC-DEF", "FUNC-VOID-PARAMS"]
    tests: 4
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Control flow (if, while, for)"
    version: "v0.2.0"
    tasks: ["STMT-IF", "STMT-WHILE", "STMT-FOR"]
    tests: 12
    methodology: "EXTREME TDD"
    unsafe_blocks: 0

  - title: "Pointers and malloc/free → Box"
    version: "v0.3.0"
    tasks: ["TYPE-PTR-MALLOC", "STDLIB-MALLOC", "STDLIB-FREE"]
    tests: 9
    methodology: "EXTREME TDD + Ownership Inference"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

  - title: "sizeof operator"
    version: "v0.3.0"
    tasks: ["EXPR-UNARY-SIZEOF"]
    tests: 9
    methodology: "EXTREME TDD + Property Testing"
    unsafe_blocks: 0
    critical_ticket: "DECY-044"

high_priority_next_tasks:
  description: "Next 20 tasks to implement"
  tasks:
    - id: "TYPE-PTR-NULL"
      title: "NULL → Option<T>"
      priority: 1
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Eliminates null pointer dereferences"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STDLIB-CALLOC"
      title: "calloc → Vec::with_capacity"
      priority: 2
      status: "✅ COMPLETED (Sprint 1)"
      ownership_inference_impact: "HIGH"
      unsafe_reduction: "Pattern-based allocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "STMT-SWITCH"
      title: "switch → match"
      priority: 3
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 15

    - id: "TYPE-ARRAY-VLA"
      title: "Variable-length arrays → Vec"
      priority: 4
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Stack overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-ARITH-PTR"
      title: "Pointer arithmetic → slice indexing"
      priority: 5
      status: "🔶 BLOCKED - RED PHASE COMPLETE (Sprint 3)"
      phase: "RED"
      ownership_inference_impact: "CRITICAL"
      unsafe_reduction: "Eliminates pointer arithmetic"
      red_phase_date: "2025-10-15"
      tests_added: 9
      blocked_reason: "Needs ownership inference infrastructure"

    - id: "STDLIB-REALLOC"
      title: "realloc → Vec::resize"
      priority: 6
      status: "✅ COMPLETED (Sprint 2)"
      ownership_inference_impact: "MEDIUM"
      unsafe_reduction: "Pattern-based reallocation"
      completed_date: "2025-10-15"
      tests_added: 7

    - id: "EXPR-POSTFIX-INCR"
      title: "Post-increment/decrement"
      priority: 7
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "EXPR-UNARY-INCR"
      title: "Pre-increment/decrement"
      priority: 8
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "EXPR-ASSIGN-COMPOUND"
      title: "Compound assignment (+=, *=, etc.)"
      priority: 9
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "PREP-DEFINE-CONST"
      title: "#define constants → const"
      priority: 10
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "PREP-INCLUDE"
      title: "#include → use statements"
      priority: 11
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "None (module system)"
      completed_date: "2025-10-15"
      tests_added: 10

    - id: "PREP-DEFINE-MACRO"
      title: "#define macros → functions or macros"
      priority: 12
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type safety from functions"
      completed_date: "2025-10-15"
      tests_added: 16

    - id: "STDLIB-STRLEN"
      title: "strlen → .len()"
      priority: 13
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 8

    - id: "STDLIB-STRCPY"
      title: "strcpy → String/clone"
      priority: 14
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "Buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "TYPE-STRUCT-NESTED"
      title: "Nested structs"
      priority: 15
      status: "✅ COMPLETED (Sprint 2)"
      unsafe_reduction: "None (already safe)"
      completed_date: "2025-10-15"
      tests_added: 9

    - id: "STDLIB-SCANF"
      title: "scanf → stdin reading"
      priority: 16
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Type-safe parsing + buffer overflow prevention"
      completed_date: "2025-10-15"
      tests_added: 14

    - id: "FUNC-VARIADIC"
      title: "Variadic functions"
      priority: 17
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Type safety from macros or Vec (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 11

    - id: "STMT-GOTO"
      title: "goto elimination"
      priority: 18
      status: "✅ COMPLETED (Sprint 4)"
      unsafe_reduction: "Structured control flow (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "TYPE-QUAL-VOLATILE"
      title: "volatile → atomic"
      priority: 19
      status: "✅ COMPLETED (Sprint 3)"
      unsafe_reduction: "Atomic types are SAFE (0 unsafe for concurrency), MMIO requires unsafe"
      completed_date: "2025-10-15"
      tests_added: 12

    - id: "DECY-045"
      title: "Comprehensive sizeof edge case testing"
      priority: 20
      status: "✅ COMPLETED (Sprint 4)"
      type: "quality"
      unsafe_reduction: "Prevents parser bugs (0 unsafe blocks)"
      completed_date: "2025-10-15"
      tests_added: 24

next_steps:
  - "Start with TYPE-PTR-NULL (NULL → Option) in Sprint 1"
  - "Follow EXTREME TDD religiously (RED-GREEN-REFACTOR)"
  - "Pull ANDON CORD immediately when bugs found during validation"
  - "Track unsafe block count per sprint (target: <5 per 1000 LOC)"
  - "Use STOP THE LINE protocol for all validation failures"
  - "Document all transformations with C99/K&R references"
  - "Prioritize ownership inference improvements in decy-ownership crate"

status:
  overall: "IN_PROGRESS"
  completion_percent: 46
  completed_tasks: 69
  in_progress_tasks: 0
  blocked_tasks: 1
  not_started_tasks: 80
  total_tasks: 150
  methodology: "EXTREME TDD (RED-GREEN-REFACTOR) + Ownership Inference"
  goal: "100% C99 language coverage with <5 unsafe blocks per 1000 LOC"
  last_completed:
    task_id: "LEX-CONST-STR"
    title: "String literals comprehensive documentation"
    version: "v0.65.0"
    date: "2025-10-17"
    unsafe_blocks_added: 0
    tests_added: 15
    coverage: "100%"
  current_sprint: 5
  current_unsafe_count_per_1000_loc: 0
  target_unsafe_count_per_1000_loc: 5
